#include <cjson.h>
#include "protocommondata.h"
#include <dll/sdframework/sdframework.h>
#include <sstream>
CProtoCommonData::CProtoCommonData()
{
    m_vecMsgList.clear() ;
	memset(m_EncodeFuncArray, 0, sizeof(m_EncodeFuncArray));
	memset(m_DecodeFuncArray, 0, sizeof(m_DecodeFuncArray));
	m_iMaxPkgSize = 0;
	Init();
}

CProtoCommonData * CProtoCommonData::Instance()
{
   static CProtoCommonData oInst;
   return &oInst;
}

CProtoCommonData::~CProtoCommonData()
{
}

INT32 CProtoCommonData::Encode(INT32 iMsgID, void *pHost, CHAR *pNet, INT32 iNetSize)
{
	m_oData.Prepare(pNet, iNetSize, 1, 3, 1);

	EnFuncCProtoCommonData pfnEncode = FindEncodeFunc(iMsgID);
	if(NULL == pfnEncode)
		return -1;

	return (*pfnEncode)(pHost, &m_oData);
}

INT32 CProtoCommonData::Decode(INT32 iMsgID, CHAR *pNet,INT32 iNetSize, void *pHost, INT32 iHostSize)
{
	m_oData.Prepare(pNet, iNetSize, 1, 3, 1);
	if(iHostSize < m_iMaxPkgSize)
		return -1;

	DeFuncCProtoCommonData pfnDecode = FindDecodeFunc(iMsgID);
	if(NULL == pfnDecode)
		return -1;

	return (*pfnDecode)(pHost, &m_oData);
}

EnFuncCProtoCommonData CProtoCommonData::FindEncodeFunc(INT32 iMsgID)
{
	if(iMsgID - PROTOCOMMONDATA_MSGID_OFFSET >= PROTOCOMMONDATA_MSGID_RANGE)
		return NULL;
	return m_EncodeFuncArray[iMsgID - PROTOCOMMONDATA_MSGID_OFFSET];
}

DeFuncCProtoCommonData CProtoCommonData::FindDecodeFunc(INT32 iMsgID)
{
	if(iMsgID - PROTOCOMMONDATA_MSGID_OFFSET >= PROTOCOMMONDATA_MSGID_RANGE)
		return NULL;
	return m_DecodeFuncArray[iMsgID - PROTOCOMMONDATA_MSGID_OFFSET];
}

BOOL CProtoCommonData::Init()
{
	memset(m_EncodeFuncArray, 0, sizeof(m_EncodeFuncArray));
	memset(m_DecodeFuncArray, 0, sizeof(m_DecodeFuncArray));

	return true;
}

INT32 EncodeDT_RES_DATA(void *pHost, CNetData* poNetData)
{
	DT_RES_DATA *pstIn = (DT_RES_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byResKind))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwResValue))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RES_DATA(void *pHost, CNetData* poNetData)
{
	DT_RES_DATA *pstOut = (DT_RES_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byResKind))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwResValue))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RES_DATA(DT_RES_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ResKind", (double)(data.byResKind));
	cJSON_AddNumberToObject(root,"ResValue", (double)(data.qwResValue));

	return root;
}

INT32 DT_RES_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byResKind);
	memcpy(pDataBuff + dwOffset, &byResKind, sizeof(byResKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwResValue);
	memcpy(pDataBuff + dwOffset, &qwResValue, sizeof(qwResValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RES_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byResKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byResKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResKind, 0, sizeof(byResKind));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwResValue) >= pstIndex->dwContextLen)
				{
					memcpy(&qwResValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwResValue, 0, sizeof(qwResValue));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ITEM_DATA(void *pHost, CNetData* poNetData)
{
	DT_ITEM_DATA *pstIn = (DT_ITEM_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ITEM_DATA(void *pHost, CNetData* poNetData)
{
	DT_ITEM_DATA *pstOut = (DT_ITEM_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ITEM_DATA(DT_ITEM_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_ITEM_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ITEM_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RES_NUM_ITEM_DATA(void *pHost, CNetData* poNetData)
{
	DT_RES_NUM_ITEM_DATA *pstIn = (DT_RES_NUM_ITEM_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byResNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PLAYER_RES_NUM; i++)
	{
		if(i >= (INT32)pstIn->byResNum)
			break;
		if(-1 == EncodeDT_RES_DATA(&pstIn->astResList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byItemNum))
		return -1;

	for(i = 0; i < MAX_PLAYER_RES_NUM; i++)
	{
		if(i >= (INT32)pstIn->byItemNum)
			break;
		if(-1 == EncodeDT_ITEM_DATA(&pstIn->astItemList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RES_NUM_ITEM_DATA(void *pHost, CNetData* poNetData)
{
	DT_RES_NUM_ITEM_DATA *pstOut = (DT_RES_NUM_ITEM_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byResNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PLAYER_RES_NUM; i++)
	{
		if(i >= (INT32)pstOut->byResNum)
			break;
		if(-1 == DecodeDT_RES_DATA(&pstOut->astResList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byItemNum))
		return -1;

	for(i = 0; i < MAX_PLAYER_RES_NUM; i++)
	{
		if(i >= (INT32)pstOut->byItemNum)
			break;
		if(-1 == DecodeDT_ITEM_DATA(&pstOut->astItemList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RES_NUM_ITEM_DATA(DT_RES_NUM_ITEM_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ResNum", (double)(data.byResNum));
	cJSON *ResList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ResList", ResList);
	for( UINT32 dwIndex=0; dwIndex<data.byResNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ResList, " ", GetJsonDT_RES_DATA(data.astResList[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"ItemNum", (double)(data.byItemNum));
	cJSON *ItemList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ItemList", ItemList);
	for( UINT32 dwIndex=0; dwIndex<data.byItemNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ItemList, " ", GetJsonDT_ITEM_DATA(data.astItemList[dwIndex]));
	}

	return root;
}

INT32 DT_RES_NUM_ITEM_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byResNum);
	memcpy(pDataBuff + dwOffset, &byResNum, sizeof(byResNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byResNum > MAX_PLAYER_RES_NUM)
	{
		byResNum = MAX_PLAYER_RES_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byResNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byResNum; i++)
	{
		dwContextLenTmp += astResList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byItemNum);
	memcpy(pDataBuff + dwOffset, &byItemNum, sizeof(byItemNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(byItemNum > MAX_PLAYER_RES_NUM)
	{
		byItemNum = MAX_PLAYER_RES_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byItemNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byItemNum; i++)
	{
		dwContextLenTmp += astItemList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RES_NUM_ITEM_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byResNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byResNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResNum, 0, sizeof(byResNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byResNum)
				{
					wArrNum = wArrNum <= MAX_PLAYER_RES_NUM ? wArrNum : MAX_PLAYER_RES_NUM;
					byResNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astResList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astResList, 0, sizeof(astResList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astResList, 0, sizeof(astResList));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byItemNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byItemNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byItemNum, 0, sizeof(byItemNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byItemNum)
				{
					wArrNum = wArrNum <= MAX_PLAYER_RES_NUM ? wArrNum : MAX_PLAYER_RES_NUM;
					byItemNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astItemList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astItemList, 0, sizeof(astItemList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astItemList, 0, sizeof(astItemList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GUIDE_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_GUIDE_RECORD_DATA *pstIn = (DT_GUIDE_RECORD_DATA*)pHost;

	INT32 i;
	for(i = 0; i < MAX_GUIDE_NUM; i++)
	{
		if(-1 == poNetData->AddByte(pstIn->abyGuideRecordData[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GUIDE_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_GUIDE_RECORD_DATA *pstOut = (DT_GUIDE_RECORD_DATA*)pHost;

	INT32 i;
	for(i = 0; i < MAX_GUIDE_NUM; i++)
	{
		if(-1 == poNetData->DelByte(pstOut->abyGuideRecordData[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GUIDE_RECORD_DATA(DT_GUIDE_RECORD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON *GuideRecordData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GuideRecordData", GuideRecordData);
	for( UINT32 dwIndex=0; dwIndex<MAX_GUIDE_NUM; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"GuideRecordData", (double)(data.abyGuideRecordData[dwIndex]));
	}

	return root;
}

INT32 DT_GUIDE_RECORD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(abyGuideRecordData) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_GUIDE_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyGuideRecordData, sizeof(abyGuideRecordData));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GUIDE_RECORD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyGuideRecordData) >= dwContextLen) && (wArrNum <= MAX_GUIDE_NUM))
				{
					memcpy(&abyGuideRecordData, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyGuideRecordData, 0, sizeof(abyGuideRecordData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_BASE_DATA *pstIn = (DT_PLAYER_BASE_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszDispName, sizeof(pstIn->aszDispName)))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwCoin))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwGold))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStory))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPhyStrength))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwScience))
		return -1;

	if(-1 == EncodeDT_GUIDE_RECORD_DATA(&pstIn->stGuideRecordData, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byRobotFunc))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPower))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFirstAttack))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwTodayFirstLoginTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBagOpenNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBlueGas))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwPurpleGas))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byVipLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTotalAmount))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwJingJie))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwTotalRMB))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStudyExp))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwRecvRankEncTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwExtData))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFlowerSum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwMedal))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRMBGold))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRMBGoldGift))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGmGold))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wOriZoneID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_BASE_DATA *pstOut = (DT_PLAYER_BASE_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszDispName, sizeof(pstOut->aszDispName)))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwCoin))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwGold))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStory))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPhyStrength))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwScience))
		return -1;

	if(-1 == DecodeDT_GUIDE_RECORD_DATA(&pstOut->stGuideRecordData, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byRobotFunc))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPower))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFirstAttack))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwTodayFirstLoginTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBagOpenNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBlueGas))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwPurpleGas))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byVipLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTotalAmount))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwJingJie))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwTotalRMB))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStudyExp))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwRecvRankEncTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwExtData))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFlowerSum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwMedal))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRMBGold))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRMBGoldGift))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGmGold))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wOriZoneID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_BASE_DATA(DT_PLAYER_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ID", (double)(data.dwID));
	cJSON_AddStringToObject(root,"DispName", data.aszDispName );
	cJSON_AddNumberToObject(root,"Coin", (double)(data.qwCoin));
	cJSON_AddNumberToObject(root,"Gold", (double)(data.qwGold));
	cJSON_AddNumberToObject(root,"Story", (double)(data.qwStory));
	cJSON_AddNumberToObject(root,"PhyStrength", (double)(data.wPhyStrength));
	cJSON_AddNumberToObject(root,"Science", (double)(data.qwScience));
	cJSON_AddItemToObject(root, "GuideRecordData", GetJsonDT_GUIDE_RECORD_DATA(data.stGuideRecordData));
	cJSON_AddNumberToObject(root,"RobotFunc", (double)(data.byRobotFunc));
	cJSON_AddNumberToObject(root,"Power", (double)(data.dwPower));
	cJSON_AddNumberToObject(root,"FirstAttack", (double)(data.dwFirstAttack));
	cJSON_AddNumberToObject(root,"TodayFirstLoginTime", (double)(data.qwTodayFirstLoginTime));
	cJSON_AddNumberToObject(root,"BagOpenNum", (double)(data.byBagOpenNum));
	cJSON_AddNumberToObject(root,"BlueGas", (double)(data.qwBlueGas));
	cJSON_AddNumberToObject(root,"PurpleGas", (double)(data.qwPurpleGas));
	cJSON_AddNumberToObject(root,"VipLevel", (double)(data.byVipLevel));
	cJSON_AddNumberToObject(root,"TotalAmount", (double)(data.dwTotalAmount));
	cJSON_AddNumberToObject(root,"JingJie", (double)(data.qwJingJie));
	cJSON_AddNumberToObject(root,"TotalRMB", (double)(data.qwTotalRMB));
	cJSON_AddNumberToObject(root,"StudyExp", (double)(data.qwStudyExp));
	cJSON_AddNumberToObject(root,"RecvRankEncTime", (double)(data.qwRecvRankEncTime));
	cJSON_AddNumberToObject(root,"ExtData", (double)(data.dwExtData));
	cJSON_AddNumberToObject(root,"FlowerSum", (double)(data.dwFlowerSum));
	cJSON_AddNumberToObject(root,"Medal", (double)(data.qwMedal));
	cJSON_AddNumberToObject(root,"RMBGold", (double)(data.dwRMBGold));
	cJSON_AddNumberToObject(root,"RMBGoldGift", (double)(data.dwRMBGoldGift));
	cJSON_AddNumberToObject(root,"GmGold", (double)(data.dwGmGold));
	cJSON_AddNumberToObject(root,"OriZoneID", (double)(data.wOriZoneID));

	return root;
}

INT32 DT_PLAYER_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 28;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwID);
	memcpy(pDataBuff + dwOffset, &dwID, sizeof(dwID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(aszDispName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispName, sizeof(aszDispName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwCoin);
	memcpy(pDataBuff + dwOffset, &qwCoin, sizeof(qwCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwGold);
	memcpy(pDataBuff + dwOffset, &qwGold, sizeof(qwGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwStory);
	memcpy(pDataBuff + dwOffset, &qwStory, sizeof(qwStory));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wPhyStrength);
	memcpy(pDataBuff + dwOffset, &wPhyStrength, sizeof(wPhyStrength));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwScience);
	memcpy(pDataBuff + dwOffset, &qwScience, sizeof(qwScience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stGuideRecordData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byRobotFunc);
	memcpy(pDataBuff + dwOffset, &byRobotFunc, sizeof(byRobotFunc));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(dwPower);
	memcpy(pDataBuff + dwOffset, &dwPower, sizeof(dwPower));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(dwFirstAttack);
	memcpy(pDataBuff + dwOffset, &dwFirstAttack, sizeof(dwFirstAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(qwTodayFirstLoginTime);
	memcpy(pDataBuff + dwOffset, &qwTodayFirstLoginTime, sizeof(qwTodayFirstLoginTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(byBagOpenNum);
	memcpy(pDataBuff + dwOffset, &byBagOpenNum, sizeof(byBagOpenNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(qwBlueGas);
	memcpy(pDataBuff + dwOffset, &qwBlueGas, sizeof(qwBlueGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(qwPurpleGas);
	memcpy(pDataBuff + dwOffset, &qwPurpleGas, sizeof(qwPurpleGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = sizeof(byVipLevel);
	memcpy(pDataBuff + dwOffset, &byVipLevel, sizeof(byVipLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(dwTotalAmount);
	memcpy(pDataBuff + dwOffset, &dwTotalAmount, sizeof(dwTotalAmount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(qwJingJie);
	memcpy(pDataBuff + dwOffset, &qwJingJie, sizeof(qwJingJie));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 19;
	pstIndex->dwContextLen = sizeof(qwTotalRMB);
	memcpy(pDataBuff + dwOffset, &qwTotalRMB, sizeof(qwTotalRMB));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 20;
	pstIndex->dwContextLen = sizeof(qwStudyExp);
	memcpy(pDataBuff + dwOffset, &qwStudyExp, sizeof(qwStudyExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 21;
	pstIndex->dwContextLen = sizeof(qwRecvRankEncTime);
	memcpy(pDataBuff + dwOffset, &qwRecvRankEncTime, sizeof(qwRecvRankEncTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 22;
	pstIndex->dwContextLen = sizeof(dwExtData);
	memcpy(pDataBuff + dwOffset, &dwExtData, sizeof(dwExtData));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 23;
	pstIndex->dwContextLen = sizeof(dwFlowerSum);
	memcpy(pDataBuff + dwOffset, &dwFlowerSum, sizeof(dwFlowerSum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 24;
	pstIndex->dwContextLen = sizeof(qwMedal);
	memcpy(pDataBuff + dwOffset, &qwMedal, sizeof(qwMedal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 25;
	pstIndex->dwContextLen = sizeof(dwRMBGold);
	memcpy(pDataBuff + dwOffset, &dwRMBGold, sizeof(dwRMBGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 26;
	pstIndex->dwContextLen = sizeof(dwRMBGoldGift);
	memcpy(pDataBuff + dwOffset, &dwRMBGoldGift, sizeof(dwRMBGoldGift));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 27;
	pstIndex->dwContextLen = sizeof(dwGmGold);
	memcpy(pDataBuff + dwOffset, &dwGmGold, sizeof(dwGmGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 28;
	pstIndex->dwContextLen = sizeof(wOriZoneID);
	memcpy(pDataBuff + dwOffset, &wOriZoneID, sizeof(wOriZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwID, 0, sizeof(dwID));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispName, 0, sizeof(aszDispName));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&qwCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwCoin, 0, sizeof(qwCoin));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwGold) >= pstIndex->dwContextLen)
				{
					memcpy(&qwGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwGold, 0, sizeof(qwGold));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwStory) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStory, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStory, 0, sizeof(qwStory));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wPhyStrength) >= pstIndex->dwContextLen)
				{
					memcpy(&wPhyStrength, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPhyStrength, 0, sizeof(wPhyStrength));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwScience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwScience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwScience, 0, sizeof(qwScience));
				}
			}
			break;
		case 8:
			{
				stGuideRecordData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				if(sizeof(byRobotFunc) >= pstIndex->dwContextLen)
				{
					memcpy(&byRobotFunc, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRobotFunc, 0, sizeof(byRobotFunc));
				}
			}
			break;
		case 10:
			{
				if(sizeof(dwPower) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPower, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPower, 0, sizeof(dwPower));
				}
			}
			break;
		case 11:
			{
				if(sizeof(dwFirstAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFirstAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFirstAttack, 0, sizeof(dwFirstAttack));
				}
			}
			break;
		case 12:
			{
				if(sizeof(qwTodayFirstLoginTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwTodayFirstLoginTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwTodayFirstLoginTime, 0, sizeof(qwTodayFirstLoginTime));
				}
			}
			break;
		case 13:
			{
				if(sizeof(byBagOpenNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBagOpenNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBagOpenNum, 0, sizeof(byBagOpenNum));
				}
			}
			break;
		case 14:
			{
				if(sizeof(qwBlueGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBlueGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBlueGas, 0, sizeof(qwBlueGas));
				}
			}
			break;
		case 15:
			{
				if(sizeof(qwPurpleGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwPurpleGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwPurpleGas, 0, sizeof(qwPurpleGas));
				}
			}
			break;
		case 16:
			{
				if(sizeof(byVipLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byVipLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byVipLevel, 0, sizeof(byVipLevel));
				}
			}
			break;
		case 17:
			{
				if(sizeof(dwTotalAmount) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTotalAmount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTotalAmount, 0, sizeof(dwTotalAmount));
				}
			}
			break;
		case 18:
			{
				if(sizeof(qwJingJie) >= pstIndex->dwContextLen)
				{
					memcpy(&qwJingJie, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwJingJie, 0, sizeof(qwJingJie));
				}
			}
			break;
		case 19:
			{
				if(sizeof(qwTotalRMB) >= pstIndex->dwContextLen)
				{
					memcpy(&qwTotalRMB, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwTotalRMB, 0, sizeof(qwTotalRMB));
				}
			}
			break;
		case 20:
			{
				if(sizeof(qwStudyExp) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStudyExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStudyExp, 0, sizeof(qwStudyExp));
				}
			}
			break;
		case 21:
			{
				if(sizeof(qwRecvRankEncTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwRecvRankEncTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwRecvRankEncTime, 0, sizeof(qwRecvRankEncTime));
				}
			}
			break;
		case 22:
			{
				if(sizeof(dwExtData) >= pstIndex->dwContextLen)
				{
					memcpy(&dwExtData, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwExtData, 0, sizeof(dwExtData));
				}
			}
			break;
		case 23:
			{
				if(sizeof(dwFlowerSum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFlowerSum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFlowerSum, 0, sizeof(dwFlowerSum));
				}
			}
			break;
		case 24:
			{
				if(sizeof(qwMedal) >= pstIndex->dwContextLen)
				{
					memcpy(&qwMedal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwMedal, 0, sizeof(qwMedal));
				}
			}
			break;
		case 25:
			{
				if(sizeof(dwRMBGold) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRMBGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRMBGold, 0, sizeof(dwRMBGold));
				}
			}
			break;
		case 26:
			{
				if(sizeof(dwRMBGoldGift) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRMBGoldGift, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRMBGoldGift, 0, sizeof(dwRMBGoldGift));
				}
			}
			break;
		case 27:
			{
				if(sizeof(dwGmGold) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGmGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGmGold, 0, sizeof(dwGmGold));
				}
			}
			break;
		case 28:
			{
				if(sizeof(wOriZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&wOriZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wOriZoneID, 0, sizeof(wOriZoneID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTRIBUTE *pstIn = (DT_BATTLE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwHP))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAttack))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTRIBUTE *pstOut = (DT_BATTLE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwHP))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAttack))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ATTRIBUTE(DT_BATTLE_ATTRIBUTE &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HP", (double)(data.dwHP));
	cJSON_AddNumberToObject(root,"Attack", (double)(data.dwAttack));

	return root;
}

INT32 DT_BATTLE_ATTRIBUTE::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwHP);
	memcpy(pDataBuff + dwOffset, &dwHP, sizeof(dwHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwAttack);
	memcpy(pDataBuff + dwOffset, &dwAttack, sizeof(dwAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ATTRIBUTE::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHP, 0, sizeof(dwHP));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAttack, 0, sizeof(dwAttack));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ATTRIBUTE2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTRIBUTE2 *pstIn = (DT_BATTLE_ATTRIBUTE2*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwHP))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAttack))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDefend))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ATTRIBUTE2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTRIBUTE2 *pstOut = (DT_BATTLE_ATTRIBUTE2*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwHP))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAttack))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDefend))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ATTRIBUTE2(DT_BATTLE_ATTRIBUTE2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HP", (double)(data.dwHP));
	cJSON_AddNumberToObject(root,"Attack", (double)(data.dwAttack));
	cJSON_AddNumberToObject(root,"Defend", (double)(data.dwDefend));

	return root;
}

INT32 DT_BATTLE_ATTRIBUTE2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwHP);
	memcpy(pDataBuff + dwOffset, &dwHP, sizeof(dwHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwAttack);
	memcpy(pDataBuff + dwOffset, &dwAttack, sizeof(dwAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwDefend);
	memcpy(pDataBuff + dwOffset, &dwDefend, sizeof(dwDefend));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ATTRIBUTE2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHP, 0, sizeof(dwHP));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAttack, 0, sizeof(dwAttack));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwDefend) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDefend, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDefend, 0, sizeof(dwDefend));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_BASE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_BASE_ATTRIBUTE *pstIn = (DT_BATTLE_BASE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwHP))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAttack))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDefend))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_BASE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_BASE_ATTRIBUTE *pstOut = (DT_BATTLE_BASE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwHP))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAttack))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDefend))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_BASE_ATTRIBUTE(DT_BATTLE_BASE_ATTRIBUTE &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HP", (double)(data.qwHP));
	cJSON_AddNumberToObject(root,"Attack", (double)(data.dwAttack));
	cJSON_AddNumberToObject(root,"Defend", (double)(data.dwDefend));

	return root;
}

INT32 DT_BATTLE_BASE_ATTRIBUTE::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwHP);
	memcpy(pDataBuff + dwOffset, &qwHP, sizeof(qwHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwAttack);
	memcpy(pDataBuff + dwOffset, &dwAttack, sizeof(dwAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwDefend);
	memcpy(pDataBuff + dwOffset, &dwDefend, sizeof(dwDefend));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_BASE_ATTRIBUTE::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwHP) >= pstIndex->dwContextLen)
				{
					memcpy(&qwHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwHP, 0, sizeof(qwHP));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAttack, 0, sizeof(dwAttack));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwDefend) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDefend, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDefend, 0, sizeof(dwDefend));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HIDE_BATTLE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_HIDE_BATTLE_ATTRIBUTE *pstIn = (DT_HIDE_BATTLE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHitRate))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wDodgeRate))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCritRate))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wDeCritRate))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAngryValue))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HIDE_BATTLE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_HIDE_BATTLE_ATTRIBUTE *pstOut = (DT_HIDE_BATTLE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHitRate))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wDodgeRate))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCritRate))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wDeCritRate))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAngryValue))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HIDE_BATTLE_ATTRIBUTE(DT_HIDE_BATTLE_ATTRIBUTE &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HitRate", (double)(data.wHitRate));
	cJSON_AddNumberToObject(root,"DodgeRate", (double)(data.wDodgeRate));
	cJSON_AddNumberToObject(root,"CritRate", (double)(data.wCritRate));
	cJSON_AddNumberToObject(root,"DeCritRate", (double)(data.wDeCritRate));
	cJSON_AddNumberToObject(root,"AngryValue", (double)(data.wAngryValue));

	return root;
}

INT32 DT_HIDE_BATTLE_ATTRIBUTE::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHitRate);
	memcpy(pDataBuff + dwOffset, &wHitRate, sizeof(wHitRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wDodgeRate);
	memcpy(pDataBuff + dwOffset, &wDodgeRate, sizeof(wDodgeRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wCritRate);
	memcpy(pDataBuff + dwOffset, &wCritRate, sizeof(wCritRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wDeCritRate);
	memcpy(pDataBuff + dwOffset, &wDeCritRate, sizeof(wDeCritRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wAngryValue);
	memcpy(pDataBuff + dwOffset, &wAngryValue, sizeof(wAngryValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HIDE_BATTLE_ATTRIBUTE::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHitRate) >= pstIndex->dwContextLen)
				{
					memcpy(&wHitRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHitRate, 0, sizeof(wHitRate));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wDodgeRate) >= pstIndex->dwContextLen)
				{
					memcpy(&wDodgeRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDodgeRate, 0, sizeof(wDodgeRate));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wCritRate) >= pstIndex->dwContextLen)
				{
					memcpy(&wCritRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCritRate, 0, sizeof(wCritRate));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wDeCritRate) >= pstIndex->dwContextLen)
				{
					memcpy(&wDeCritRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDeCritRate, 0, sizeof(wDeCritRate));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wAngryValue) >= pstIndex->dwContextLen)
				{
					memcpy(&wAngryValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAngryValue, 0, sizeof(wAngryValue));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EXT_BATTLE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_EXT_BATTLE_ATTRIBUTE *pstIn = (DT_EXT_BATTLE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wIncHurtRate))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wDecHurtRate))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wOddAngry))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFirstAttack))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCoachTalent))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EXT_BATTLE_ATTRIBUTE(void *pHost, CNetData* poNetData)
{
	DT_EXT_BATTLE_ATTRIBUTE *pstOut = (DT_EXT_BATTLE_ATTRIBUTE*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wIncHurtRate))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wDecHurtRate))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wOddAngry))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFirstAttack))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCoachTalent))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EXT_BATTLE_ATTRIBUTE(DT_EXT_BATTLE_ATTRIBUTE &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"IncHurtRate", (double)(data.wIncHurtRate));
	cJSON_AddNumberToObject(root,"DecHurtRate", (double)(data.wDecHurtRate));
	cJSON_AddNumberToObject(root,"OddAngry", (double)(data.wOddAngry));
	cJSON_AddNumberToObject(root,"FirstAttack", (double)(data.dwFirstAttack));
	cJSON_AddNumberToObject(root,"CoachTalent", (double)(data.wCoachTalent));

	return root;
}

INT32 DT_EXT_BATTLE_ATTRIBUTE::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wIncHurtRate);
	memcpy(pDataBuff + dwOffset, &wIncHurtRate, sizeof(wIncHurtRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wDecHurtRate);
	memcpy(pDataBuff + dwOffset, &wDecHurtRate, sizeof(wDecHurtRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wOddAngry);
	memcpy(pDataBuff + dwOffset, &wOddAngry, sizeof(wOddAngry));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwFirstAttack);
	memcpy(pDataBuff + dwOffset, &dwFirstAttack, sizeof(dwFirstAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wCoachTalent);
	memcpy(pDataBuff + dwOffset, &wCoachTalent, sizeof(wCoachTalent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EXT_BATTLE_ATTRIBUTE::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wIncHurtRate) >= pstIndex->dwContextLen)
				{
					memcpy(&wIncHurtRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wIncHurtRate, 0, sizeof(wIncHurtRate));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wDecHurtRate) >= pstIndex->dwContextLen)
				{
					memcpy(&wDecHurtRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDecHurtRate, 0, sizeof(wDecHurtRate));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wOddAngry) >= pstIndex->dwContextLen)
				{
					memcpy(&wOddAngry, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wOddAngry, 0, sizeof(wOddAngry));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwFirstAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFirstAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFirstAttack, 0, sizeof(dwFirstAttack));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wCoachTalent) >= pstIndex->dwContextLen)
				{
					memcpy(&wCoachTalent, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCoachTalent, 0, sizeof(wCoachTalent));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_UPDATE_ATTR_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_UPDATE_ATTR_DATA *pstIn = (DT_HERO_UPDATE_ATTR_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wAttrHP))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttrAttack))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_UPDATE_ATTR_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_UPDATE_ATTR_DATA *pstOut = (DT_HERO_UPDATE_ATTR_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wAttrHP))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttrAttack))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_UPDATE_ATTR_DATA(DT_HERO_UPDATE_ATTR_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttrHP", (double)(data.wAttrHP));
	cJSON_AddNumberToObject(root,"AttrAttack", (double)(data.wAttrAttack));

	return root;
}

INT32 DT_HERO_UPDATE_ATTR_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wAttrHP);
	memcpy(pDataBuff + dwOffset, &wAttrHP, sizeof(wAttrHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAttrAttack);
	memcpy(pDataBuff + dwOffset, &wAttrAttack, sizeof(wAttrAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_UPDATE_ATTR_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wAttrHP) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttrHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttrHP, 0, sizeof(wAttrHP));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAttrAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttrAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttrAttack, 0, sizeof(wAttrAttack));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_ATTR_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_ATTR_DATA *pstIn = (DT_HERO_ATTR_DATA*)pHost;

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stBattleAttribute, poNetData))
		return -1;

	if(-1 == EncodeDT_HIDE_BATTLE_ATTRIBUTE(&pstIn->stHideBattleAttr, poNetData))
		return -1;

	if(-1 == EncodeDT_HERO_UPDATE_ATTR_DATA(&pstIn->stUpdateAttrInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_ATTR_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_ATTR_DATA *pstOut = (DT_HERO_ATTR_DATA*)pHost;

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stBattleAttribute, poNetData))
		return -1;

	if(-1 == DecodeDT_HIDE_BATTLE_ATTRIBUTE(&pstOut->stHideBattleAttr, poNetData))
		return -1;

	if(-1 == DecodeDT_HERO_UPDATE_ATTR_DATA(&pstOut->stUpdateAttrInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_ATTR_DATA(DT_HERO_ATTR_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "BattleAttribute", GetJsonDT_BATTLE_ATTRIBUTE(data.stBattleAttribute));
	cJSON_AddItemToObject(root, "HideBattleAttr", GetJsonDT_HIDE_BATTLE_ATTRIBUTE(data.stHideBattleAttr));
	cJSON_AddItemToObject(root, "UpdateAttrInfo", GetJsonDT_HERO_UPDATE_ATTR_DATA(data.stUpdateAttrInfo));

	return root;
}

INT32 DT_HERO_ATTR_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stBattleAttribute.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stHideBattleAttr.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stUpdateAttrInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_ATTR_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stBattleAttribute.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stHideBattleAttr.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stUpdateAttrInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SPECIAL_EFFECT_DATA(void *pHost, CNetData* poNetData)
{
	DT_SPECIAL_EFFECT_DATA *pstIn = (DT_SPECIAL_EFFECT_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEffectID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsActivity))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySkillNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SKILL_SOUL_NUM; i++)
	{
		if(i >= (INT32)pstIn->bySkillNum)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyEffectSmallType[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SPECIAL_EFFECT_DATA(void *pHost, CNetData* poNetData)
{
	DT_SPECIAL_EFFECT_DATA *pstOut = (DT_SPECIAL_EFFECT_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEffectID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsActivity))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySkillNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SKILL_SOUL_NUM; i++)
	{
		if(i >= (INT32)pstOut->bySkillNum)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyEffectSmallType[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SPECIAL_EFFECT_DATA(DT_SPECIAL_EFFECT_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EffectID", (double)(data.wEffectID));
	cJSON_AddNumberToObject(root,"IsActivity", (double)(data.byIsActivity));
	cJSON_AddNumberToObject(root,"SkillNum", (double)(data.bySkillNum));
	cJSON *EffectSmallType = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EffectSmallType", EffectSmallType);
	for( UINT32 dwIndex=0; dwIndex<data.bySkillNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"EffectSmallType", (double)(data.abyEffectSmallType[dwIndex]));
	}

	return root;
}

INT32 DT_SPECIAL_EFFECT_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEffectID);
	memcpy(pDataBuff + dwOffset, &wEffectID, sizeof(wEffectID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byIsActivity);
	memcpy(pDataBuff + dwOffset, &byIsActivity, sizeof(byIsActivity));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(bySkillNum);
	memcpy(pDataBuff + dwOffset, &bySkillNum, sizeof(bySkillNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	if(bySkillNum > MAX_SKILL_SOUL_NUM)
	{
		bySkillNum = MAX_SKILL_SOUL_NUM;
	}
	pstIndex->dwContextLen = bySkillNum * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = bySkillNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyEffectSmallType, bySkillNum * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SPECIAL_EFFECT_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEffectID) >= pstIndex->dwContextLen)
				{
					memcpy(&wEffectID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEffectID, 0, sizeof(wEffectID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byIsActivity) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsActivity, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsActivity, 0, sizeof(byIsActivity));
				}
			}
			break;
		case 3:
			{
				if(sizeof(bySkillNum) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkillNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkillNum, 0, sizeof(bySkillNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyEffectSmallType) >= dwContextLen) && (wArrNum == bySkillNum) && (wArrNum <= MAX_SKILL_SOUL_NUM))
				{
					memcpy(&abyEffectSmallType, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyEffectSmallType, 0, sizeof(abyEffectSmallType));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SOUL_ATTR_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_ATTR_DATA *pstIn = (DT_SOUL_ATTR_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKindPrecent))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwKindValue))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SOUL_ATTR_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_ATTR_DATA *pstOut = (DT_SOUL_ATTR_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKindPrecent))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwKindValue))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SOUL_ATTR_DATA(DT_SOUL_ATTR_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.byKindID));
	cJSON_AddNumberToObject(root,"KindPrecent", (double)(data.byKindPrecent));
	cJSON_AddNumberToObject(root,"KindValue", (double)(data.dwKindValue));

	return root;
}

INT32 DT_SOUL_ATTR_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byKindID);
	memcpy(pDataBuff + dwOffset, &byKindID, sizeof(byKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byKindPrecent);
	memcpy(pDataBuff + dwOffset, &byKindPrecent, sizeof(byKindPrecent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwKindValue);
	memcpy(pDataBuff + dwOffset, &dwKindValue, sizeof(dwKindValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SOUL_ATTR_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&byKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKindID, 0, sizeof(byKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byKindPrecent) >= pstIndex->dwContextLen)
				{
					memcpy(&byKindPrecent, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKindPrecent, 0, sizeof(byKindPrecent));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwKindValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwKindValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwKindValue, 0, sizeof(dwKindValue));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SOUL_POTENCY_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_POTENCY_DATA *pstIn = (DT_SOUL_POTENCY_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPotencyLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPotencySubLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SOUL_POTENCY_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_POTENCY_DATA *pstOut = (DT_SOUL_POTENCY_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPotencyLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPotencySubLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SOUL_POTENCY_DATA(DT_SOUL_POTENCY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PotencyLevel", (double)(data.byPotencyLevel));
	cJSON_AddNumberToObject(root,"PotencySubLevel", (double)(data.byPotencySubLevel));

	return root;
}

INT32 DT_SOUL_POTENCY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPotencyLevel);
	memcpy(pDataBuff + dwOffset, &byPotencyLevel, sizeof(byPotencyLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byPotencySubLevel);
	memcpy(pDataBuff + dwOffset, &byPotencySubLevel, sizeof(byPotencySubLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SOUL_POTENCY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPotencyLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byPotencyLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPotencyLevel, 0, sizeof(byPotencyLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byPotencySubLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byPotencySubLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPotencySubLevel, 0, sizeof(byPotencySubLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SOUL_POTENCY_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_POTENCY_LST_DATA *pstIn = (DT_SOUL_POTENCY_LST_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSoulNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_BAG_NUM; i++)
	{
		if(i >= (INT32)pstIn->wSoulNum)
			break;
		if(-1 == EncodeDT_SOUL_POTENCY_DATA(&pstIn->astSoulPotencyLstData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SOUL_POTENCY_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_POTENCY_LST_DATA *pstOut = (DT_SOUL_POTENCY_LST_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSoulNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_BAG_NUM; i++)
	{
		if(i >= (INT32)pstOut->wSoulNum)
			break;
		if(-1 == DecodeDT_SOUL_POTENCY_DATA(&pstOut->astSoulPotencyLstData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SOUL_POTENCY_LST_DATA(DT_SOUL_POTENCY_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SoulNum", (double)(data.wSoulNum));
	cJSON *SoulPotencyLstData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulPotencyLstData", SoulPotencyLstData);
	for( UINT32 dwIndex=0; dwIndex<data.wSoulNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SoulPotencyLstData, " ", GetJsonDT_SOUL_POTENCY_DATA(data.astSoulPotencyLstData[dwIndex]));
	}

	return root;
}

INT32 DT_SOUL_POTENCY_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSoulNum);
	memcpy(pDataBuff + dwOffset, &wSoulNum, sizeof(wSoulNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wSoulNum > MAX_SOUL_BAG_NUM)
	{
		wSoulNum = MAX_SOUL_BAG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wSoulNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wSoulNum; i++)
	{
		dwContextLenTmp += astSoulPotencyLstData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SOUL_POTENCY_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSoulNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wSoulNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSoulNum, 0, sizeof(wSoulNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wSoulNum)
				{
					wArrNum = wArrNum <= MAX_SOUL_BAG_NUM ? wArrNum : MAX_SOUL_BAG_NUM;
					wSoulNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSoulPotencyLstData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSoulPotencyLstData, 0, sizeof(astSoulPotencyLstData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSoulPotencyLstData, 0, sizeof(astSoulPotencyLstData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SOUL_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_DATA *pstIn = (DT_SOUL_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSoulID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSoulIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySoulStar))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySoulType))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySoulLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSoulExperience))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsNormalSoul))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDevourExp))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBaseNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBaseNum)
			break;
		if(-1 == EncodeDT_SOUL_ATTR_DATA(&pstIn->astSoulAttr[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byBaseAfterNum))
		return -1;

	for(i = 0; i < MAX_SOUL_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBaseNum)
			break;
		if(-1 == EncodeDT_SOUL_ATTR_DATA(&pstIn->astSoulAfterAttr[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHaveEffect))
		return -1;

	if(-1 == EncodeDT_SPECIAL_EFFECT_DATA(&pstIn->stSpecialEffect, poNetData))
		return -1;

	for(i = 0; i < MAX_SOUL_ATTR_NUM; i++)
	{
		if(-1 == poNetData->AddByte(pstIn->abySoulAttrLock[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SOUL_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_DATA *pstOut = (DT_SOUL_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSoulID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSoulIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySoulStar))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySoulType))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySoulLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSoulExperience))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsNormalSoul))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDevourExp))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBaseNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBaseNum)
			break;
		if(-1 == DecodeDT_SOUL_ATTR_DATA(&pstOut->astSoulAttr[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byBaseAfterNum))
		return -1;

	for(i = 0; i < MAX_SOUL_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBaseNum)
			break;
		if(-1 == DecodeDT_SOUL_ATTR_DATA(&pstOut->astSoulAfterAttr[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHaveEffect))
		return -1;

	if(-1 == DecodeDT_SPECIAL_EFFECT_DATA(&pstOut->stSpecialEffect, poNetData))
		return -1;

	for(i = 0; i < MAX_SOUL_ATTR_NUM; i++)
	{
		if(-1 == poNetData->DelByte(pstOut->abySoulAttrLock[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SOUL_DATA(DT_SOUL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SoulID", (double)(data.wSoulID));
	cJSON_AddNumberToObject(root,"SoulIdx", (double)(data.dwSoulIdx));
	cJSON_AddNumberToObject(root,"SoulStar", (double)(data.bySoulStar));
	cJSON_AddNumberToObject(root,"SoulType", (double)(data.bySoulType));
	cJSON_AddNumberToObject(root,"SoulLevel", (double)(data.bySoulLevel));
	cJSON_AddNumberToObject(root,"SoulExperience", (double)(data.dwSoulExperience));
	cJSON_AddNumberToObject(root,"IsNormalSoul", (double)(data.byIsNormalSoul));
	cJSON_AddNumberToObject(root,"DevourExp", (double)(data.dwDevourExp));
	cJSON_AddNumberToObject(root,"BaseNum", (double)(data.byBaseNum));
	cJSON *SoulAttr = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulAttr", SoulAttr);
	for( UINT32 dwIndex=0; dwIndex<data.byBaseNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SoulAttr, " ", GetJsonDT_SOUL_ATTR_DATA(data.astSoulAttr[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"BaseAfterNum", (double)(data.byBaseAfterNum));
	cJSON *SoulAfterAttr = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulAfterAttr", SoulAfterAttr);
	for( UINT32 dwIndex=0; dwIndex<data.byBaseNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SoulAfterAttr, " ", GetJsonDT_SOUL_ATTR_DATA(data.astSoulAfterAttr[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HaveEffect", (double)(data.byHaveEffect));
	cJSON_AddItemToObject(root, "SpecialEffect", GetJsonDT_SPECIAL_EFFECT_DATA(data.stSpecialEffect));
	cJSON *SoulAttrLock = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulAttrLock", SoulAttrLock);
	for( UINT32 dwIndex=0; dwIndex<MAX_SOUL_ATTR_NUM; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"SoulAttrLock", (double)(data.abySoulAttrLock[dwIndex]));
	}

	return root;
}

INT32 DT_SOUL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 15;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSoulID);
	memcpy(pDataBuff + dwOffset, &wSoulID, sizeof(wSoulID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwSoulIdx);
	memcpy(pDataBuff + dwOffset, &dwSoulIdx, sizeof(dwSoulIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(bySoulStar);
	memcpy(pDataBuff + dwOffset, &bySoulStar, sizeof(bySoulStar));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(bySoulType);
	memcpy(pDataBuff + dwOffset, &bySoulType, sizeof(bySoulType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(bySoulLevel);
	memcpy(pDataBuff + dwOffset, &bySoulLevel, sizeof(bySoulLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwSoulExperience);
	memcpy(pDataBuff + dwOffset, &dwSoulExperience, sizeof(dwSoulExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byIsNormalSoul);
	memcpy(pDataBuff + dwOffset, &byIsNormalSoul, sizeof(byIsNormalSoul));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwDevourExp);
	memcpy(pDataBuff + dwOffset, &dwDevourExp, sizeof(dwDevourExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byBaseNum);
	memcpy(pDataBuff + dwOffset, &byBaseNum, sizeof(byBaseNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	dwContextLenTmp = 0;
	if(byBaseNum > MAX_SOUL_ATTR_NUM)
	{
		byBaseNum = MAX_SOUL_ATTR_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBaseNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBaseNum; i++)
	{
		dwContextLenTmp += astSoulAttr[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byBaseAfterNum);
	memcpy(pDataBuff + dwOffset, &byBaseAfterNum, sizeof(byBaseAfterNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	dwContextLenTmp = 0;
	if(byBaseNum > MAX_SOUL_ATTR_NUM)
	{
		byBaseNum = MAX_SOUL_ATTR_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBaseNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBaseNum; i++)
	{
		dwContextLenTmp += astSoulAfterAttr[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(byHaveEffect);
	memcpy(pDataBuff + dwOffset, &byHaveEffect, sizeof(byHaveEffect));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = stSpecialEffect.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(abySoulAttrLock) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_SOUL_ATTR_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abySoulAttrLock, sizeof(abySoulAttrLock));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SOUL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSoulID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSoulID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSoulID, 0, sizeof(wSoulID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwSoulIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSoulIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSoulIdx, 0, sizeof(dwSoulIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(bySoulStar) >= pstIndex->dwContextLen)
				{
					memcpy(&bySoulStar, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySoulStar, 0, sizeof(bySoulStar));
				}
			}
			break;
		case 4:
			{
				if(sizeof(bySoulType) >= pstIndex->dwContextLen)
				{
					memcpy(&bySoulType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySoulType, 0, sizeof(bySoulType));
				}
			}
			break;
		case 5:
			{
				if(sizeof(bySoulLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&bySoulLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySoulLevel, 0, sizeof(bySoulLevel));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwSoulExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSoulExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSoulExperience, 0, sizeof(dwSoulExperience));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byIsNormalSoul) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsNormalSoul, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsNormalSoul, 0, sizeof(byIsNormalSoul));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwDevourExp) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDevourExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDevourExp, 0, sizeof(dwDevourExp));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byBaseNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBaseNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBaseNum, 0, sizeof(byBaseNum));
				}
			}
			break;
		case 10:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBaseNum)
				{
					wArrNum = wArrNum <= MAX_SOUL_ATTR_NUM ? wArrNum : MAX_SOUL_ATTR_NUM;
					byBaseNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSoulAttr[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSoulAttr, 0, sizeof(astSoulAttr));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSoulAttr, 0, sizeof(astSoulAttr));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byBaseAfterNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBaseAfterNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBaseAfterNum, 0, sizeof(byBaseAfterNum));
				}
			}
			break;
		case 12:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBaseNum)
				{
					wArrNum = wArrNum <= MAX_SOUL_ATTR_NUM ? wArrNum : MAX_SOUL_ATTR_NUM;
					byBaseNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSoulAfterAttr[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSoulAfterAttr, 0, sizeof(astSoulAfterAttr));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSoulAfterAttr, 0, sizeof(astSoulAfterAttr));
				}
			}
			break;
		case 13:
			{
				if(sizeof(byHaveEffect) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveEffect, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveEffect, 0, sizeof(byHaveEffect));
				}
			}
			break;
		case 14:
			{
				stSpecialEffect.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 15:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abySoulAttrLock) >= dwContextLen) && (wArrNum <= MAX_SOUL_ATTR_NUM))
				{
					memcpy(&abySoulAttrLock, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abySoulAttrLock, 0, sizeof(abySoulAttrLock));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_SOUL_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_SOUL_DATA *pstIn = (DT_HERO_SOUL_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSoulNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_EQUIP_NUM; i++)
	{
		if(i >= (INT32)pstIn->wSoulNum)
			break;
		if(-1 == EncodeDT_SOUL_DATA(&pstIn->astSoulLstData[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_SOUL_EQUIP_NUM; i++)
	{
		if(i >= (INT32)pstIn->wSoulNum)
			break;
		if(-1 == EncodeDT_SOUL_POTENCY_DATA(&pstIn->astSoulPotencyLstData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_SOUL_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_SOUL_DATA *pstOut = (DT_HERO_SOUL_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSoulNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_EQUIP_NUM; i++)
	{
		if(i >= (INT32)pstOut->wSoulNum)
			break;
		if(-1 == DecodeDT_SOUL_DATA(&pstOut->astSoulLstData[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_SOUL_EQUIP_NUM; i++)
	{
		if(i >= (INT32)pstOut->wSoulNum)
			break;
		if(-1 == DecodeDT_SOUL_POTENCY_DATA(&pstOut->astSoulPotencyLstData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_SOUL_DATA(DT_HERO_SOUL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SoulNum", (double)(data.wSoulNum));
	cJSON *SoulLstData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulLstData", SoulLstData);
	for( UINT32 dwIndex=0; dwIndex<data.wSoulNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SoulLstData, " ", GetJsonDT_SOUL_DATA(data.astSoulLstData[dwIndex]));
	}
	cJSON *SoulPotencyLstData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulPotencyLstData", SoulPotencyLstData);
	for( UINT32 dwIndex=0; dwIndex<data.wSoulNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SoulPotencyLstData, " ", GetJsonDT_SOUL_POTENCY_DATA(data.astSoulPotencyLstData[dwIndex]));
	}

	return root;
}

INT32 DT_HERO_SOUL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSoulNum);
	memcpy(pDataBuff + dwOffset, &wSoulNum, sizeof(wSoulNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wSoulNum > MAX_SOUL_EQUIP_NUM)
	{
		wSoulNum = MAX_SOUL_EQUIP_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wSoulNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wSoulNum; i++)
	{
		dwContextLenTmp += astSoulLstData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(wSoulNum > MAX_SOUL_EQUIP_NUM)
	{
		wSoulNum = MAX_SOUL_EQUIP_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wSoulNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wSoulNum; i++)
	{
		dwContextLenTmp += astSoulPotencyLstData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_SOUL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSoulNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wSoulNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSoulNum, 0, sizeof(wSoulNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wSoulNum)
				{
					wArrNum = wArrNum <= MAX_SOUL_EQUIP_NUM ? wArrNum : MAX_SOUL_EQUIP_NUM;
					wSoulNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSoulLstData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSoulLstData, 0, sizeof(astSoulLstData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSoulLstData, 0, sizeof(astSoulLstData));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wSoulNum)
				{
					wArrNum = wArrNum <= MAX_SOUL_EQUIP_NUM ? wArrNum : MAX_SOUL_EQUIP_NUM;
					wSoulNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSoulPotencyLstData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSoulPotencyLstData, 0, sizeof(astSoulPotencyLstData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSoulPotencyLstData, 0, sizeof(astSoulPotencyLstData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_BASE_DATA *pstIn = (DT_HERO_BASE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCoach))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPos))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wTalent))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwExperience))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byRecuitedFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byVisitNum))
		return -1;

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stBattleAttribute, poNetData))
		return -1;

	if(-1 == EncodeDT_HIDE_BATTLE_ATTRIBUTE(&pstIn->stHideBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastUseDrugLevel))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastUseDrugTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUseExperienceDrugPerDay))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastUseExperienceDrugTime))
		return -1;

	if(-1 == EncodeDT_HERO_UPDATE_ATTR_DATA(&pstIn->stUpdateAttrInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsFly))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFlyExp))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_BASE_DATA *pstOut = (DT_HERO_BASE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCoach))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPos))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wTalent))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwExperience))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byRecuitedFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byVisitNum))
		return -1;

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stBattleAttribute, poNetData))
		return -1;

	if(-1 == DecodeDT_HIDE_BATTLE_ATTRIBUTE(&pstOut->stHideBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastUseDrugLevel))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastUseDrugTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUseExperienceDrugPerDay))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastUseExperienceDrugTime))
		return -1;

	if(-1 == DecodeDT_HERO_UPDATE_ATTR_DATA(&pstOut->stUpdateAttrInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsFly))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFlyExp))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_BASE_DATA(DT_HERO_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"Coach", (double)(data.byCoach));
	cJSON_AddNumberToObject(root,"Pos", (double)(data.byPos));
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"Talent", (double)(data.wTalent));
	cJSON_AddNumberToObject(root,"Experience", (double)(data.qwExperience));
	cJSON_AddNumberToObject(root,"RecuitedFlag", (double)(data.byRecuitedFlag));
	cJSON_AddNumberToObject(root,"VisitNum", (double)(data.byVisitNum));
	cJSON_AddItemToObject(root, "BattleAttribute", GetJsonDT_BATTLE_ATTRIBUTE(data.stBattleAttribute));
	cJSON_AddItemToObject(root, "HideBattleAttr", GetJsonDT_HIDE_BATTLE_ATTRIBUTE(data.stHideBattleAttr));
	cJSON_AddNumberToObject(root,"LastUseDrugLevel", (double)(data.byLastUseDrugLevel));
	cJSON_AddNumberToObject(root,"LastUseDrugTime", (double)(data.qwLastUseDrugTime));
	cJSON_AddNumberToObject(root,"UseExperienceDrugPerDay", (double)(data.byUseExperienceDrugPerDay));
	cJSON_AddNumberToObject(root,"LastUseExperienceDrugTime", (double)(data.qwLastUseExperienceDrugTime));
	cJSON_AddItemToObject(root, "UpdateAttrInfo", GetJsonDT_HERO_UPDATE_ATTR_DATA(data.stUpdateAttrInfo));
	cJSON_AddNumberToObject(root,"IsFly", (double)(data.byIsFly));
	cJSON_AddNumberToObject(root,"FlyExp", (double)(data.dwFlyExp));

	return root;
}

INT32 DT_HERO_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 18;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCoach);
	memcpy(pDataBuff + dwOffset, &byCoach, sizeof(byCoach));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byPos);
	memcpy(pDataBuff + dwOffset, &byPos, sizeof(byPos));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wTalent);
	memcpy(pDataBuff + dwOffset, &wTalent, sizeof(wTalent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwExperience);
	memcpy(pDataBuff + dwOffset, &qwExperience, sizeof(qwExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byRecuitedFlag);
	memcpy(pDataBuff + dwOffset, &byRecuitedFlag, sizeof(byRecuitedFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byVisitNum);
	memcpy(pDataBuff + dwOffset, &byVisitNum, sizeof(byVisitNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = stBattleAttribute.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = stHideBattleAttr.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(byLastUseDrugLevel);
	memcpy(pDataBuff + dwOffset, &byLastUseDrugLevel, sizeof(byLastUseDrugLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(qwLastUseDrugTime);
	memcpy(pDataBuff + dwOffset, &qwLastUseDrugTime, sizeof(qwLastUseDrugTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(byUseExperienceDrugPerDay);
	memcpy(pDataBuff + dwOffset, &byUseExperienceDrugPerDay, sizeof(byUseExperienceDrugPerDay));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(qwLastUseExperienceDrugTime);
	memcpy(pDataBuff + dwOffset, &qwLastUseExperienceDrugTime, sizeof(qwLastUseExperienceDrugTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = stUpdateAttrInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(byIsFly);
	memcpy(pDataBuff + dwOffset, &byIsFly, sizeof(byIsFly));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(dwFlyExp);
	memcpy(pDataBuff + dwOffset, &dwFlyExp, sizeof(dwFlyExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCoach) >= pstIndex->dwContextLen)
				{
					memcpy(&byCoach, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCoach, 0, sizeof(byCoach));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byPos) >= pstIndex->dwContextLen)
				{
					memcpy(&byPos, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPos, 0, sizeof(byPos));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wTalent) >= pstIndex->dwContextLen)
				{
					memcpy(&wTalent, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wTalent, 0, sizeof(wTalent));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwExperience, 0, sizeof(qwExperience));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byRecuitedFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byRecuitedFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRecuitedFlag, 0, sizeof(byRecuitedFlag));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byVisitNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byVisitNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byVisitNum, 0, sizeof(byVisitNum));
				}
			}
			break;
		case 10:
			{
				stBattleAttribute.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 11:
			{
				stHideBattleAttr.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 12:
			{
				if(sizeof(byLastUseDrugLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastUseDrugLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastUseDrugLevel, 0, sizeof(byLastUseDrugLevel));
				}
			}
			break;
		case 13:
			{
				if(sizeof(qwLastUseDrugTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastUseDrugTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastUseDrugTime, 0, sizeof(qwLastUseDrugTime));
				}
			}
			break;
		case 14:
			{
				if(sizeof(byUseExperienceDrugPerDay) >= pstIndex->dwContextLen)
				{
					memcpy(&byUseExperienceDrugPerDay, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUseExperienceDrugPerDay, 0, sizeof(byUseExperienceDrugPerDay));
				}
			}
			break;
		case 15:
			{
				if(sizeof(qwLastUseExperienceDrugTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastUseExperienceDrugTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastUseExperienceDrugTime, 0, sizeof(qwLastUseExperienceDrugTime));
				}
			}
			break;
		case 16:
			{
				stUpdateAttrInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 17:
			{
				if(sizeof(byIsFly) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsFly, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsFly, 0, sizeof(byIsFly));
				}
			}
			break;
		case 18:
			{
				if(sizeof(dwFlyExp) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFlyExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFlyExp, 0, sizeof(dwFlyExp));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_XIANGQIAN_DATA(void *pHost, CNetData* poNetData)
{
	DT_XIANGQIAN_DATA *pstIn = (DT_XIANGQIAN_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wItemID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_XIANGQIAN_DATA(void *pHost, CNetData* poNetData)
{
	DT_XIANGQIAN_DATA *pstOut = (DT_XIANGQIAN_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wItemID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_XIANGQIAN_DATA(DT_XIANGQIAN_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ItemID", (double)(data.wItemID));

	return root;
}

INT32 DT_XIANGQIAN_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wItemID);
	memcpy(pDataBuff + dwOffset, &wItemID, sizeof(wItemID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_XIANGQIAN_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wItemID) >= pstIndex->dwContextLen)
				{
					memcpy(&wItemID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wItemID, 0, sizeof(wItemID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EQUIP_DATA(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_DATA *pstIn = (DT_EQUIP_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBagPos))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwItemNewTime))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_XIANGQIAN_NUM; i++)
	{
		if(-1 == EncodeDT_XIANGQIAN_DATA(&pstIn->astXiangqianList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EQUIP_DATA(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_DATA *pstOut = (DT_EQUIP_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBagPos))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwItemNewTime))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_XIANGQIAN_NUM; i++)
		{
			if(-1 == DecodeDT_XIANGQIAN_DATA(&pstOut->astXiangqianList[i], poNetData))
				return -1;
		}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EQUIP_DATA(DT_EQUIP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"Idx", (double)(data.wIdx));
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"BagPos", (double)(data.wBagPos));
	cJSON_AddNumberToObject(root,"ItemNewTime", (double)(data.qwItemNewTime));
	cJSON *XiangqianList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "XiangqianList", XiangqianList);
	for( UINT32 dwIndex=0; dwIndex<MAX_XIANGQIAN_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(XiangqianList, " ", GetJsonDT_XIANGQIAN_DATA(data.astXiangqianList[dwIndex]));
	}

	return root;
}

INT32 DT_EQUIP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wIdx);
	memcpy(pDataBuff + dwOffset, &wIdx, sizeof(wIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wBagPos);
	memcpy(pDataBuff + dwOffset, &wBagPos, sizeof(wBagPos));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(qwItemNewTime);
	memcpy(pDataBuff + dwOffset, &qwItemNewTime, sizeof(qwItemNewTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_XIANGQIAN_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_XIANGQIAN_NUM; i++)
	{
		dwContextLenTmp += astXiangqianList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EQUIP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wIdx, 0, sizeof(wIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wBagPos) >= pstIndex->dwContextLen)
				{
					memcpy(&wBagPos, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBagPos, 0, sizeof(wBagPos));
				}
			}
			break;
		case 6:
			{
				if(sizeof(qwItemNewTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwItemNewTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwItemNewTime, 0, sizeof(qwItemNewTime));
				}
			}
			break;
		case 7:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_XIANGQIAN_NUM ? wArrNum : MAX_XIANGQIAN_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astXiangqianList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astXiangqianList, 0, sizeof(astXiangqianList));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_EQUIP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_HERO_EQUIP_DATA_LST *pstIn = (DT_HERO_EQUIP_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEquipNum))
		return -1;

	INT32 i;
	for(i = 0; i < EQUIP_POS_NUM; i++)
	{
		if(i >= (INT32)pstIn->wEquipNum)
			break;
		if(-1 == EncodeDT_EQUIP_DATA(&pstIn->astEquipList[i], poNetData))
			return -1;
	}

	for(i = 0; i < EQUIP_POS_NUM; i++)
	{
		if(i >= (INT32)pstIn->wEquipNum)
			break;
		if(-1 == poNetData->AddWord(pstIn->awEnchantLevel[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_EQUIP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_HERO_EQUIP_DATA_LST *pstOut = (DT_HERO_EQUIP_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEquipNum))
		return -1;

	INT32 i;
	for(i = 0; i < EQUIP_POS_NUM; i++)
	{
		if(i >= (INT32)pstOut->wEquipNum)
			break;
		if(-1 == DecodeDT_EQUIP_DATA(&pstOut->astEquipList[i], poNetData))
			return -1;
	}

	for(i = 0; i < EQUIP_POS_NUM; i++)
	{
		if(i >= (INT32)pstOut->wEquipNum)
			break;
		if(-1 == poNetData->DelWord(pstOut->awEnchantLevel[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_EQUIP_DATA_LST(DT_HERO_EQUIP_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipNum", (double)(data.wEquipNum));
	cJSON *EquipList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EquipList", EquipList);
	for( UINT32 dwIndex=0; dwIndex<data.wEquipNum; ++dwIndex)
	{
		cJSON_AddItemToObject(EquipList, " ", GetJsonDT_EQUIP_DATA(data.astEquipList[dwIndex]));
	}
	cJSON *EnchantLevel = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EnchantLevel", EnchantLevel);
	for( UINT32 dwIndex=0; dwIndex<data.wEquipNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"EnchantLevel", (double)(data.awEnchantLevel[dwIndex]));
	}

	return root;
}

INT32 DT_HERO_EQUIP_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEquipNum);
	memcpy(pDataBuff + dwOffset, &wEquipNum, sizeof(wEquipNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wEquipNum > EQUIP_POS_NUM)
	{
		wEquipNum = EQUIP_POS_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wEquipNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wEquipNum; i++)
	{
		dwContextLenTmp += astEquipList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	if(wEquipNum > EQUIP_POS_NUM)
	{
		wEquipNum = EQUIP_POS_NUM;
	}
	pstIndex->dwContextLen = wEquipNum * sizeof(UINT16) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = wEquipNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awEnchantLevel, wEquipNum * sizeof(UINT16));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_EQUIP_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEquipNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wEquipNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEquipNum, 0, sizeof(wEquipNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wEquipNum)
				{
					wArrNum = wArrNum <= EQUIP_POS_NUM ? wArrNum : EQUIP_POS_NUM;
					wEquipNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astEquipList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astEquipList, 0, sizeof(astEquipList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astEquipList, 0, sizeof(astEquipList));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awEnchantLevel) >= dwContextLen) && (wArrNum == wEquipNum) && (wArrNum <= EQUIP_POS_NUM))
				{
					memcpy(&awEnchantLevel, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awEnchantLevel, 0, sizeof(awEnchantLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BAG_EQUIP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BAG_EQUIP_DATA_LST *pstIn = (DT_BAG_EQUIP_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEquipNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstIn->wEquipNum)
			break;
		if(-1 == EncodeDT_EQUIP_DATA(&pstIn->astEquipList[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstIn->wEquipNum)
			break;
		if(-1 == poNetData->AddWord(pstIn->awEnchantLevel[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BAG_EQUIP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BAG_EQUIP_DATA_LST *pstOut = (DT_BAG_EQUIP_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEquipNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstOut->wEquipNum)
			break;
		if(-1 == DecodeDT_EQUIP_DATA(&pstOut->astEquipList[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstOut->wEquipNum)
			break;
		if(-1 == poNetData->DelWord(pstOut->awEnchantLevel[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BAG_EQUIP_DATA_LST(DT_BAG_EQUIP_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipNum", (double)(data.wEquipNum));
	cJSON *EquipList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EquipList", EquipList);
	for( UINT32 dwIndex=0; dwIndex<data.wEquipNum; ++dwIndex)
	{
		cJSON_AddItemToObject(EquipList, " ", GetJsonDT_EQUIP_DATA(data.astEquipList[dwIndex]));
	}
	cJSON *EnchantLevel = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EnchantLevel", EnchantLevel);
	for( UINT32 dwIndex=0; dwIndex<data.wEquipNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"EnchantLevel", (double)(data.awEnchantLevel[dwIndex]));
	}

	return root;
}

INT32 DT_BAG_EQUIP_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEquipNum);
	memcpy(pDataBuff + dwOffset, &wEquipNum, sizeof(wEquipNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wEquipNum > MAX_BAG_OPEN_NUM_NEW)
	{
		wEquipNum = MAX_BAG_OPEN_NUM_NEW;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wEquipNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wEquipNum; i++)
	{
		dwContextLenTmp += astEquipList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	if(wEquipNum > MAX_BAG_OPEN_NUM_NEW)
	{
		wEquipNum = MAX_BAG_OPEN_NUM_NEW;
	}
	pstIndex->dwContextLen = wEquipNum * sizeof(UINT16) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = wEquipNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awEnchantLevel, wEquipNum * sizeof(UINT16));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BAG_EQUIP_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEquipNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wEquipNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEquipNum, 0, sizeof(wEquipNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wEquipNum)
				{
					wArrNum = wArrNum <= MAX_BAG_OPEN_NUM_NEW ? wArrNum : MAX_BAG_OPEN_NUM_NEW;
					wEquipNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astEquipList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astEquipList, 0, sizeof(astEquipList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astEquipList, 0, sizeof(astEquipList));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awEnchantLevel) >= dwContextLen) && (wArrNum == wEquipNum) && (wArrNum <= MAX_BAG_OPEN_NUM_NEW))
				{
					memcpy(&awEnchantLevel, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awEnchantLevel, 0, sizeof(awEnchantLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GOODS_DATA(void *pHost, CNetData* poNetData)
{
	DT_GOODS_DATA *pstIn = (DT_GOODS_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPileCount))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastUseTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastUseNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBagPos))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwItemNewTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GOODS_DATA(void *pHost, CNetData* poNetData)
{
	DT_GOODS_DATA *pstOut = (DT_GOODS_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPileCount))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastUseTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastUseNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBagPos))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwItemNewTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GOODS_DATA(DT_GOODS_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"PileCount", (double)(data.wPileCount));
	cJSON_AddNumberToObject(root,"LastUseTime", (double)(data.qwLastUseTime));
	cJSON_AddNumberToObject(root,"LastUseNum", (double)(data.wLastUseNum));
	cJSON_AddNumberToObject(root,"BagPos", (double)(data.wBagPos));
	cJSON_AddNumberToObject(root,"ItemNewTime", (double)(data.qwItemNewTime));

	return root;
}

INT32 DT_GOODS_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wPileCount);
	memcpy(pDataBuff + dwOffset, &wPileCount, sizeof(wPileCount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastUseTime);
	memcpy(pDataBuff + dwOffset, &qwLastUseTime, sizeof(qwLastUseTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wLastUseNum);
	memcpy(pDataBuff + dwOffset, &wLastUseNum, sizeof(wLastUseNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wBagPos);
	memcpy(pDataBuff + dwOffset, &wBagPos, sizeof(wBagPos));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(qwItemNewTime);
	memcpy(pDataBuff + dwOffset, &qwItemNewTime, sizeof(qwItemNewTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GOODS_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wPileCount) >= pstIndex->dwContextLen)
				{
					memcpy(&wPileCount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPileCount, 0, sizeof(wPileCount));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastUseTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastUseTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastUseTime, 0, sizeof(qwLastUseTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wLastUseNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastUseNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastUseNum, 0, sizeof(wLastUseNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wBagPos) >= pstIndex->dwContextLen)
				{
					memcpy(&wBagPos, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBagPos, 0, sizeof(wBagPos));
				}
			}
			break;
		case 6:
			{
				if(sizeof(qwItemNewTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwItemNewTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwItemNewTime, 0, sizeof(qwItemNewTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BAG_GOODS_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BAG_GOODS_DATA_LST *pstIn = (DT_BAG_GOODS_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wGoodsNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstIn->wGoodsNum)
			break;
		if(-1 == EncodeDT_GOODS_DATA(&pstIn->astGoodsList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BAG_GOODS_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BAG_GOODS_DATA_LST *pstOut = (DT_BAG_GOODS_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wGoodsNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstOut->wGoodsNum)
			break;
		if(-1 == DecodeDT_GOODS_DATA(&pstOut->astGoodsList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BAG_GOODS_DATA_LST(DT_BAG_GOODS_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GoodsNum", (double)(data.wGoodsNum));
	cJSON *GoodsList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GoodsList", GoodsList);
	for( UINT32 dwIndex=0; dwIndex<data.wGoodsNum; ++dwIndex)
	{
		cJSON_AddItemToObject(GoodsList, " ", GetJsonDT_GOODS_DATA(data.astGoodsList[dwIndex]));
	}

	return root;
}

INT32 DT_BAG_GOODS_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wGoodsNum);
	memcpy(pDataBuff + dwOffset, &wGoodsNum, sizeof(wGoodsNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wGoodsNum > MAX_BAG_OPEN_NUM_NEW)
	{
		wGoodsNum = MAX_BAG_OPEN_NUM_NEW;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wGoodsNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wGoodsNum; i++)
	{
		dwContextLenTmp += astGoodsList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BAG_GOODS_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wGoodsNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wGoodsNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wGoodsNum, 0, sizeof(wGoodsNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wGoodsNum)
				{
					wArrNum = wArrNum <= MAX_BAG_OPEN_NUM_NEW ? wArrNum : MAX_BAG_OPEN_NUM_NEW;
					wGoodsNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astGoodsList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astGoodsList, 0, sizeof(astGoodsList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astGoodsList, 0, sizeof(astGoodsList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DRUG_DATA(void *pHost, CNetData* poNetData)
{
	DT_DRUG_DATA *pstIn = (DT_DRUG_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DRUG_DATA(void *pHost, CNetData* poNetData)
{
	DT_DRUG_DATA *pstOut = (DT_DRUG_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DRUG_DATA(DT_DRUG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Level", (double)(data.byLevel));
	cJSON_AddNumberToObject(root,"Num", (double)(data.byNum));
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));

	return root;
}

INT32 DT_DRUG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLevel);
	memcpy(pDataBuff + dwOffset, &byLevel, sizeof(byLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byNum);
	memcpy(pDataBuff + dwOffset, &byNum, sizeof(byNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DRUG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLevel, 0, sizeof(byLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNum, 0, sizeof(byNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DRUG_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_DRUG_DATA_LST *pstIn = (DT_DRUG_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byDrugLevelNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_DRUG_LEVEL; i++)
	{
		if(i >= (INT32)pstIn->byDrugLevelNum)
			break;
		if(-1 == EncodeDT_DRUG_DATA(&pstIn->astDrugList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DRUG_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_DRUG_DATA_LST *pstOut = (DT_DRUG_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byDrugLevelNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_DRUG_LEVEL; i++)
	{
		if(i >= (INT32)pstOut->byDrugLevelNum)
			break;
		if(-1 == DecodeDT_DRUG_DATA(&pstOut->astDrugList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DRUG_DATA_LST(DT_DRUG_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"DrugLevelNum", (double)(data.byDrugLevelNum));
	cJSON *DrugList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "DrugList", DrugList);
	for( UINT32 dwIndex=0; dwIndex<data.byDrugLevelNum; ++dwIndex)
	{
		cJSON_AddItemToObject(DrugList, " ", GetJsonDT_DRUG_DATA(data.astDrugList[dwIndex]));
	}

	return root;
}

INT32 DT_DRUG_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byDrugLevelNum);
	memcpy(pDataBuff + dwOffset, &byDrugLevelNum, sizeof(byDrugLevelNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byDrugLevelNum > MAX_DRUG_LEVEL)
	{
		byDrugLevelNum = MAX_DRUG_LEVEL;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byDrugLevelNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byDrugLevelNum; i++)
	{
		dwContextLenTmp += astDrugList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DRUG_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byDrugLevelNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byDrugLevelNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDrugLevelNum, 0, sizeof(byDrugLevelNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byDrugLevelNum)
				{
					wArrNum = wArrNum <= MAX_DRUG_LEVEL ? wArrNum : MAX_DRUG_LEVEL;
					byDrugLevelNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astDrugList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astDrugList, 0, sizeof(astDrugList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astDrugList, 0, sizeof(astDrugList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GODWEAPON_DATA(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_DATA *pstIn = (DT_GODWEAPON_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wQuality))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GODWEAPON_DATA(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_DATA *pstOut = (DT_GODWEAPON_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wQuality))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GODWEAPON_DATA(DT_GODWEAPON_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"Quality", (double)(data.wQuality));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));

	return root;
}

INT32 DT_GODWEAPON_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wQuality);
	memcpy(pDataBuff + dwOffset, &wQuality, sizeof(wQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GODWEAPON_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&wQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wQuality, 0, sizeof(wQuality));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_RANG_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_RANG_DATA *pstIn = (DT_ATTACK_RANG_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackRangKind))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTraceBuffKind))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_RANG_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_RANG_DATA *pstOut = (DT_ATTACK_RANG_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackRangKind))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTraceBuffKind))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_RANG_DATA(DT_ATTACK_RANG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackRangKind", (double)(data.byAttackRangKind));
	cJSON_AddNumberToObject(root,"TraceBuffKind", (double)(data.byTraceBuffKind));

	return root;
}

INT32 DT_ATTACK_RANG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackRangKind);
	memcpy(pDataBuff + dwOffset, &byAttackRangKind, sizeof(byAttackRangKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTraceBuffKind);
	memcpy(pDataBuff + dwOffset, &byTraceBuffKind, sizeof(byTraceBuffKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_RANG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackRangKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackRangKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackRangKind, 0, sizeof(byAttackRangKind));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTraceBuffKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byTraceBuffKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTraceBuffKind, 0, sizeof(byTraceBuffKind));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SKILL_DATA(void *pHost, CNetData* poNetData)
{
	DT_SKILL_DATA *pstIn = (DT_SKILL_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wActionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wActionLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wEffectID))
		return -1;

	if(-1 == EncodeDT_ATTACK_RANG_DATA(&pstIn->stAttackRangInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwActionExp))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SKILL_DATA(void *pHost, CNetData* poNetData)
{
	DT_SKILL_DATA *pstOut = (DT_SKILL_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wActionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wActionLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wEffectID))
		return -1;

	if(-1 == DecodeDT_ATTACK_RANG_DATA(&pstOut->stAttackRangInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwActionExp))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SKILL_DATA(DT_SKILL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ActionID", (double)(data.wActionID));
	cJSON_AddNumberToObject(root,"ActionLevel", (double)(data.wActionLevel));
	cJSON_AddNumberToObject(root,"EffectID", (double)(data.wEffectID));
	cJSON_AddItemToObject(root, "AttackRangInfo", GetJsonDT_ATTACK_RANG_DATA(data.stAttackRangInfo));
	cJSON_AddNumberToObject(root,"ActionExp", (double)(data.dwActionExp));

	return root;
}

INT32 DT_SKILL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wActionID);
	memcpy(pDataBuff + dwOffset, &wActionID, sizeof(wActionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wActionLevel);
	memcpy(pDataBuff + dwOffset, &wActionLevel, sizeof(wActionLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wEffectID);
	memcpy(pDataBuff + dwOffset, &wEffectID, sizeof(wEffectID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stAttackRangInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwActionExp);
	memcpy(pDataBuff + dwOffset, &dwActionExp, sizeof(dwActionExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SKILL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 3:
			{
				if(sizeof(wActionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wActionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wActionID, 0, sizeof(wActionID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wActionLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wActionLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wActionLevel, 0, sizeof(wActionLevel));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wEffectID) >= pstIndex->dwContextLen)
				{
					memcpy(&wEffectID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEffectID, 0, sizeof(wEffectID));
				}
			}
			break;
		case 6:
			{
				stAttackRangInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				if(sizeof(dwActionExp) >= pstIndex->dwContextLen)
				{
					memcpy(&dwActionExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwActionExp, 0, sizeof(dwActionExp));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SKILL_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_SKILL_DATA_LST *pstIn = (DT_SKILL_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->bySkillNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SKILL_SLOT_NUM; i++)
	{
		if(i >= (INT32)pstIn->bySkillNum)
			break;
		if(-1 == EncodeDT_SKILL_DATA(&pstIn->astSkillInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SKILL_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_SKILL_DATA_LST *pstOut = (DT_SKILL_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->bySkillNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SKILL_SLOT_NUM; i++)
	{
		if(i >= (INT32)pstOut->bySkillNum)
			break;
		if(-1 == DecodeDT_SKILL_DATA(&pstOut->astSkillInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SKILL_DATA_LST(DT_SKILL_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SkillNum", (double)(data.bySkillNum));
	cJSON *SkillInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SkillInfo", SkillInfo);
	for( UINT32 dwIndex=0; dwIndex<data.bySkillNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SkillInfo, " ", GetJsonDT_SKILL_DATA(data.astSkillInfo[dwIndex]));
	}

	return root;
}

INT32 DT_SKILL_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(bySkillNum);
	memcpy(pDataBuff + dwOffset, &bySkillNum, sizeof(bySkillNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(bySkillNum > MAX_SKILL_SLOT_NUM)
	{
		bySkillNum = MAX_SKILL_SLOT_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = bySkillNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < bySkillNum; i++)
	{
		dwContextLenTmp += astSkillInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SKILL_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(bySkillNum) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkillNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkillNum, 0, sizeof(bySkillNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == bySkillNum)
				{
					wArrNum = wArrNum <= MAX_SKILL_SLOT_NUM ? wArrNum : MAX_SKILL_SLOT_NUM;
					bySkillNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSkillInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSkillInfo, 0, sizeof(astSkillInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSkillInfo, 0, sizeof(astSkillInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_STUDY_DATA(void *pHost, CNetData* poNetData)
{
	DT_STUDY_DATA *pstIn = (DT_STUDY_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byStudyColorKind))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byStudyAttrKind1))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byStudyLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byStudyAttrKind2))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_STUDY_DATA(void *pHost, CNetData* poNetData)
{
	DT_STUDY_DATA *pstOut = (DT_STUDY_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byStudyColorKind))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byStudyAttrKind1))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byStudyLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byStudyAttrKind2))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_STUDY_DATA(DT_STUDY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"StudyColorKind", (double)(data.byStudyColorKind));
	cJSON_AddNumberToObject(root,"StudyAttrKind1", (double)(data.byStudyAttrKind1));
	cJSON_AddNumberToObject(root,"StudyLevel", (double)(data.byStudyLevel));
	cJSON_AddNumberToObject(root,"StudyAttrKind2", (double)(data.byStudyAttrKind2));

	return root;
}

INT32 DT_STUDY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byStudyColorKind);
	memcpy(pDataBuff + dwOffset, &byStudyColorKind, sizeof(byStudyColorKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byStudyAttrKind1);
	memcpy(pDataBuff + dwOffset, &byStudyAttrKind1, sizeof(byStudyAttrKind1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byStudyLevel);
	memcpy(pDataBuff + dwOffset, &byStudyLevel, sizeof(byStudyLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byStudyAttrKind2);
	memcpy(pDataBuff + dwOffset, &byStudyAttrKind2, sizeof(byStudyAttrKind2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_STUDY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byStudyColorKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byStudyColorKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStudyColorKind, 0, sizeof(byStudyColorKind));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byStudyAttrKind1) >= pstIndex->dwContextLen)
				{
					memcpy(&byStudyAttrKind1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStudyAttrKind1, 0, sizeof(byStudyAttrKind1));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byStudyLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byStudyLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStudyLevel, 0, sizeof(byStudyLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byStudyAttrKind2) >= pstIndex->dwContextLen)
				{
					memcpy(&byStudyAttrKind2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStudyAttrKind2, 0, sizeof(byStudyAttrKind2));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_AWAKEN_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_BASE_DATA *pstIn = (DT_AWAKEN_BASE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGoldFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStudyExp))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHaveCallNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwlastCallTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStudyClip))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_AWAKEN_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_BASE_DATA *pstOut = (DT_AWAKEN_BASE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGoldFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStudyExp))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHaveCallNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwlastCallTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStudyClip))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_AWAKEN_BASE_DATA(DT_AWAKEN_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Level", (double)(data.byLevel));
	cJSON_AddNumberToObject(root,"GoldFlag", (double)(data.byGoldFlag));
	cJSON_AddNumberToObject(root,"StudyExp", (double)(data.qwStudyExp));
	cJSON_AddNumberToObject(root,"HaveCallNum", (double)(data.wHaveCallNum));
	cJSON_AddNumberToObject(root,"lastCallTime", (double)(data.qwlastCallTime));
	cJSON_AddNumberToObject(root,"StudyClip", (double)(data.qwStudyClip));

	return root;
}

INT32 DT_AWAKEN_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLevel);
	memcpy(pDataBuff + dwOffset, &byLevel, sizeof(byLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byGoldFlag);
	memcpy(pDataBuff + dwOffset, &byGoldFlag, sizeof(byGoldFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwStudyExp);
	memcpy(pDataBuff + dwOffset, &qwStudyExp, sizeof(qwStudyExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wHaveCallNum);
	memcpy(pDataBuff + dwOffset, &wHaveCallNum, sizeof(wHaveCallNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwlastCallTime);
	memcpy(pDataBuff + dwOffset, &qwlastCallTime, sizeof(qwlastCallTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(qwStudyClip);
	memcpy(pDataBuff + dwOffset, &qwStudyClip, sizeof(qwStudyClip));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_AWAKEN_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLevel, 0, sizeof(byLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byGoldFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byGoldFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGoldFlag, 0, sizeof(byGoldFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwStudyExp) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStudyExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStudyExp, 0, sizeof(qwStudyExp));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wHaveCallNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wHaveCallNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHaveCallNum, 0, sizeof(wHaveCallNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwlastCallTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwlastCallTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwlastCallTime, 0, sizeof(qwlastCallTime));
				}
			}
			break;
		case 6:
			{
				if(sizeof(qwStudyClip) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStudyClip, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStudyClip, 0, sizeof(qwStudyClip));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_AWAKEN_BASE_DATA1(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_BASE_DATA1 *pstIn = (DT_AWAKEN_BASE_DATA1*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGoldFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStudyExp))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHaveCallNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwlastCallTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_AWAKEN_BASE_DATA1(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_BASE_DATA1 *pstOut = (DT_AWAKEN_BASE_DATA1*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGoldFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStudyExp))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHaveCallNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwlastCallTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_AWAKEN_BASE_DATA1(DT_AWAKEN_BASE_DATA1 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Level", (double)(data.byLevel));
	cJSON_AddNumberToObject(root,"GoldFlag", (double)(data.byGoldFlag));
	cJSON_AddNumberToObject(root,"StudyExp", (double)(data.qwStudyExp));
	cJSON_AddNumberToObject(root,"HaveCallNum", (double)(data.wHaveCallNum));
	cJSON_AddNumberToObject(root,"lastCallTime", (double)(data.qwlastCallTime));

	return root;
}

INT32 DT_AWAKEN_BASE_DATA1::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLevel);
	memcpy(pDataBuff + dwOffset, &byLevel, sizeof(byLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byGoldFlag);
	memcpy(pDataBuff + dwOffset, &byGoldFlag, sizeof(byGoldFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwStudyExp);
	memcpy(pDataBuff + dwOffset, &qwStudyExp, sizeof(qwStudyExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wHaveCallNum);
	memcpy(pDataBuff + dwOffset, &wHaveCallNum, sizeof(wHaveCallNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwlastCallTime);
	memcpy(pDataBuff + dwOffset, &qwlastCallTime, sizeof(qwlastCallTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_AWAKEN_BASE_DATA1::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLevel, 0, sizeof(byLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byGoldFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byGoldFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGoldFlag, 0, sizeof(byGoldFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwStudyExp) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStudyExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStudyExp, 0, sizeof(qwStudyExp));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wHaveCallNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wHaveCallNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHaveCallNum, 0, sizeof(wHaveCallNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwlastCallTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwlastCallTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwlastCallTime, 0, sizeof(qwlastCallTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_AWAKEN_DATA(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_DATA *pstIn = (DT_AWAKEN_DATA*)pHost;

	if(-1 == EncodeDT_AWAKEN_BASE_DATA(&pstIn->stBaseInfo, poNetData))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_STUDY_GRID_NUM; i++)
	{
		if(-1 == EncodeDT_STUDY_DATA(&pstIn->astBagStudyInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byZTSUseTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_AWAKEN_DATA(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_DATA *pstOut = (DT_AWAKEN_DATA*)pHost;

	if(-1 == DecodeDT_AWAKEN_BASE_DATA(&pstOut->stBaseInfo, poNetData))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_BAG_STUDY_GRID_NUM; i++)
		{
			if(-1 == DecodeDT_STUDY_DATA(&pstOut->astBagStudyInfo[i], poNetData))
				return -1;
		}

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byZTSUseTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_AWAKEN_DATA(DT_AWAKEN_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "BaseInfo", GetJsonDT_AWAKEN_BASE_DATA(data.stBaseInfo));
	cJSON *BagStudyInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BagStudyInfo", BagStudyInfo);
	for( UINT32 dwIndex=0; dwIndex<MAX_BAG_STUDY_GRID_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(BagStudyInfo, " ", GetJsonDT_STUDY_DATA(data.astBagStudyInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"ZTSUseTime", (double)(data.byZTSUseTime));

	return root;
}

INT32 DT_AWAKEN_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stBaseInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_BAG_STUDY_GRID_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_BAG_STUDY_GRID_NUM; i++)
	{
		dwContextLenTmp += astBagStudyInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byZTSUseTime);
	memcpy(pDataBuff + dwOffset, &byZTSUseTime, sizeof(byZTSUseTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_AWAKEN_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stBaseInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_BAG_STUDY_GRID_NUM ? wArrNum : MAX_BAG_STUDY_GRID_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astBagStudyInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astBagStudyInfo, 0, sizeof(astBagStudyInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 3:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byZTSUseTime) >= pstIndex->dwContextLen)
				{
					memcpy(&byZTSUseTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byZTSUseTime, 0, sizeof(byZTSUseTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_AWAKEN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_DATA_LST *pstIn = (DT_AWAKEN_DATA_LST*)pHost;

	INT32 i;
	for(i = 0; i < MAX_HERO_STUDY_GRID_NUM; i++)
	{
		if(-1 == EncodeDT_STUDY_DATA(&pstIn->astStudyInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_AWAKEN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_AWAKEN_DATA_LST *pstOut = (DT_AWAKEN_DATA_LST*)pHost;

	INT32 i;
		for(i = 0; i < MAX_HERO_STUDY_GRID_NUM; i++)
		{
			if(-1 == DecodeDT_STUDY_DATA(&pstOut->astStudyInfo[i], poNetData))
				return -1;
		}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_AWAKEN_DATA_LST(DT_AWAKEN_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON *StudyInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "StudyInfo", StudyInfo);
	for( UINT32 dwIndex=0; dwIndex<MAX_HERO_STUDY_GRID_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(StudyInfo, " ", GetJsonDT_STUDY_DATA(data.astStudyInfo[dwIndex]));
	}

	return root;
}

INT32 DT_AWAKEN_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_HERO_STUDY_GRID_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_HERO_STUDY_GRID_NUM; i++)
	{
		dwContextLenTmp += astStudyInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_AWAKEN_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_HERO_STUDY_GRID_NUM ? wArrNum : MAX_HERO_STUDY_GRID_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astStudyInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astStudyInfo, 0, sizeof(astStudyInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ABSORB_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_ABSORB_DATA_LST *pstIn = (DT_ABSORB_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAbsorbNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ABSORB_NUM; i++)
	{
		if(i >= (INT32)pstIn->byAbsorbNum)
			break;
		if(-1 == poNetData->AddWord(pstIn->awKindIDLst[i]))
			return -1;
	}

	if(-1 == poNetData->AddWord(pstIn->wAbsorbKindID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ABSORB_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_ABSORB_DATA_LST *pstOut = (DT_ABSORB_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAbsorbNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ABSORB_NUM; i++)
	{
		if(i >= (INT32)pstOut->byAbsorbNum)
			break;
		if(-1 == poNetData->DelWord(pstOut->awKindIDLst[i]))
			return -1;
	}

	if(-1 == poNetData->DelWord(pstOut->wAbsorbKindID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ABSORB_DATA_LST(DT_ABSORB_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AbsorbNum", (double)(data.byAbsorbNum));
	cJSON *KindIDLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "KindIDLst", KindIDLst);
	for( UINT32 dwIndex=0; dwIndex<data.byAbsorbNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"KindIDLst", (double)(data.awKindIDLst[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"AbsorbKindID", (double)(data.wAbsorbKindID));

	return root;
}

INT32 DT_ABSORB_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAbsorbNum);
	memcpy(pDataBuff + dwOffset, &byAbsorbNum, sizeof(byAbsorbNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(byAbsorbNum > MAX_ABSORB_NUM)
	{
		byAbsorbNum = MAX_ABSORB_NUM;
	}
	pstIndex->dwContextLen = byAbsorbNum * sizeof(UINT16) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byAbsorbNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awKindIDLst, byAbsorbNum * sizeof(UINT16));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wAbsorbKindID);
	memcpy(pDataBuff + dwOffset, &wAbsorbKindID, sizeof(wAbsorbKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ABSORB_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAbsorbNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAbsorbNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAbsorbNum, 0, sizeof(byAbsorbNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awKindIDLst) >= dwContextLen) && (wArrNum == byAbsorbNum) && (wArrNum <= MAX_ABSORB_NUM))
				{
					memcpy(&awKindIDLst, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awKindIDLst, 0, sizeof(awKindIDLst));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wAbsorbKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wAbsorbKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAbsorbKindID, 0, sizeof(wAbsorbKindID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTR_INC_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTR_INC_DATA *pstIn = (DT_ATTR_INC_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttrKind))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAttrValue))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTR_INC_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTR_INC_DATA *pstOut = (DT_ATTR_INC_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttrKind))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAttrValue))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTR_INC_DATA(DT_ATTR_INC_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttrKind", (double)(data.byAttrKind));
	cJSON_AddNumberToObject(root,"AttrValue", (double)(data.dwAttrValue));

	return root;
}

INT32 DT_ATTR_INC_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttrKind);
	memcpy(pDataBuff + dwOffset, &byAttrKind, sizeof(byAttrKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwAttrValue);
	memcpy(pDataBuff + dwOffset, &dwAttrValue, sizeof(dwAttrValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTR_INC_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttrKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttrKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttrKind, 0, sizeof(byAttrKind));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwAttrValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAttrValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAttrValue, 0, sizeof(dwAttrValue));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ATTR_LST_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTR_LST_INFO *pstIn = (DT_BATTLE_ATTR_LST_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttrNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstIn->byAttrNum)
			break;
		if(-1 == EncodeDT_ATTR_INC_DATA(&pstIn->astAttrInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ATTR_LST_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTR_LST_INFO *pstOut = (DT_BATTLE_ATTR_LST_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttrNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstOut->byAttrNum)
			break;
		if(-1 == DecodeDT_ATTR_INC_DATA(&pstOut->astAttrInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ATTR_LST_INFO(DT_BATTLE_ATTR_LST_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttrNum", (double)(data.byAttrNum));
	cJSON *AttrInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "AttrInfo", AttrInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byAttrNum; ++dwIndex)
	{
		cJSON_AddItemToObject(AttrInfo, " ", GetJsonDT_ATTR_INC_DATA(data.astAttrInfo[dwIndex]));
	}

	return root;
}

INT32 DT_BATTLE_ATTR_LST_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttrNum);
	memcpy(pDataBuff + dwOffset, &byAttrNum, sizeof(byAttrNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byAttrNum > MAX_SCIENCE_ATTR_NUM)
	{
		byAttrNum = MAX_SCIENCE_ATTR_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAttrNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAttrNum; i++)
	{
		dwContextLenTmp += astAttrInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ATTR_LST_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttrNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttrNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttrNum, 0, sizeof(byAttrNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAttrNum)
				{
					wArrNum = wArrNum <= MAX_SCIENCE_ATTR_NUM ? wArrNum : MAX_SCIENCE_ATTR_NUM;
					byAttrNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astAttrInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astAttrInfo, 0, sizeof(astAttrInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astAttrInfo, 0, sizeof(astAttrInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ATTR_EXT_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTR_EXT_INFO *pstIn = (DT_BATTLE_ATTR_EXT_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byKindID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwKindValue))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ATTR_EXT_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTR_EXT_INFO *pstOut = (DT_BATTLE_ATTR_EXT_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byKindID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwKindValue))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ATTR_EXT_INFO(DT_BATTLE_ATTR_EXT_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.byKindID));
	cJSON_AddNumberToObject(root,"KindValue", (double)(data.dwKindValue));
	cJSON_AddNumberToObject(root,"Level", (double)(data.byLevel));

	return root;
}

INT32 DT_BATTLE_ATTR_EXT_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byKindID);
	memcpy(pDataBuff + dwOffset, &byKindID, sizeof(byKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwKindValue);
	memcpy(pDataBuff + dwOffset, &dwKindValue, sizeof(dwKindValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byLevel);
	memcpy(pDataBuff + dwOffset, &byLevel, sizeof(byLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ATTR_EXT_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&byKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKindID, 0, sizeof(byKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwKindValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwKindValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwKindValue, 0, sizeof(dwKindValue));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLevel, 0, sizeof(byLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ATTR_EXT_LST_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTR_EXT_LST_INFO *pstIn = (DT_BATTLE_ATTR_EXT_LST_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byExtAttrNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstIn->byExtAttrNum)
			break;
		if(-1 == EncodeDT_BATTLE_ATTR_EXT_INFO(&pstIn->astExtAttrInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ATTR_EXT_LST_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ATTR_EXT_LST_INFO *pstOut = (DT_BATTLE_ATTR_EXT_LST_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byExtAttrNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstOut->byExtAttrNum)
			break;
		if(-1 == DecodeDT_BATTLE_ATTR_EXT_INFO(&pstOut->astExtAttrInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ATTR_EXT_LST_INFO(DT_BATTLE_ATTR_EXT_LST_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ExtAttrNum", (double)(data.byExtAttrNum));
	cJSON *ExtAttrInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ExtAttrInfo", ExtAttrInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byExtAttrNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ExtAttrInfo, " ", GetJsonDT_BATTLE_ATTR_EXT_INFO(data.astExtAttrInfo[dwIndex]));
	}

	return root;
}

INT32 DT_BATTLE_ATTR_EXT_LST_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byExtAttrNum);
	memcpy(pDataBuff + dwOffset, &byExtAttrNum, sizeof(byExtAttrNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byExtAttrNum > MAX_SCIENCE_ATTR_NUM)
	{
		byExtAttrNum = MAX_SCIENCE_ATTR_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byExtAttrNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byExtAttrNum; i++)
	{
		dwContextLenTmp += astExtAttrInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ATTR_EXT_LST_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byExtAttrNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byExtAttrNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byExtAttrNum, 0, sizeof(byExtAttrNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byExtAttrNum)
				{
					wArrNum = wArrNum <= MAX_SCIENCE_ATTR_NUM ? wArrNum : MAX_SCIENCE_ATTR_NUM;
					byExtAttrNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astExtAttrInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astExtAttrInfo, 0, sizeof(astExtAttrInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astExtAttrInfo, 0, sizeof(astExtAttrInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_JEWELRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_JEWELRY_DATA *pstIn = (DT_JEWELRY_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wJewelryID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wJewelryLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byJewelryDressPos))
		return -1;

	if(-1 == EncodeDT_BATTLE_ATTR_LST_INFO(&pstIn->stBaseAttrLst, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_ATTR_EXT_LST_INFO(&pstIn->stExtAttrLst, poNetData))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBagPos))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwItemNewTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wStrengLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_JEWELRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_JEWELRY_DATA *pstOut = (DT_JEWELRY_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wJewelryID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wJewelryLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byJewelryDressPos))
		return -1;

	if(-1 == DecodeDT_BATTLE_ATTR_LST_INFO(&pstOut->stBaseAttrLst, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_ATTR_EXT_LST_INFO(&pstOut->stExtAttrLst, poNetData))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBagPos))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwItemNewTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wStrengLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_JEWELRY_DATA(DT_JEWELRY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"JewelryID", (double)(data.wJewelryID));
	cJSON_AddNumberToObject(root,"JewelryLevel", (double)(data.wJewelryLevel));
	cJSON_AddNumberToObject(root,"JewelryDressPos", (double)(data.byJewelryDressPos));
	cJSON_AddItemToObject(root, "BaseAttrLst", GetJsonDT_BATTLE_ATTR_LST_INFO(data.stBaseAttrLst));
	cJSON_AddItemToObject(root, "ExtAttrLst", GetJsonDT_BATTLE_ATTR_EXT_LST_INFO(data.stExtAttrLst));
	cJSON_AddNumberToObject(root,"Idx", (double)(data.wIdx));
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));
	cJSON_AddNumberToObject(root,"BagPos", (double)(data.wBagPos));
	cJSON_AddNumberToObject(root,"ItemNewTime", (double)(data.qwItemNewTime));
	cJSON_AddNumberToObject(root,"StrengLevel", (double)(data.wStrengLevel));

	return root;
}

INT32 DT_JEWELRY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wJewelryID);
	memcpy(pDataBuff + dwOffset, &wJewelryID, sizeof(wJewelryID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wJewelryLevel);
	memcpy(pDataBuff + dwOffset, &wJewelryLevel, sizeof(wJewelryLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byJewelryDressPos);
	memcpy(pDataBuff + dwOffset, &byJewelryDressPos, sizeof(byJewelryDressPos));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stBaseAttrLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stExtAttrLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wIdx);
	memcpy(pDataBuff + dwOffset, &wIdx, sizeof(wIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wBagPos);
	memcpy(pDataBuff + dwOffset, &wBagPos, sizeof(wBagPos));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwItemNewTime);
	memcpy(pDataBuff + dwOffset, &qwItemNewTime, sizeof(qwItemNewTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(wStrengLevel);
	memcpy(pDataBuff + dwOffset, &wStrengLevel, sizeof(wStrengLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_JEWELRY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wJewelryID) >= pstIndex->dwContextLen)
				{
					memcpy(&wJewelryID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wJewelryID, 0, sizeof(wJewelryID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wJewelryLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wJewelryLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wJewelryLevel, 0, sizeof(wJewelryLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byJewelryDressPos) >= pstIndex->dwContextLen)
				{
					memcpy(&byJewelryDressPos, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byJewelryDressPos, 0, sizeof(byJewelryDressPos));
				}
			}
			break;
		case 4:
			{
				stBaseAttrLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stExtAttrLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				if(sizeof(wIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wIdx, 0, sizeof(wIdx));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wBagPos) >= pstIndex->dwContextLen)
				{
					memcpy(&wBagPos, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBagPos, 0, sizeof(wBagPos));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwItemNewTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwItemNewTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwItemNewTime, 0, sizeof(qwItemNewTime));
				}
			}
			break;
		case 10:
			{
				if(sizeof(wStrengLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wStrengLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wStrengLevel, 0, sizeof(wStrengLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_JEWELRY_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_JEWELRY_DATA_LST *pstIn = (DT_JEWELRY_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wJewelryNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_JEWELRY_POS; i++)
	{
		if(i >= (INT32)pstIn->wJewelryNum)
			break;
		if(-1 == EncodeDT_JEWELRY_DATA(&pstIn->astJewelryInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_JEWELRY_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_JEWELRY_DATA_LST *pstOut = (DT_JEWELRY_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wJewelryNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_JEWELRY_POS; i++)
	{
		if(i >= (INT32)pstOut->wJewelryNum)
			break;
		if(-1 == DecodeDT_JEWELRY_DATA(&pstOut->astJewelryInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_JEWELRY_DATA_LST(DT_JEWELRY_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"JewelryNum", (double)(data.wJewelryNum));
	cJSON *JewelryInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "JewelryInfo", JewelryInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wJewelryNum; ++dwIndex)
	{
		cJSON_AddItemToObject(JewelryInfo, " ", GetJsonDT_JEWELRY_DATA(data.astJewelryInfo[dwIndex]));
	}

	return root;
}

INT32 DT_JEWELRY_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wJewelryNum);
	memcpy(pDataBuff + dwOffset, &wJewelryNum, sizeof(wJewelryNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wJewelryNum > MAX_JEWELRY_POS)
	{
		wJewelryNum = MAX_JEWELRY_POS;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wJewelryNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wJewelryNum; i++)
	{
		dwContextLenTmp += astJewelryInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_JEWELRY_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wJewelryNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wJewelryNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wJewelryNum, 0, sizeof(wJewelryNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wJewelryNum)
				{
					wArrNum = wArrNum <= MAX_JEWELRY_POS ? wArrNum : MAX_JEWELRY_POS;
					wJewelryNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astJewelryInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astJewelryInfo, 0, sizeof(astJewelryInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astJewelryInfo, 0, sizeof(astJewelryInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BAG_JEWELRY_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BAG_JEWELRY_DATA_LST *pstIn = (DT_BAG_JEWELRY_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wJewelryNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstIn->wJewelryNum)
			break;
		if(-1 == EncodeDT_JEWELRY_DATA(&pstIn->astJewelryInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BAG_JEWELRY_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BAG_JEWELRY_DATA_LST *pstOut = (DT_BAG_JEWELRY_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wJewelryNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM_NEW; i++)
	{
		if(i >= (INT32)pstOut->wJewelryNum)
			break;
		if(-1 == DecodeDT_JEWELRY_DATA(&pstOut->astJewelryInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BAG_JEWELRY_DATA_LST(DT_BAG_JEWELRY_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"JewelryNum", (double)(data.wJewelryNum));
	cJSON *JewelryInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "JewelryInfo", JewelryInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wJewelryNum; ++dwIndex)
	{
		cJSON_AddItemToObject(JewelryInfo, " ", GetJsonDT_JEWELRY_DATA(data.astJewelryInfo[dwIndex]));
	}

	return root;
}

INT32 DT_BAG_JEWELRY_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wJewelryNum);
	memcpy(pDataBuff + dwOffset, &wJewelryNum, sizeof(wJewelryNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wJewelryNum > MAX_BAG_OPEN_NUM_NEW)
	{
		wJewelryNum = MAX_BAG_OPEN_NUM_NEW;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wJewelryNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wJewelryNum; i++)
	{
		dwContextLenTmp += astJewelryInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BAG_JEWELRY_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wJewelryNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wJewelryNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wJewelryNum, 0, sizeof(wJewelryNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wJewelryNum)
				{
					wArrNum = wArrNum <= MAX_BAG_OPEN_NUM_NEW ? wArrNum : MAX_BAG_OPEN_NUM_NEW;
					wJewelryNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astJewelryInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astJewelryInfo, 0, sizeof(astJewelryInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astJewelryInfo, 0, sizeof(astJewelryInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_DATA *pstIn = (DT_HERO_DATA*)pHost;

	if(-1 == EncodeDT_HERO_BASE_DATA(&pstIn->stHeroBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_HERO_EQUIP_DATA_LST(&pstIn->stEquipDataInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_DRUG_DATA_LST(&pstIn->stDrugDataInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_GODWEAPON_DATA(&pstIn->stGodweaponInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_SKILL_DATA_LST(&pstIn->stSkillInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_AWAKEN_DATA_LST(&pstIn->stStudyInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_ABSORB_DATA_LST(&pstIn->stAbsorbInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_DATA *pstOut = (DT_HERO_DATA*)pHost;

	if(-1 == DecodeDT_HERO_BASE_DATA(&pstOut->stHeroBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_HERO_EQUIP_DATA_LST(&pstOut->stEquipDataInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_DRUG_DATA_LST(&pstOut->stDrugDataInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_GODWEAPON_DATA(&pstOut->stGodweaponInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_SKILL_DATA_LST(&pstOut->stSkillInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_AWAKEN_DATA_LST(&pstOut->stStudyInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_ABSORB_DATA_LST(&pstOut->stAbsorbInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_DATA(DT_HERO_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "HeroBaseData", GetJsonDT_HERO_BASE_DATA(data.stHeroBaseData));
	cJSON_AddItemToObject(root, "EquipDataInfo", GetJsonDT_HERO_EQUIP_DATA_LST(data.stEquipDataInfo));
	cJSON_AddItemToObject(root, "DrugDataInfo", GetJsonDT_DRUG_DATA_LST(data.stDrugDataInfo));
	cJSON_AddItemToObject(root, "GodweaponInfo", GetJsonDT_GODWEAPON_DATA(data.stGodweaponInfo));
	cJSON_AddItemToObject(root, "SkillInfo", GetJsonDT_SKILL_DATA_LST(data.stSkillInfo));
	cJSON_AddItemToObject(root, "StudyInfo", GetJsonDT_AWAKEN_DATA_LST(data.stStudyInfo));
	cJSON_AddItemToObject(root, "AbsorbInfo", GetJsonDT_ABSORB_DATA_LST(data.stAbsorbInfo));

	return root;
}

INT32 DT_HERO_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stHeroBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEquipDataInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stDrugDataInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stGodweaponInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stSkillInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stStudyInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stAbsorbInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stHeroBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEquipDataInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stDrugDataInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stGodweaponInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stSkillInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stStudyInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				stAbsorbInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_HERO_DATA_LIST *pstIn = (DT_HERO_DATA_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHeroNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_HERO_NUM; i++)
	{
		if(i >= (INT32)pstIn->wHeroNum)
			break;
		if(-1 == EncodeDT_HERO_DATA(&pstIn->astHeroInfoLst[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_HERO_NUM; i++)
	{
		if(i >= (INT32)pstIn->wHeroNum)
			break;
		if(-1 == EncodeDT_JEWELRY_DATA_LST(&pstIn->astjewelryInfoLst[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_HERO_NUM; i++)
	{
		if(i >= (INT32)pstIn->wHeroNum)
			break;
		if(-1 == EncodeDT_HERO_SOUL_DATA(&pstIn->astSoulInfoLst[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_HERO_DATA_LIST *pstOut = (DT_HERO_DATA_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHeroNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_HERO_NUM; i++)
	{
		if(i >= (INT32)pstOut->wHeroNum)
			break;
		if(-1 == DecodeDT_HERO_DATA(&pstOut->astHeroInfoLst[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_HERO_NUM; i++)
	{
		if(i >= (INT32)pstOut->wHeroNum)
			break;
		if(-1 == DecodeDT_JEWELRY_DATA_LST(&pstOut->astjewelryInfoLst[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_HERO_NUM; i++)
	{
		if(i >= (INT32)pstOut->wHeroNum)
			break;
		if(-1 == DecodeDT_HERO_SOUL_DATA(&pstOut->astSoulInfoLst[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_DATA_LIST(DT_HERO_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroNum", (double)(data.wHeroNum));
	cJSON *HeroInfoLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HeroInfoLst", HeroInfoLst);
	for( UINT32 dwIndex=0; dwIndex<data.wHeroNum; ++dwIndex)
	{
		cJSON_AddItemToObject(HeroInfoLst, " ", GetJsonDT_HERO_DATA(data.astHeroInfoLst[dwIndex]));
	}
	cJSON *jewelryInfoLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "jewelryInfoLst", jewelryInfoLst);
	for( UINT32 dwIndex=0; dwIndex<data.wHeroNum; ++dwIndex)
	{
		cJSON_AddItemToObject(jewelryInfoLst, " ", GetJsonDT_JEWELRY_DATA_LST(data.astjewelryInfoLst[dwIndex]));
	}
	cJSON *SoulInfoLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulInfoLst", SoulInfoLst);
	for( UINT32 dwIndex=0; dwIndex<data.wHeroNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SoulInfoLst, " ", GetJsonDT_HERO_SOUL_DATA(data.astSoulInfoLst[dwIndex]));
	}

	return root;
}

INT32 DT_HERO_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHeroNum);
	memcpy(pDataBuff + dwOffset, &wHeroNum, sizeof(wHeroNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wHeroNum > MAX_HERO_NUM)
	{
		wHeroNum = MAX_HERO_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wHeroNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wHeroNum; i++)
	{
		dwContextLenTmp += astHeroInfoLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(wHeroNum > MAX_HERO_NUM)
	{
		wHeroNum = MAX_HERO_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wHeroNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wHeroNum; i++)
	{
		dwContextLenTmp += astjewelryInfoLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(wHeroNum > MAX_HERO_NUM)
	{
		wHeroNum = MAX_HERO_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wHeroNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wHeroNum; i++)
	{
		dwContextLenTmp += astSoulInfoLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHeroNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroNum, 0, sizeof(wHeroNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wHeroNum)
				{
					wArrNum = wArrNum <= MAX_HERO_NUM ? wArrNum : MAX_HERO_NUM;
					wHeroNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astHeroInfoLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astHeroInfoLst, 0, sizeof(astHeroInfoLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astHeroInfoLst, 0, sizeof(astHeroInfoLst));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wHeroNum)
				{
					wArrNum = wArrNum <= MAX_HERO_NUM ? wArrNum : MAX_HERO_NUM;
					wHeroNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astjewelryInfoLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astjewelryInfoLst, 0, sizeof(astjewelryInfoLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astjewelryInfoLst, 0, sizeof(astjewelryInfoLst));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wHeroNum)
				{
					wArrNum = wArrNum <= MAX_HERO_NUM ? wArrNum : MAX_HERO_NUM;
					wHeroNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSoulInfoLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSoulInfoLst, 0, sizeof(astSoulInfoLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSoulInfoLst, 0, sizeof(astSoulInfoLst));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BUILD_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BUILD_BASE_DATA *pstIn = (DT_BUILD_BASE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwValue1))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwValue2))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byValue3))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySort))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveOpenFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BUILD_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BUILD_BASE_DATA *pstOut = (DT_BUILD_BASE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwValue1))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwValue2))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byValue3))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySort))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveOpenFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BUILD_BASE_DATA(DT_BUILD_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.byKindID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"Value1", (double)(data.qwValue1));
	cJSON_AddNumberToObject(root,"Value2", (double)(data.qwValue2));
	cJSON_AddNumberToObject(root,"Value3", (double)(data.byValue3));
	cJSON_AddNumberToObject(root,"Sort", (double)(data.bySort));
	cJSON_AddNumberToObject(root,"HaveOpenFlag", (double)(data.byHaveOpenFlag));

	return root;
}

INT32 DT_BUILD_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byKindID);
	memcpy(pDataBuff + dwOffset, &byKindID, sizeof(byKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwValue1);
	memcpy(pDataBuff + dwOffset, &qwValue1, sizeof(qwValue1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwValue2);
	memcpy(pDataBuff + dwOffset, &qwValue2, sizeof(qwValue2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byValue3);
	memcpy(pDataBuff + dwOffset, &byValue3, sizeof(byValue3));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(bySort);
	memcpy(pDataBuff + dwOffset, &bySort, sizeof(bySort));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byHaveOpenFlag);
	memcpy(pDataBuff + dwOffset, &byHaveOpenFlag, sizeof(byHaveOpenFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BUILD_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&byKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKindID, 0, sizeof(byKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwValue1) >= pstIndex->dwContextLen)
				{
					memcpy(&qwValue1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwValue1, 0, sizeof(qwValue1));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwValue2) >= pstIndex->dwContextLen)
				{
					memcpy(&qwValue2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwValue2, 0, sizeof(qwValue2));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byValue3) >= pstIndex->dwContextLen)
				{
					memcpy(&byValue3, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byValue3, 0, sizeof(byValue3));
				}
			}
			break;
		case 6:
			{
				if(sizeof(bySort) >= pstIndex->dwContextLen)
				{
					memcpy(&bySort, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySort, 0, sizeof(bySort));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byHaveOpenFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveOpenFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveOpenFlag, 0, sizeof(byHaveOpenFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BUILD_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_BUILD_DATA_LIST *pstIn = (DT_BUILD_DATA_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wBuildNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BUILD_NUM; i++)
	{
		if(i >= (INT32)pstIn->wBuildNum)
			break;
		if(-1 == EncodeDT_BUILD_BASE_DATA(&pstIn->astBuildInfoLst[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BUILD_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_BUILD_DATA_LIST *pstOut = (DT_BUILD_DATA_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wBuildNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BUILD_NUM; i++)
	{
		if(i >= (INT32)pstOut->wBuildNum)
			break;
		if(-1 == DecodeDT_BUILD_BASE_DATA(&pstOut->astBuildInfoLst[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BUILD_DATA_LIST(DT_BUILD_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BuildNum", (double)(data.wBuildNum));
	cJSON *BuildInfoLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BuildInfoLst", BuildInfoLst);
	for( UINT32 dwIndex=0; dwIndex<data.wBuildNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BuildInfoLst, " ", GetJsonDT_BUILD_BASE_DATA(data.astBuildInfoLst[dwIndex]));
	}

	return root;
}

INT32 DT_BUILD_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wBuildNum);
	memcpy(pDataBuff + dwOffset, &wBuildNum, sizeof(wBuildNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wBuildNum > MAX_BUILD_NUM)
	{
		wBuildNum = MAX_BUILD_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wBuildNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wBuildNum; i++)
	{
		dwContextLenTmp += astBuildInfoLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BUILD_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wBuildNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wBuildNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBuildNum, 0, sizeof(wBuildNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wBuildNum)
				{
					wArrNum = wArrNum <= MAX_BUILD_NUM ? wArrNum : MAX_BUILD_NUM;
					wBuildNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBuildInfoLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBuildInfoLst, 0, sizeof(astBuildInfoLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBuildInfoLst, 0, sizeof(astBuildInfoLst));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_INSTANCE_ID(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_ID *pstIn = (DT_INSTANCE_ID*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_INSTANCE_ID(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_ID *pstOut = (DT_INSTANCE_ID*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_INSTANCE_ID(DT_INSTANCE_ID &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));

	return root;
}

INT32 DT_INSTANCE_ID::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_INSTANCE_ID::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_INSTANCE_DATA(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_DATA *pstIn = (DT_INSTANCE_DATA*)pHost;

	if(-1 == EncodeDT_INSTANCE_ID(&pstIn->stInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastPassTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSuccessNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFailedNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastConFailedNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMaxConFailedNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_INSTANCE_DATA(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_DATA *pstOut = (DT_INSTANCE_DATA*)pHost;

	if(-1 == DecodeDT_INSTANCE_ID(&pstOut->stInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastPassTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSuccessNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFailedNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastConFailedNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMaxConFailedNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_INSTANCE_DATA(DT_INSTANCE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "InstanceID", GetJsonDT_INSTANCE_ID(data.stInstanceID));
	cJSON_AddNumberToObject(root,"LastPassTime", (double)(data.qwLastPassTime));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));
	cJSON_AddNumberToObject(root,"SuccessNum", (double)(data.dwSuccessNum));
	cJSON_AddNumberToObject(root,"FailedNum", (double)(data.dwFailedNum));
	cJSON_AddNumberToObject(root,"LastConFailedNum", (double)(data.wLastConFailedNum));
	cJSON_AddNumberToObject(root,"MaxConFailedNum", (double)(data.wMaxConFailedNum));

	return root;
}

INT32 DT_INSTANCE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stInstanceID.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastPassTime);
	memcpy(pDataBuff + dwOffset, &qwLastPassTime, sizeof(qwLastPassTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwSuccessNum);
	memcpy(pDataBuff + dwOffset, &dwSuccessNum, sizeof(dwSuccessNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwFailedNum);
	memcpy(pDataBuff + dwOffset, &dwFailedNum, sizeof(dwFailedNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wLastConFailedNum);
	memcpy(pDataBuff + dwOffset, &wLastConFailedNum, sizeof(wLastConFailedNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wMaxConFailedNum);
	memcpy(pDataBuff + dwOffset, &wMaxConFailedNum, sizeof(wMaxConFailedNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_INSTANCE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stInstanceID.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				if(sizeof(qwLastPassTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastPassTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastPassTime, 0, sizeof(qwLastPassTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwSuccessNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSuccessNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSuccessNum, 0, sizeof(dwSuccessNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwFailedNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFailedNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFailedNum, 0, sizeof(dwFailedNum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wLastConFailedNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastConFailedNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastConFailedNum, 0, sizeof(wLastConFailedNum));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wMaxConFailedNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaxConFailedNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaxConFailedNum, 0, sizeof(wMaxConFailedNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_INSTANCE_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_DATA_LIST *pstIn = (DT_INSTANCE_DATA_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wInstanceNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_INSTANCE_PER_SCENE_NUM; i++)
	{
		if(i >= (INT32)pstIn->wInstanceNum)
			break;
		if(-1 == EncodeDT_INSTANCE_DATA(&pstIn->astInstanceInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_INSTANCE_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_DATA_LIST *pstOut = (DT_INSTANCE_DATA_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wInstanceNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_INSTANCE_PER_SCENE_NUM; i++)
	{
		if(i >= (INT32)pstOut->wInstanceNum)
			break;
		if(-1 == DecodeDT_INSTANCE_DATA(&pstOut->astInstanceInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_INSTANCE_DATA_LIST(DT_INSTANCE_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"InstanceNum", (double)(data.wInstanceNum));
	cJSON *InstanceInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "InstanceInfo", InstanceInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wInstanceNum; ++dwIndex)
	{
		cJSON_AddItemToObject(InstanceInfo, " ", GetJsonDT_INSTANCE_DATA(data.astInstanceInfo[dwIndex]));
	}

	return root;
}

INT32 DT_INSTANCE_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wInstanceNum);
	memcpy(pDataBuff + dwOffset, &wInstanceNum, sizeof(wInstanceNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(wInstanceNum > MAX_INSTANCE_PER_SCENE_NUM)
	{
		wInstanceNum = MAX_INSTANCE_PER_SCENE_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wInstanceNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wInstanceNum; i++)
	{
		dwContextLenTmp += astInstanceInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_INSTANCE_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wInstanceNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wInstanceNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wInstanceNum, 0, sizeof(wInstanceNum));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wInstanceNum)
				{
					wArrNum = wArrNum <= MAX_INSTANCE_PER_SCENE_NUM ? wArrNum : MAX_INSTANCE_PER_SCENE_NUM;
					wInstanceNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astInstanceInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astInstanceInfo, 0, sizeof(astInstanceInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astInstanceInfo, 0, sizeof(astInstanceInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SCIENCE_ATTREXT(void *pHost, CNetData* poNetData)
{
	DT_SCIENCE_ATTREXT *pstIn = (DT_SCIENCE_ATTREXT*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttrKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttrLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SCIENCE_ATTREXT(void *pHost, CNetData* poNetData)
{
	DT_SCIENCE_ATTREXT *pstOut = (DT_SCIENCE_ATTREXT*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttrKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttrLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SCIENCE_ATTREXT(DT_SCIENCE_ATTREXT &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttrKindID", (double)(data.byAttrKindID));
	cJSON_AddNumberToObject(root,"AttrLevel", (double)(data.wAttrLevel));

	return root;
}

INT32 DT_SCIENCE_ATTREXT::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttrKindID);
	memcpy(pDataBuff + dwOffset, &byAttrKindID, sizeof(byAttrKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAttrLevel);
	memcpy(pDataBuff + dwOffset, &wAttrLevel, sizeof(wAttrLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SCIENCE_ATTREXT::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttrKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttrKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttrKindID, 0, sizeof(byAttrKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAttrLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttrLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttrLevel, 0, sizeof(wAttrLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SCIENCE_ATTREXT_LIST(void *pHost, CNetData* poNetData)
{
	DT_SCIENCE_ATTREXT_LIST *pstIn = (DT_SCIENCE_ATTREXT_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttrNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstIn->byAttrNum)
			break;
		if(-1 == EncodeDT_SCIENCE_ATTREXT(&pstIn->astBuildInfoLst[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SCIENCE_ATTREXT_LIST(void *pHost, CNetData* poNetData)
{
	DT_SCIENCE_ATTREXT_LIST *pstOut = (DT_SCIENCE_ATTREXT_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttrNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstOut->byAttrNum)
			break;
		if(-1 == DecodeDT_SCIENCE_ATTREXT(&pstOut->astBuildInfoLst[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SCIENCE_ATTREXT_LIST(DT_SCIENCE_ATTREXT_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttrNum", (double)(data.byAttrNum));
	cJSON *BuildInfoLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BuildInfoLst", BuildInfoLst);
	for( UINT32 dwIndex=0; dwIndex<data.byAttrNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BuildInfoLst, " ", GetJsonDT_SCIENCE_ATTREXT(data.astBuildInfoLst[dwIndex]));
	}

	return root;
}

INT32 DT_SCIENCE_ATTREXT_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttrNum);
	memcpy(pDataBuff + dwOffset, &byAttrNum, sizeof(byAttrNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byAttrNum > MAX_SCIENCE_ATTR_NUM)
	{
		byAttrNum = MAX_SCIENCE_ATTR_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAttrNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAttrNum; i++)
	{
		dwContextLenTmp += astBuildInfoLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SCIENCE_ATTREXT_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttrNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttrNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttrNum, 0, sizeof(byAttrNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAttrNum)
				{
					wArrNum = wArrNum <= MAX_SCIENCE_ATTR_NUM ? wArrNum : MAX_SCIENCE_ATTR_NUM;
					byAttrNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBuildInfoLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBuildInfoLst, 0, sizeof(astBuildInfoLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBuildInfoLst, 0, sizeof(astBuildInfoLst));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CROWN_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROWN_TASK_CONDITION *pstIn = (DT_CROWN_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wCrownTimes))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CROWN_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROWN_TASK_CONDITION *pstOut = (DT_CROWN_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wCrownTimes))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CROWN_TASK_CONDITION(DT_CROWN_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CrownTimes", (double)(data.wCrownTimes));

	return root;
}

INT32 DT_CROWN_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wCrownTimes);
	memcpy(pDataBuff + dwOffset, &wCrownTimes, sizeof(wCrownTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CROWN_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wCrownTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&wCrownTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCrownTimes, 0, sizeof(wCrownTimes));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BUILDUPGRADE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_BUILDUPGRADE_TASK_CONDITION *pstIn = (DT_BUILDUPGRADE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBuildKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BUILDUPGRADE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_BUILDUPGRADE_TASK_CONDITION *pstOut = (DT_BUILDUPGRADE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBuildKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BUILDUPGRADE_TASK_CONDITION(DT_BUILDUPGRADE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BuildKindID", (double)(data.byBuildKindID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));

	return root;
}

INT32 DT_BUILDUPGRADE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBuildKindID);
	memcpy(pDataBuff + dwOffset, &byBuildKindID, sizeof(byBuildKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BUILDUPGRADE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBuildKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&byBuildKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBuildKindID, 0, sizeof(byBuildKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RECRUITHERO_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_RECRUITHERO_TASK_CONDITION *pstIn = (DT_RECRUITHERO_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wRecruitHeroKindID1))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wRecruitHeroKindID2))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RECRUITHERO_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_RECRUITHERO_TASK_CONDITION *pstOut = (DT_RECRUITHERO_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wRecruitHeroKindID1))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wRecruitHeroKindID2))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RECRUITHERO_TASK_CONDITION(DT_RECRUITHERO_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RecruitHeroKindID1", (double)(data.wRecruitHeroKindID1));
	cJSON_AddNumberToObject(root,"RecruitHeroKindID2", (double)(data.wRecruitHeroKindID2));

	return root;
}

INT32 DT_RECRUITHERO_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wRecruitHeroKindID1);
	memcpy(pDataBuff + dwOffset, &wRecruitHeroKindID1, sizeof(wRecruitHeroKindID1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wRecruitHeroKindID2);
	memcpy(pDataBuff + dwOffset, &wRecruitHeroKindID2, sizeof(wRecruitHeroKindID2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RECRUITHERO_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wRecruitHeroKindID1) >= pstIndex->dwContextLen)
				{
					memcpy(&wRecruitHeroKindID1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRecruitHeroKindID1, 0, sizeof(wRecruitHeroKindID1));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wRecruitHeroKindID2) >= pstIndex->dwContextLen)
				{
					memcpy(&wRecruitHeroKindID2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRecruitHeroKindID2, 0, sizeof(wRecruitHeroKindID2));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CROWN_HEROCOLOR_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROWN_HEROCOLOR_CONDITION *pstIn = (DT_CROWN_HEROCOLOR_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHeroColor))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CROWN_HEROCOLOR_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROWN_HEROCOLOR_CONDITION *pstOut = (DT_CROWN_HEROCOLOR_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHeroColor))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CROWN_HEROCOLOR_CONDITION(DT_CROWN_HEROCOLOR_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroColor", (double)(data.wHeroColor));
	cJSON_AddNumberToObject(root,"Num", (double)(data.byNum));

	return root;
}

INT32 DT_CROWN_HEROCOLOR_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHeroColor);
	memcpy(pDataBuff + dwOffset, &wHeroColor, sizeof(wHeroColor));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byNum);
	memcpy(pDataBuff + dwOffset, &byNum, sizeof(byNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CROWN_HEROCOLOR_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHeroColor) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroColor, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroColor, 0, sizeof(wHeroColor));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNum, 0, sizeof(byNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CROWN_HEROUPGRADE_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROWN_HEROUPGRADE_CONDITION *pstIn = (DT_CROWN_HEROUPGRADE_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHeroLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CROWN_HEROUPGRADE_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROWN_HEROUPGRADE_CONDITION *pstOut = (DT_CROWN_HEROUPGRADE_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHeroLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CROWN_HEROUPGRADE_CONDITION(DT_CROWN_HEROUPGRADE_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroLevel", (double)(data.wHeroLevel));
	cJSON_AddNumberToObject(root,"Num", (double)(data.byNum));

	return root;
}

INT32 DT_CROWN_HEROUPGRADE_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHeroLevel);
	memcpy(pDataBuff + dwOffset, &wHeroLevel, sizeof(wHeroLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byNum);
	memcpy(pDataBuff + dwOffset, &byNum, sizeof(byNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CROWN_HEROUPGRADE_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHeroLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroLevel, 0, sizeof(wHeroLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNum, 0, sizeof(byNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FIRSTPASSINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_FIRSTPASSINSTANCE_TASK_CONDITION *pstIn = (DT_FIRSTPASSINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FIRSTPASSINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_FIRSTPASSINSTANCE_TASK_CONDITION *pstOut = (DT_FIRSTPASSINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FIRSTPASSINSTANCE_TASK_CONDITION(DT_FIRSTPASSINSTANCE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));

	return root;
}

INT32 DT_FIRSTPASSINSTANCE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FIRSTPASSINSTANCE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SCOREPASSINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_SCOREPASSINSTANCE_TASK_CONDITION *pstIn = (DT_SCOREPASSINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SCOREPASSINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_SCOREPASSINSTANCE_TASK_CONDITION *pstOut = (DT_SCOREPASSINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SCOREPASSINSTANCE_TASK_CONDITION(DT_SCOREPASSINSTANCE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));

	return root;
}

INT32 DT_SCOREPASSINSTANCE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SCOREPASSINSTANCE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_TIMESPASSINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_TIMESPASSINSTANCE_TASK_CONDITION *pstIn = (DT_TIMESPASSINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTimes))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_TIMESPASSINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_TIMESPASSINSTANCE_TASK_CONDITION *pstOut = (DT_TIMESPASSINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTimes))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_TIMESPASSINSTANCE_TASK_CONDITION(DT_TIMESPASSINSTANCE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));
	cJSON_AddNumberToObject(root,"Times", (double)(data.byTimes));

	return root;
}

INT32 DT_TIMESPASSINSTANCE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byTimes);
	memcpy(pDataBuff + dwOffset, &byTimes, sizeof(byTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_TIMESPASSINSTANCE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTimes, 0, sizeof(byTimes));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_KILLMONSTERINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_KILLMONSTERINSTANCE_TASK_CONDITION *pstIn = (DT_KILLMONSTERINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMonsterKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKillNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_KILLMONSTERINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_KILLMONSTERINSTANCE_TASK_CONDITION *pstOut = (DT_KILLMONSTERINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMonsterKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKillNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_KILLMONSTERINSTANCE_TASK_CONDITION(DT_KILLMONSTERINSTANCE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));
	cJSON_AddNumberToObject(root,"MonsterKindID", (double)(data.wMonsterKindID));
	cJSON_AddNumberToObject(root,"KillNum", (double)(data.byKillNum));

	return root;
}

INT32 DT_KILLMONSTERINSTANCE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wMonsterKindID);
	memcpy(pDataBuff + dwOffset, &wMonsterKindID, sizeof(wMonsterKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byKillNum);
	memcpy(pDataBuff + dwOffset, &byKillNum, sizeof(byKillNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_KILLMONSTERINSTANCE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wMonsterKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wMonsterKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMonsterKindID, 0, sizeof(wMonsterKindID));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byKillNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byKillNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKillNum, 0, sizeof(byKillNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_STRENGTHENEQUIPLEVEL_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHENEQUIPLEVEL_TASK_CONDITION *pstIn = (DT_STRENGTHENEQUIPLEVEL_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEquipKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_STRENGTHENEQUIPLEVEL_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHENEQUIPLEVEL_TASK_CONDITION *pstOut = (DT_STRENGTHENEQUIPLEVEL_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEquipKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_STRENGTHENEQUIPLEVEL_TASK_CONDITION(DT_STRENGTHENEQUIPLEVEL_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipKindID", (double)(data.wEquipKindID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));

	return root;
}

INT32 DT_STRENGTHENEQUIPLEVEL_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEquipKindID);
	memcpy(pDataBuff + dwOffset, &wEquipKindID, sizeof(wEquipKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_STRENGTHENEQUIPLEVEL_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEquipKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wEquipKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEquipKindID, 0, sizeof(wEquipKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_STRENGTHENEQUIPNUM_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHENEQUIPNUM_TASK_CONDITION *pstIn = (DT_STRENGTHENEQUIPNUM_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEquipKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_STRENGTHENEQUIPNUM_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHENEQUIPNUM_TASK_CONDITION *pstOut = (DT_STRENGTHENEQUIPNUM_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEquipKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_STRENGTHENEQUIPNUM_TASK_CONDITION(DT_STRENGTHENEQUIPNUM_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipKindID", (double)(data.wEquipKindID));
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_STRENGTHENEQUIPNUM_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEquipKindID);
	memcpy(pDataBuff + dwOffset, &wEquipKindID, sizeof(wEquipKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_STRENGTHENEQUIPNUM_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEquipKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wEquipKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEquipKindID, 0, sizeof(wEquipKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ITEMCOLLECT_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_ITEMCOLLECT_TASK_CONDITION *pstIn = (DT_ITEMCOLLECT_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wItemKindNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ITEM_KIND_COLLECT_NUM; i++)
	{
		if(i >= (INT32)pstIn->wItemKindNum)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyItemCollectInfo[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ITEMCOLLECT_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_ITEMCOLLECT_TASK_CONDITION *pstOut = (DT_ITEMCOLLECT_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wItemKindNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ITEM_KIND_COLLECT_NUM; i++)
	{
		if(i >= (INT32)pstOut->wItemKindNum)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyItemCollectInfo[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ITEMCOLLECT_TASK_CONDITION(DT_ITEMCOLLECT_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ItemKindNum", (double)(data.wItemKindNum));
	cJSON *ItemCollectInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ItemCollectInfo", ItemCollectInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wItemKindNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"ItemCollectInfo", (double)(data.abyItemCollectInfo[dwIndex]));
	}

	return root;
}

INT32 DT_ITEMCOLLECT_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wItemKindNum);
	memcpy(pDataBuff + dwOffset, &wItemKindNum, sizeof(wItemKindNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(wItemKindNum > MAX_ITEM_KIND_COLLECT_NUM)
	{
		wItemKindNum = MAX_ITEM_KIND_COLLECT_NUM;
	}
	pstIndex->dwContextLen = wItemKindNum * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = wItemKindNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyItemCollectInfo, wItemKindNum * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ITEMCOLLECT_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wItemKindNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wItemKindNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wItemKindNum, 0, sizeof(wItemKindNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyItemCollectInfo) >= dwContextLen) && (wArrNum == wItemKindNum) && (wArrNum <= MAX_ITEM_KIND_COLLECT_NUM))
				{
					memcpy(&abyItemCollectInfo, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyItemCollectInfo, 0, sizeof(abyItemCollectInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ACTIVATEGODWEAPON_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_ACTIVATEGODWEAPON_TASK_CONDITION *pstIn = (DT_ACTIVATEGODWEAPON_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ACTIVATEGODWEAPON_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_ACTIVATEGODWEAPON_TASK_CONDITION *pstOut = (DT_ACTIVATEGODWEAPON_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ACTIVATEGODWEAPON_TASK_CONDITION(DT_ACTIVATEGODWEAPON_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));

	return root;
}

INT32 DT_ACTIVATEGODWEAPON_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ACTIVATEGODWEAPON_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_UPGRADEGODWEAPON_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEGODWEAPON_TASK_CONDITION *pstIn = (DT_UPGRADEGODWEAPON_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wQuality))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_UPGRADEGODWEAPON_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEGODWEAPON_TASK_CONDITION *pstOut = (DT_UPGRADEGODWEAPON_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wQuality))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_UPGRADEGODWEAPON_TASK_CONDITION(DT_UPGRADEGODWEAPON_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));
	cJSON_AddNumberToObject(root,"Quality", (double)(data.wQuality));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));

	return root;
}

INT32 DT_UPGRADEGODWEAPON_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wQuality);
	memcpy(pDataBuff + dwOffset, &wQuality, sizeof(wQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_UPGRADEGODWEAPON_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&wQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wQuality, 0, sizeof(wQuality));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_UPGRADEDRUG_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEDRUG_TASK_CONDITION *pstIn = (DT_UPGRADEDRUG_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wUpgradeNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_UPGRADEDRUG_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEDRUG_TASK_CONDITION *pstOut = (DT_UPGRADEDRUG_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wUpgradeNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_UPGRADEDRUG_TASK_CONDITION(DT_UPGRADEDRUG_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"UpgradeNum", (double)(data.wUpgradeNum));

	return root;
}

INT32 DT_UPGRADEDRUG_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wUpgradeNum);
	memcpy(pDataBuff + dwOffset, &wUpgradeNum, sizeof(wUpgradeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_UPGRADEDRUG_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wUpgradeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wUpgradeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wUpgradeNum, 0, sizeof(wUpgradeNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CHALLENGE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CHALLENGE_TASK_CONDITION *pstIn = (DT_CHALLENGE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wChallengeNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CHALLENGE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CHALLENGE_TASK_CONDITION *pstOut = (DT_CHALLENGE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wChallengeNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CHALLENGE_TASK_CONDITION(DT_CHALLENGE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ChallengeNum", (double)(data.wChallengeNum));

	return root;
}

INT32 DT_CHALLENGE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wChallengeNum);
	memcpy(pDataBuff + dwOffset, &wChallengeNum, sizeof(wChallengeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CHALLENGE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wChallengeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wChallengeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wChallengeNum, 0, sizeof(wChallengeNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLUNDER_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_TASK_CONDITION *pstIn = (DT_PLUNDER_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPlunderNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLUNDER_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_TASK_CONDITION *pstOut = (DT_PLUNDER_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPlunderNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLUNDER_TASK_CONDITION(DT_PLUNDER_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlunderNum", (double)(data.wPlunderNum));

	return root;
}

INT32 DT_PLUNDER_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPlunderNum);
	memcpy(pDataBuff + dwOffset, &wPlunderNum, sizeof(wPlunderNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLUNDER_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPlunderNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPlunderNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPlunderNum, 0, sizeof(wPlunderNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DRESSSKILL_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_DRESSSKILL_TASK_CONDITION *pstIn = (DT_DRESSSKILL_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDressFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DRESSSKILL_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_DRESSSKILL_TASK_CONDITION *pstOut = (DT_DRESSSKILL_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDressFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DRESSSKILL_TASK_CONDITION(DT_DRESSSKILL_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SkillID", (double)(data.wSkillID));
	cJSON_AddNumberToObject(root,"DressFlag", (double)(data.byDressFlag));

	return root;
}

INT32 DT_DRESSSKILL_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSkillID);
	memcpy(pDataBuff + dwOffset, &wSkillID, sizeof(wSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byDressFlag);
	memcpy(pDataBuff + dwOffset, &byDressFlag, sizeof(byDressFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DRESSSKILL_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSkillID, 0, sizeof(wSkillID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byDressFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byDressFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDressFlag, 0, sizeof(byDressFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DRESSEQUIP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_DRESSEQUIP_TASK_CONDITION *pstIn = (DT_DRESSEQUIP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEquipID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDressFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DRESSEQUIP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_DRESSEQUIP_TASK_CONDITION *pstOut = (DT_DRESSEQUIP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEquipID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDressFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DRESSEQUIP_TASK_CONDITION(DT_DRESSEQUIP_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipID", (double)(data.wEquipID));
	cJSON_AddNumberToObject(root,"DressFlag", (double)(data.byDressFlag));

	return root;
}

INT32 DT_DRESSEQUIP_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEquipID);
	memcpy(pDataBuff + dwOffset, &wEquipID, sizeof(wEquipID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byDressFlag);
	memcpy(pDataBuff + dwOffset, &byDressFlag, sizeof(byDressFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DRESSEQUIP_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEquipID) >= pstIndex->dwContextLen)
				{
					memcpy(&wEquipID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEquipID, 0, sizeof(wEquipID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byDressFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byDressFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDressFlag, 0, sizeof(byDressFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_UPGRADEEQUIP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEEQUIP_TASK_CONDITION *pstIn = (DT_UPGRADEEQUIP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEquipID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUpgradeFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_UPGRADEEQUIP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEEQUIP_TASK_CONDITION *pstOut = (DT_UPGRADEEQUIP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEquipID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUpgradeFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_UPGRADEEQUIP_TASK_CONDITION(DT_UPGRADEEQUIP_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipID", (double)(data.wEquipID));
	cJSON_AddNumberToObject(root,"UpgradeFlag", (double)(data.byUpgradeFlag));

	return root;
}

INT32 DT_UPGRADEEQUIP_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEquipID);
	memcpy(pDataBuff + dwOffset, &wEquipID, sizeof(wEquipID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byUpgradeFlag);
	memcpy(pDataBuff + dwOffset, &byUpgradeFlag, sizeof(byUpgradeFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_UPGRADEEQUIP_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEquipID) >= pstIndex->dwContextLen)
				{
					memcpy(&wEquipID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEquipID, 0, sizeof(wEquipID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byUpgradeFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byUpgradeFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUpgradeFlag, 0, sizeof(byUpgradeFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_USEEXPRIENCEDRUG_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_USEEXPRIENCEDRUG_TASK_CONDITION *pstIn = (DT_USEEXPRIENCEDRUG_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_USEEXPRIENCEDRUG_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_USEEXPRIENCEDRUG_TASK_CONDITION *pstOut = (DT_USEEXPRIENCEDRUG_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_USEEXPRIENCEDRUG_TASK_CONDITION(DT_USEEXPRIENCEDRUG_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_USEEXPRIENCEDRUG_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_USEEXPRIENCEDRUG_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MELT_EQUIP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_MELT_EQUIP_TASK_CONDITION *pstIn = (DT_MELT_EQUIP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MELT_EQUIP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_MELT_EQUIP_TASK_CONDITION *pstOut = (DT_MELT_EQUIP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MELT_EQUIP_TASK_CONDITION(DT_MELT_EQUIP_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_MELT_EQUIP_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MELT_EQUIP_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COMPOSEGOOD_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_COMPOSEGOOD_TASK_CONDITION *pstIn = (DT_COMPOSEGOOD_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wMaterialID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMaterialNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COMPOSEGOOD_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_COMPOSEGOOD_TASK_CONDITION *pstOut = (DT_COMPOSEGOOD_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wMaterialID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMaterialNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COMPOSEGOOD_TASK_CONDITION(DT_COMPOSEGOOD_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MaterialID", (double)(data.wMaterialID));
	cJSON_AddNumberToObject(root,"MaterialNum", (double)(data.wMaterialNum));
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_COMPOSEGOOD_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wMaterialID);
	memcpy(pDataBuff + dwOffset, &wMaterialID, sizeof(wMaterialID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wMaterialNum);
	memcpy(pDataBuff + dwOffset, &wMaterialNum, sizeof(wMaterialNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COMPOSEGOOD_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wMaterialID) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaterialID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaterialID, 0, sizeof(wMaterialID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wMaterialNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaterialNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaterialNum, 0, sizeof(wMaterialNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ELITEINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_ELITEINSTANCE_TASK_CONDITION *pstIn = (DT_ELITEINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUpgradeFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ELITEINSTANCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_ELITEINSTANCE_TASK_CONDITION *pstOut = (DT_ELITEINSTANCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUpgradeFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ELITEINSTANCE_TASK_CONDITION(DT_ELITEINSTANCE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));
	cJSON_AddNumberToObject(root,"UpgradeFlag", (double)(data.byUpgradeFlag));

	return root;
}

INT32 DT_ELITEINSTANCE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byUpgradeFlag);
	memcpy(pDataBuff + dwOffset, &byUpgradeFlag, sizeof(byUpgradeFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ELITEINSTANCE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byUpgradeFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byUpgradeFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUpgradeFlag, 0, sizeof(byUpgradeFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_UPGRADSCIENCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADSCIENCE_TASK_CONDITION *pstIn = (DT_UPGRADSCIENCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_UPGRADSCIENCE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADSCIENCE_TASK_CONDITION *pstOut = (DT_UPGRADSCIENCE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_UPGRADSCIENCE_TASK_CONDITION(DT_UPGRADSCIENCE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_UPGRADSCIENCE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_UPGRADSCIENCE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_STRENGTHATTACK_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHATTACK_TASK_CONDITION *pstIn = (DT_STRENGTHATTACK_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_STRENGTHATTACK_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHATTACK_TASK_CONDITION *pstOut = (DT_STRENGTHATTACK_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_STRENGTHATTACK_TASK_CONDITION(DT_STRENGTHATTACK_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_STRENGTHATTACK_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_STRENGTHATTACK_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_STRENGTHLIFE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHLIFE_TASK_CONDITION *pstIn = (DT_STRENGTHLIFE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_STRENGTHLIFE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STRENGTHLIFE_TASK_CONDITION *pstOut = (DT_STRENGTHLIFE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_STRENGTHLIFE_TASK_CONDITION(DT_STRENGTHLIFE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_STRENGTHLIFE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_STRENGTHLIFE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CROP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROP_TASK_CONDITION *pstIn = (DT_CROP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CROP_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CROP_TASK_CONDITION *pstOut = (DT_CROP_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CROP_TASK_CONDITION(DT_CROP_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_CROP_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CROP_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_UPGRADESKILL_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADESKILL_TASK_CONDITION *pstIn = (DT_UPGRADESKILL_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSkillActionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_UPGRADESKILL_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADESKILL_TASK_CONDITION *pstOut = (DT_UPGRADESKILL_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSkillActionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_UPGRADESKILL_TASK_CONDITION(DT_UPGRADESKILL_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SkillActionID", (double)(data.wSkillActionID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));

	return root;
}

INT32 DT_UPGRADESKILL_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSkillActionID);
	memcpy(pDataBuff + dwOffset, &wSkillActionID, sizeof(wSkillActionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_UPGRADESKILL_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSkillActionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSkillActionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSkillActionID, 0, sizeof(wSkillActionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_UPGRADEJINGJIE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEJINGJIE_TASK_CONDITION *pstIn = (DT_UPGRADEJINGJIE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSubLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_UPGRADEJINGJIE_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_UPGRADEJINGJIE_TASK_CONDITION *pstOut = (DT_UPGRADEJINGJIE_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSubLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_UPGRADEJINGJIE_TASK_CONDITION(DT_UPGRADEJINGJIE_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"SubLevel", (double)(data.wSubLevel));

	return root;
}

INT32 DT_UPGRADEJINGJIE_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wSubLevel);
	memcpy(pDataBuff + dwOffset, &wSubLevel, sizeof(wSubLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_UPGRADEJINGJIE_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wSubLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wSubLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSubLevel, 0, sizeof(wSubLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MOSAICGEM_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_MOSAICGEM_TASK_CONDITION *pstIn = (DT_MOSAICGEM_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MOSAICGEM_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_MOSAICGEM_TASK_CONDITION *pstOut = (DT_MOSAICGEM_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MOSAICGEM_TASK_CONDITION(DT_MOSAICGEM_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_MOSAICGEM_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MOSAICGEM_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CLIMBTOWER_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CLIMBTOWER_TASK_CONDITION *pstIn = (DT_CLIMBTOWER_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CLIMBTOWER_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_CLIMBTOWER_TASK_CONDITION *pstOut = (DT_CLIMBTOWER_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CLIMBTOWER_TASK_CONDITION(DT_CLIMBTOWER_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_CLIMBTOWER_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CLIMBTOWER_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_STUDY_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STUDY_TASK_CONDITION *pstIn = (DT_STUDY_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_STUDY_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_STUDY_TASK_CONDITION *pstOut = (DT_STUDY_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_STUDY_TASK_CONDITION(DT_STUDY_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Level", (double)(data.byLevel));

	return root;
}

INT32 DT_STUDY_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLevel);
	memcpy(pDataBuff + dwOffset, &byLevel, sizeof(byLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_STUDY_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLevel, 0, sizeof(byLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RECRUITHERO_NUM_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_RECRUITHERO_NUM_TASK_CONDITION *pstIn = (DT_RECRUITHERO_NUM_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RECRUITHERO_NUM_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_RECRUITHERO_NUM_TASK_CONDITION *pstOut = (DT_RECRUITHERO_NUM_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RECRUITHERO_NUM_TASK_CONDITION(DT_RECRUITHERO_NUM_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));

	return root;
}

INT32 DT_RECRUITHERO_NUM_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RECRUITHERO_NUM_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_OPENLIGHT_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_OPENLIGHT_TASK_CONDITION *pstIn = (DT_OPENLIGHT_TASK_CONDITION*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byExt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_OPENLIGHT_TASK_CONDITION(void *pHost, CNetData* poNetData)
{
	DT_OPENLIGHT_TASK_CONDITION *pstOut = (DT_OPENLIGHT_TASK_CONDITION*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byExt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_OPENLIGHT_TASK_CONDITION(DT_OPENLIGHT_TASK_CONDITION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Ext", (double)(data.byExt));

	return root;
}

INT32 DT_OPENLIGHT_TASK_CONDITION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byExt);
	memcpy(pDataBuff + dwOffset, &byExt, sizeof(byExt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_OPENLIGHT_TASK_CONDITION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byExt) >= pstIndex->dwContextLen)
				{
					memcpy(&byExt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byExt, 0, sizeof(byExt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeUnDT_TASK_CONDITION(void *pHost, INT32 iSelect, CNetData* poNetData)
{
	switch(iSelect){
	case CROWN:
		return EncodeDT_CROWN_TASK_CONDITION(pHost, poNetData);
	case RECRUITHERO:
		return EncodeDT_RECRUITHERO_TASK_CONDITION(pHost, poNetData);
	case UPGRADESKILL:
		return EncodeDT_UPGRADESKILL_TASK_CONDITION(pHost, poNetData);
	case UPGRADEJINGJIE:
		return EncodeDT_UPGRADEJINGJIE_TASK_CONDITION(pHost, poNetData);
	case FIRSTPASSINSTANCE:
		return EncodeDT_FIRSTPASSINSTANCE_TASK_CONDITION(pHost, poNetData);
	case SCOREPASSINSTANCE:
		return EncodeDT_SCOREPASSINSTANCE_TASK_CONDITION(pHost, poNetData);
	case TIMESPASSINSTANCE:
		return EncodeDT_TIMESPASSINSTANCE_TASK_CONDITION(pHost, poNetData);
	case KILLMONSTERINSTANCE:
		return EncodeDT_KILLMONSTERINSTANCE_TASK_CONDITION(pHost, poNetData);
	case STRENGTHENEQUIPLEVEL:
		return EncodeDT_STRENGTHENEQUIPLEVEL_TASK_CONDITION(pHost, poNetData);
	case STRENGTHENEQUIPNUM:
		return EncodeDT_STRENGTHENEQUIPNUM_TASK_CONDITION(pHost, poNetData);
	case MOSAICGEM:
		return EncodeDT_MOSAICGEM_TASK_CONDITION(pHost, poNetData);
	case ACTIVATEGODWEAPON:
		return EncodeDT_ACTIVATEGODWEAPON_TASK_CONDITION(pHost, poNetData);
	case UPGRADEGODWEAPON:
		return EncodeDT_UPGRADEGODWEAPON_TASK_CONDITION(pHost, poNetData);
	case CHALLENGE:
		return EncodeDT_CHALLENGE_TASK_CONDITION(pHost, poNetData);
	case PLUNDER:
		return EncodeDT_PLUNDER_TASK_CONDITION(pHost, poNetData);
	case CLIMBTOWER:
		return EncodeDT_CLIMBTOWER_TASK_CONDITION(pHost, poNetData);
	case DRESSEQUIP:
		return EncodeDT_DRESSEQUIP_TASK_CONDITION(pHost, poNetData);
	case USEEXPRIENCEDRUG:
		return EncodeDT_USEEXPRIENCEDRUG_TASK_CONDITION(pHost, poNetData);
	case COMPOSEGOOD:
		return EncodeDT_COMPOSEGOOD_TASK_CONDITION(pHost, poNetData);
	case ELITEINSTANCE:
		return EncodeDT_ELITEINSTANCE_TASK_CONDITION(pHost, poNetData);
	case UPGRADSCIENCE:
		return EncodeDT_UPGRADSCIENCE_TASK_CONDITION(pHost, poNetData);
	case STRENGTHATTACK:
		return EncodeDT_STRENGTHATTACK_TASK_CONDITION(pHost, poNetData);
	case STRENGTHLIFE:
		return EncodeDT_STRENGTHLIFE_TASK_CONDITION(pHost, poNetData);
	case CROP:
		return EncodeDT_CROP_TASK_CONDITION(pHost, poNetData);
	case MELTEQUIP:
		return EncodeDT_MELT_EQUIP_TASK_CONDITION(pHost, poNetData);
	case STUDY:
		return EncodeDT_STUDY_TASK_CONDITION(pHost, poNetData);
	case RECRUITHERONUM:
		return EncodeDT_RECRUITHERO_NUM_TASK_CONDITION(pHost, poNetData);
	case OPENLIGHT:
		return EncodeDT_OPENLIGHT_TASK_CONDITION(pHost, poNetData);
	default: return -1;
	}
}

INT32 DecodeUnDT_TASK_CONDITION(void *pHost, INT32 iSelect, CNetData* poNetData)
{
	switch(iSelect){
	case CROWN:
		return DecodeDT_CROWN_TASK_CONDITION(pHost, poNetData);
	case RECRUITHERO:
		return DecodeDT_RECRUITHERO_TASK_CONDITION(pHost, poNetData);
	case UPGRADESKILL:
		return DecodeDT_UPGRADESKILL_TASK_CONDITION(pHost, poNetData);
	case UPGRADEJINGJIE:
		return DecodeDT_UPGRADEJINGJIE_TASK_CONDITION(pHost, poNetData);
	case FIRSTPASSINSTANCE:
		return DecodeDT_FIRSTPASSINSTANCE_TASK_CONDITION(pHost, poNetData);
	case SCOREPASSINSTANCE:
		return DecodeDT_SCOREPASSINSTANCE_TASK_CONDITION(pHost, poNetData);
	case TIMESPASSINSTANCE:
		return DecodeDT_TIMESPASSINSTANCE_TASK_CONDITION(pHost, poNetData);
	case KILLMONSTERINSTANCE:
		return DecodeDT_KILLMONSTERINSTANCE_TASK_CONDITION(pHost, poNetData);
	case STRENGTHENEQUIPLEVEL:
		return DecodeDT_STRENGTHENEQUIPLEVEL_TASK_CONDITION(pHost, poNetData);
	case STRENGTHENEQUIPNUM:
		return DecodeDT_STRENGTHENEQUIPNUM_TASK_CONDITION(pHost, poNetData);
	case MOSAICGEM:
		return DecodeDT_MOSAICGEM_TASK_CONDITION(pHost, poNetData);
	case ACTIVATEGODWEAPON:
		return DecodeDT_ACTIVATEGODWEAPON_TASK_CONDITION(pHost, poNetData);
	case UPGRADEGODWEAPON:
		return DecodeDT_UPGRADEGODWEAPON_TASK_CONDITION(pHost, poNetData);
	case CHALLENGE:
		return DecodeDT_CHALLENGE_TASK_CONDITION(pHost, poNetData);
	case PLUNDER:
		return DecodeDT_PLUNDER_TASK_CONDITION(pHost, poNetData);
	case CLIMBTOWER:
		return DecodeDT_CLIMBTOWER_TASK_CONDITION(pHost, poNetData);
	case DRESSEQUIP:
		return DecodeDT_DRESSEQUIP_TASK_CONDITION(pHost, poNetData);
	case USEEXPRIENCEDRUG:
		return DecodeDT_USEEXPRIENCEDRUG_TASK_CONDITION(pHost, poNetData);
	case COMPOSEGOOD:
		return DecodeDT_COMPOSEGOOD_TASK_CONDITION(pHost, poNetData);
	case ELITEINSTANCE:
		return DecodeDT_ELITEINSTANCE_TASK_CONDITION(pHost, poNetData);
	case UPGRADSCIENCE:
		return DecodeDT_UPGRADSCIENCE_TASK_CONDITION(pHost, poNetData);
	case STRENGTHATTACK:
		return DecodeDT_STRENGTHATTACK_TASK_CONDITION(pHost, poNetData);
	case STRENGTHLIFE:
		return DecodeDT_STRENGTHLIFE_TASK_CONDITION(pHost, poNetData);
	case CROP:
		return DecodeDT_CROP_TASK_CONDITION(pHost, poNetData);
	case MELTEQUIP:
		return DecodeDT_MELT_EQUIP_TASK_CONDITION(pHost, poNetData);
	case STUDY:
		return DecodeDT_STUDY_TASK_CONDITION(pHost, poNetData);
	case RECRUITHERONUM:
		return DecodeDT_RECRUITHERO_NUM_TASK_CONDITION(pHost, poNetData);
	case OPENLIGHT:
		return DecodeDT_OPENLIGHT_TASK_CONDITION(pHost, poNetData);
	default: return -1;
	}
}


INT32 DT_TASK_CONDITION::EncodeSaveData(const UINT8 bySelectType, CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	INT32 nEncodeRet = -1;
	switch(bySelectType)
	{
	case CROWN:
		{
			nEncodeRet = stCrown.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case RECRUITHERO:
		{
			nEncodeRet = stRecruitHero.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADESKILL:
		{
			nEncodeRet = stUpgradeSkill.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADEJINGJIE:
		{
			nEncodeRet = stUpgradeJingJie.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case FIRSTPASSINSTANCE:
		{
			nEncodeRet = stFirstPassInstance.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case SCOREPASSINSTANCE:
		{
			nEncodeRet = stScorePassInstance.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case TIMESPASSINSTANCE:
		{
			nEncodeRet = stTimesPassInstance.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case KILLMONSTERINSTANCE:
		{
			nEncodeRet = stKillMonstersInstance.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHENEQUIPLEVEL:
		{
			nEncodeRet = stStrengthenEquipLevel.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHENEQUIPNUM:
		{
			nEncodeRet = stStrengthenEquipNum.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case MOSAICGEM:
		{
			nEncodeRet = stMosaicGem.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case ACTIVATEGODWEAPON:
		{
			nEncodeRet = stActivateGodweapon.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADEGODWEAPON:
		{
			nEncodeRet = stUpgradeGodweapon.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case CHALLENGE:
		{
			nEncodeRet = stChallenge.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case PLUNDER:
		{
			nEncodeRet = stPlunder.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case CLIMBTOWER:
		{
			nEncodeRet = stClimbTower.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case DRESSEQUIP:
		{
			nEncodeRet = stDressEquip.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case USEEXPRIENCEDRUG:
		{
			nEncodeRet = stUseExprienceDrug.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case COMPOSEGOOD:
		{
			nEncodeRet = stComposeGood.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case ELITEINSTANCE:
		{
			nEncodeRet = stEliteInstance.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADSCIENCE:
		{
			nEncodeRet = stUpgradeScience.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHATTACK:
		{
			nEncodeRet = stStrengthAttack.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHLIFE:
		{
			nEncodeRet = stStrengthLife.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case CROP:
		{
			nEncodeRet = stCrop.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case MELTEQUIP:
		{
			nEncodeRet = stMeltEquip.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STUDY:
		{
			nEncodeRet = stStudy.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case RECRUITHERONUM:
		{
			nEncodeRet = stRecruitHeroNum.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case OPENLIGHT:
		{
			nEncodeRet = stOpenLight.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	default:
		break;
	}

	return nEncodeRet;
}


INT32 DT_TASK_CONDITION::DecodeSaveData(const UINT8 bySelectType, const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	INT32 nEncodeRet = -1;
	switch(bySelectType)
	{
	case CROWN:
		{
			nEncodeRet = stCrown.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case RECRUITHERO:
		{
			nEncodeRet = stRecruitHero.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADESKILL:
		{
			nEncodeRet = stUpgradeSkill.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADEJINGJIE:
		{
			nEncodeRet = stUpgradeJingJie.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case FIRSTPASSINSTANCE:
		{
			nEncodeRet = stFirstPassInstance.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case SCOREPASSINSTANCE:
		{
			nEncodeRet = stScorePassInstance.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case TIMESPASSINSTANCE:
		{
			nEncodeRet = stTimesPassInstance.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case KILLMONSTERINSTANCE:
		{
			nEncodeRet = stKillMonstersInstance.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHENEQUIPLEVEL:
		{
			nEncodeRet = stStrengthenEquipLevel.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHENEQUIPNUM:
		{
			nEncodeRet = stStrengthenEquipNum.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case MOSAICGEM:
		{
			nEncodeRet = stMosaicGem.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case ACTIVATEGODWEAPON:
		{
			nEncodeRet = stActivateGodweapon.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADEGODWEAPON:
		{
			nEncodeRet = stUpgradeGodweapon.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case CHALLENGE:
		{
			nEncodeRet = stChallenge.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case PLUNDER:
		{
			nEncodeRet = stPlunder.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case CLIMBTOWER:
		{
			nEncodeRet = stClimbTower.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case DRESSEQUIP:
		{
			nEncodeRet = stDressEquip.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case USEEXPRIENCEDRUG:
		{
			nEncodeRet = stUseExprienceDrug.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case COMPOSEGOOD:
		{
			nEncodeRet = stComposeGood.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case ELITEINSTANCE:
		{
			nEncodeRet = stEliteInstance.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case UPGRADSCIENCE:
		{
			nEncodeRet = stUpgradeScience.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHATTACK:
		{
			nEncodeRet = stStrengthAttack.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STRENGTHLIFE:
		{
			nEncodeRet = stStrengthLife.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case CROP:
		{
			nEncodeRet = stCrop.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case MELTEQUIP:
		{
			nEncodeRet = stMeltEquip.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case STUDY:
		{
			nEncodeRet = stStudy.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case RECRUITHERONUM:
		{
			nEncodeRet = stRecruitHeroNum.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case OPENLIGHT:
		{
			nEncodeRet = stOpenLight.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	default:
		break;
	}

	return nEncodeRet;
}

INT32 EncodeDT_TASK_DATA(void *pHost, CNetData* poNetData)
{
	DT_TASK_DATA *pstIn = (DT_TASK_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byTaskLine))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTaskIdx))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStateUpdateTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTaskState))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTaskType))
		return -1;

	if(-1 == EncodeUnDT_TASK_CONDITION(&pstIn->stTaskConditionInfo, pstIn->byTaskType, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_TASK_DATA(void *pHost, CNetData* poNetData)
{
	DT_TASK_DATA *pstOut = (DT_TASK_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byTaskLine))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTaskIdx))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStateUpdateTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTaskState))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTaskType))
		return -1;

	if(-1 == DecodeUnDT_TASK_CONDITION(&pstOut->stTaskConditionInfo, pstOut->byTaskType, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_TASK_DATA(DT_TASK_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"TaskLine", (double)(data.byTaskLine));
	cJSON_AddNumberToObject(root,"TaskIdx", (double)(data.dwTaskIdx));
	cJSON_AddNumberToObject(root,"StateUpdateTime", (double)(data.qwStateUpdateTime));
	cJSON_AddNumberToObject(root,"TaskState", (double)(data.byTaskState));
	cJSON_AddNumberToObject(root,"TaskType", (double)(data.byTaskType));

	return root;
}

INT32 DT_TASK_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byTaskLine);
	memcpy(pDataBuff + dwOffset, &byTaskLine, sizeof(byTaskLine));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwTaskIdx);
	memcpy(pDataBuff + dwOffset, &dwTaskIdx, sizeof(dwTaskIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwStateUpdateTime);
	memcpy(pDataBuff + dwOffset, &qwStateUpdateTime, sizeof(qwStateUpdateTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byTaskState);
	memcpy(pDataBuff + dwOffset, &byTaskState, sizeof(byTaskState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byTaskType);
	memcpy(pDataBuff + dwOffset, &byTaskType, sizeof(byTaskType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(stTaskConditionInfo);
	memcpy(pDataBuff + dwOffset, &stTaskConditionInfo, sizeof(stTaskConditionInfo));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_TASK_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byTaskLine) >= pstIndex->dwContextLen)
				{
					memcpy(&byTaskLine, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTaskLine, 0, sizeof(byTaskLine));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwTaskIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTaskIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTaskIdx, 0, sizeof(dwTaskIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwStateUpdateTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStateUpdateTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStateUpdateTime, 0, sizeof(qwStateUpdateTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byTaskState) >= pstIndex->dwContextLen)
				{
					memcpy(&byTaskState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTaskState, 0, sizeof(byTaskState));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byTaskType) >= pstIndex->dwContextLen)
				{
					memcpy(&byTaskType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTaskType, 0, sizeof(byTaskType));
				}
			}
			break;
		case 6:
			{
				if(sizeof(stTaskConditionInfo) >= pstIndex->dwContextLen)
				{
					memcpy(&stTaskConditionInfo, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&stTaskConditionInfo, 0, sizeof(stTaskConditionInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_TASK_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_TASK_DATA_LIST *pstIn = (DT_TASK_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byTaskNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_TASK_LINE_NUM; i++)
	{
		if(i >= (INT32)pstIn->byTaskNum)
			break;
		if(-1 == EncodeDT_TASK_DATA(&pstIn->astTaskInfoList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_TASK_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_TASK_DATA_LIST *pstOut = (DT_TASK_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byTaskNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_TASK_LINE_NUM; i++)
	{
		if(i >= (INT32)pstOut->byTaskNum)
			break;
		if(-1 == DecodeDT_TASK_DATA(&pstOut->astTaskInfoList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_TASK_DATA_LIST(DT_TASK_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"TaskNum", (double)(data.byTaskNum));
	cJSON *TaskInfoList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "TaskInfoList", TaskInfoList);
	for( UINT32 dwIndex=0; dwIndex<data.byTaskNum; ++dwIndex)
	{
		cJSON_AddItemToObject(TaskInfoList, " ", GetJsonDT_TASK_DATA(data.astTaskInfoList[dwIndex]));
	}

	return root;
}

INT32 DT_TASK_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byTaskNum);
	memcpy(pDataBuff + dwOffset, &byTaskNum, sizeof(byTaskNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byTaskNum > MAX_TASK_LINE_NUM)
	{
		byTaskNum = MAX_TASK_LINE_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byTaskNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byTaskNum; i++)
	{
		dwContextLenTmp += astTaskInfoList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_TASK_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byTaskNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byTaskNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTaskNum, 0, sizeof(byTaskNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byTaskNum)
				{
					wArrNum = wArrNum <= MAX_TASK_LINE_NUM ? wArrNum : MAX_TASK_LINE_NUM;
					byTaskNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astTaskInfoList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astTaskInfoList, 0, sizeof(astTaskInfoList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astTaskInfoList, 0, sizeof(astTaskInfoList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RACE_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_RACE_BASE_DATA *pstIn = (DT_RACE_BASE_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwRank))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wContiWin))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwRecvEncourageTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastChallTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byChallTimes))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFailedFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUnreadBattleLogNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRecvEncourageRank))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwNotifyRankTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwNotifyRank))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RACE_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_RACE_BASE_DATA *pstOut = (DT_RACE_BASE_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwRank))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wContiWin))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwRecvEncourageTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastChallTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byChallTimes))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFailedFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUnreadBattleLogNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRecvEncourageRank))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwNotifyRankTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwNotifyRank))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RACE_BASE_DATA(DT_RACE_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Rank", (double)(data.dwRank));
	cJSON_AddNumberToObject(root,"ContiWin", (double)(data.wContiWin));
	cJSON_AddNumberToObject(root,"RecvEncourageTime", (double)(data.qwRecvEncourageTime));
	cJSON_AddNumberToObject(root,"LastChallTime", (double)(data.qwLastChallTime));
	cJSON_AddNumberToObject(root,"ChallTimes", (double)(data.byChallTimes));
	cJSON_AddNumberToObject(root,"FailedFlag", (double)(data.byFailedFlag));
	cJSON_AddNumberToObject(root,"UnreadBattleLogNum", (double)(data.byUnreadBattleLogNum));
	cJSON_AddNumberToObject(root,"RecvEncourageRank", (double)(data.dwRecvEncourageRank));
	cJSON_AddNumberToObject(root,"NotifyRankTime", (double)(data.qwNotifyRankTime));
	cJSON_AddNumberToObject(root,"NotifyRank", (double)(data.dwNotifyRank));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_RACE_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 11;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwRank);
	memcpy(pDataBuff + dwOffset, &dwRank, sizeof(dwRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wContiWin);
	memcpy(pDataBuff + dwOffset, &wContiWin, sizeof(wContiWin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwRecvEncourageTime);
	memcpy(pDataBuff + dwOffset, &qwRecvEncourageTime, sizeof(qwRecvEncourageTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwLastChallTime);
	memcpy(pDataBuff + dwOffset, &qwLastChallTime, sizeof(qwLastChallTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byChallTimes);
	memcpy(pDataBuff + dwOffset, &byChallTimes, sizeof(byChallTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byFailedFlag);
	memcpy(pDataBuff + dwOffset, &byFailedFlag, sizeof(byFailedFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byUnreadBattleLogNum);
	memcpy(pDataBuff + dwOffset, &byUnreadBattleLogNum, sizeof(byUnreadBattleLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwRecvEncourageRank);
	memcpy(pDataBuff + dwOffset, &dwRecvEncourageRank, sizeof(dwRecvEncourageRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwNotifyRankTime);
	memcpy(pDataBuff + dwOffset, &qwNotifyRankTime, sizeof(qwNotifyRankTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(dwNotifyRank);
	memcpy(pDataBuff + dwOffset, &dwNotifyRank, sizeof(dwNotifyRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RACE_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRank, 0, sizeof(dwRank));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wContiWin) >= pstIndex->dwContextLen)
				{
					memcpy(&wContiWin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wContiWin, 0, sizeof(wContiWin));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwRecvEncourageTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwRecvEncourageTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwRecvEncourageTime, 0, sizeof(qwRecvEncourageTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwLastChallTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastChallTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastChallTime, 0, sizeof(qwLastChallTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byChallTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byChallTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChallTimes, 0, sizeof(byChallTimes));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byFailedFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byFailedFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFailedFlag, 0, sizeof(byFailedFlag));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byUnreadBattleLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byUnreadBattleLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUnreadBattleLogNum, 0, sizeof(byUnreadBattleLogNum));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwRecvEncourageRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRecvEncourageRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRecvEncourageRank, 0, sizeof(dwRecvEncourageRank));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwNotifyRankTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwNotifyRankTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwNotifyRankTime, 0, sizeof(qwNotifyRankTime));
				}
			}
			break;
		case 10:
			{
				if(sizeof(dwNotifyRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwNotifyRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwNotifyRank, 0, sizeof(dwNotifyRank));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LOCALE_HOME(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_HOME *pstIn = (DT_LOCALE_HOME*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byExt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOCALE_HOME(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_HOME *pstOut = (DT_LOCALE_HOME*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byExt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOCALE_HOME(DT_LOCALE_HOME &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Ext", (double)(data.byExt));

	return root;
}

INT32 DT_LOCALE_HOME::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byExt);
	memcpy(pDataBuff + dwOffset, &byExt, sizeof(byExt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOCALE_HOME::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byExt) >= pstIndex->dwContextLen)
				{
					memcpy(&byExt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byExt, 0, sizeof(byExt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LOCALE_INSTANCE(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_INSTANCE *pstIn = (DT_LOCALE_INSTANCE*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySuccessFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOCALE_INSTANCE(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_INSTANCE *pstOut = (DT_LOCALE_INSTANCE*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySuccessFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOCALE_INSTANCE(DT_LOCALE_INSTANCE &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));
	cJSON_AddNumberToObject(root,"BattleIdx", (double)(data.byBattleIdx));
	cJSON_AddNumberToObject(root,"SuccessFlag", (double)(data.bySuccessFlag));

	return root;
}

INT32 DT_LOCALE_INSTANCE::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byBattleIdx);
	memcpy(pDataBuff + dwOffset, &byBattleIdx, sizeof(byBattleIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(bySuccessFlag);
	memcpy(pDataBuff + dwOffset, &bySuccessFlag, sizeof(bySuccessFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOCALE_INSTANCE::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byBattleIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleIdx, 0, sizeof(byBattleIdx));
				}
			}
			break;
		case 5:
			{
				if(sizeof(bySuccessFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&bySuccessFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySuccessFlag, 0, sizeof(bySuccessFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LOCALE_ONHOOK(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_ONHOOK *pstIn = (DT_LOCALE_ONHOOK*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTownIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byInstanceIdx))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOCALE_ONHOOK(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_ONHOOK *pstOut = (DT_LOCALE_ONHOOK*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTownIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byInstanceIdx))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOCALE_ONHOOK(DT_LOCALE_ONHOOK &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SceneIdx", (double)(data.wSceneIdx));
	cJSON_AddNumberToObject(root,"TownIdx", (double)(data.byTownIdx));
	cJSON_AddNumberToObject(root,"InstanceIdx", (double)(data.byInstanceIdx));

	return root;
}

INT32 DT_LOCALE_ONHOOK::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneIdx);
	memcpy(pDataBuff + dwOffset, &wSceneIdx, sizeof(wSceneIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byTownIdx);
	memcpy(pDataBuff + dwOffset, &byTownIdx, sizeof(byTownIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byInstanceIdx);
	memcpy(pDataBuff + dwOffset, &byInstanceIdx, sizeof(byInstanceIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOCALE_ONHOOK::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneIdx, 0, sizeof(wSceneIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byTownIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byTownIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTownIdx, 0, sizeof(byTownIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byInstanceIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byInstanceIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byInstanceIdx, 0, sizeof(byInstanceIdx));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LOCALE_MARK(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_MARK *pstIn = (DT_LOCALE_MARK*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byExt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOCALE_MARK(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_MARK *pstOut = (DT_LOCALE_MARK*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byExt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOCALE_MARK(DT_LOCALE_MARK &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Ext", (double)(data.byExt));

	return root;
}

INT32 DT_LOCALE_MARK::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byExt);
	memcpy(pDataBuff + dwOffset, &byExt, sizeof(byExt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOCALE_MARK::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byExt) >= pstIndex->dwContextLen)
				{
					memcpy(&byExt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byExt, 0, sizeof(byExt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeUnDT_LOCALE_DATA_UNION(void *pHost, INT32 iSelect, CNetData* poNetData)
{
	switch(iSelect){
	case EPL_HOME:
		return EncodeDT_LOCALE_HOME(pHost, poNetData);
	case EPL_INSTANCE:
		return EncodeDT_LOCALE_INSTANCE(pHost, poNetData);
	case EPL_ONHOOK:
		return EncodeDT_LOCALE_ONHOOK(pHost, poNetData);
	case EPL_EATBREAD:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_BOSSB:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_HOT_SPRING:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_COURAGE:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_FACTION:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_COURAGE_BATTLE:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_SOUL:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_PET:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_NEIDAN:
		return EncodeDT_LOCALE_MARK(pHost, poNetData);
	default: return -1;
	}
}

INT32 DecodeUnDT_LOCALE_DATA_UNION(void *pHost, INT32 iSelect, CNetData* poNetData)
{
	switch(iSelect){
	case EPL_HOME:
		return DecodeDT_LOCALE_HOME(pHost, poNetData);
	case EPL_INSTANCE:
		return DecodeDT_LOCALE_INSTANCE(pHost, poNetData);
	case EPL_ONHOOK:
		return DecodeDT_LOCALE_ONHOOK(pHost, poNetData);
	case EPL_EATBREAD:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_BOSSB:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_HOT_SPRING:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_COURAGE:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_FACTION:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_COURAGE_BATTLE:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_SOUL:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_PET:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	case EPL_NEIDAN:
		return DecodeDT_LOCALE_MARK(pHost, poNetData);
	default: return -1;
	}
}


INT32 DT_LOCALE_DATA_UNION::EncodeSaveData(const UINT8 bySelectType, CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	INT32 nEncodeRet = -1;
	switch(bySelectType)
	{
	case EPL_HOME:
		{
			nEncodeRet = stHome.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_INSTANCE:
		{
			nEncodeRet = stInstance.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_ONHOOK:
		{
			nEncodeRet = stOnhook.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_EATBREAD:
		{
			nEncodeRet = stEatBread.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_BOSSB:
		{
			nEncodeRet = stBossB.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_HOT_SPRING:
		{
			nEncodeRet = stHotSpring.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_COURAGE:
		{
			nEncodeRet = stCourage.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_FACTION:
		{
			nEncodeRet = stFaction.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_COURAGE_BATTLE:
		{
			nEncodeRet = stCourageBattle.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_SOUL:
		{
			nEncodeRet = stSoul.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_PET:
		{
			nEncodeRet = stPet.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_NEIDAN:
		{
			nEncodeRet = stNeiDan.EncodeSaveData(pBuff, dwBuffLen);
		}
		break;
	default:
		break;
	}

	return nEncodeRet;
}


INT32 DT_LOCALE_DATA_UNION::DecodeSaveData(const UINT8 bySelectType, const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	INT32 nEncodeRet = -1;
	switch(bySelectType)
	{
	case EPL_HOME:
		{
			nEncodeRet = stHome.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_INSTANCE:
		{
			nEncodeRet = stInstance.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_ONHOOK:
		{
			nEncodeRet = stOnhook.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_EATBREAD:
		{
			nEncodeRet = stEatBread.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_BOSSB:
		{
			nEncodeRet = stBossB.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_HOT_SPRING:
		{
			nEncodeRet = stHotSpring.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_COURAGE:
		{
			nEncodeRet = stCourage.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_FACTION:
		{
			nEncodeRet = stFaction.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_COURAGE_BATTLE:
		{
			nEncodeRet = stCourageBattle.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_SOUL:
		{
			nEncodeRet = stSoul.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_PET:
		{
			nEncodeRet = stPet.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	case EPL_NEIDAN:
		{
			nEncodeRet = stNeiDan.DecodeSaveData(pBuff, dwBuffLen);
		}
		break;
	default:
		break;
	}

	return nEncodeRet;
}

INT32 EncodeDT_LOCALE_DATA(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_DATA *pstIn = (DT_LOCALE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLocaleType))
		return -1;

	if(-1 == EncodeUnDT_LOCALE_DATA_UNION(&pstIn->stLocaleInfo, pstIn->byLocaleType, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOCALE_DATA(void *pHost, CNetData* poNetData)
{
	DT_LOCALE_DATA *pstOut = (DT_LOCALE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLocaleType))
		return -1;

	if(-1 == DecodeUnDT_LOCALE_DATA_UNION(&pstOut->stLocaleInfo, pstOut->byLocaleType, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOCALE_DATA(DT_LOCALE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LocaleType", (double)(data.byLocaleType));

	return root;
}

INT32 DT_LOCALE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLocaleType);
	memcpy(pDataBuff + dwOffset, &byLocaleType, sizeof(byLocaleType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(stLocaleInfo);
	memcpy(pDataBuff + dwOffset, &stLocaleInfo, sizeof(stLocaleInfo));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOCALE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLocaleType) >= pstIndex->dwContextLen)
				{
					memcpy(&byLocaleType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLocaleType, 0, sizeof(byLocaleType));
				}
			}
			break;
		case 2:
			{
				if(sizeof(stLocaleInfo) >= pstIndex->dwContextLen)
				{
					memcpy(&stLocaleInfo, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&stLocaleInfo, 0, sizeof(stLocaleInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeUnlockScienceInfo(void *pHost, CNetData* poNetData)
{
	UnlockScienceInfo *pstIn = (UnlockScienceInfo*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byUnlockNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstIn->byUnlockNum)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyUnlockScienceID[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeUnlockScienceInfo(void *pHost, CNetData* poNetData)
{
	UnlockScienceInfo *pstOut = (UnlockScienceInfo*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byUnlockNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SCIENCE_ATTR_NUM; i++)
	{
		if(i >= (INT32)pstOut->byUnlockNum)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyUnlockScienceID[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonUnlockScienceInfo(UnlockScienceInfo &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"UnlockNum", (double)(data.byUnlockNum));
	cJSON *UnlockScienceID = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "UnlockScienceID", UnlockScienceID);
	for( UINT32 dwIndex=0; dwIndex<data.byUnlockNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"UnlockScienceID", (double)(data.abyUnlockScienceID[dwIndex]));
	}

	return root;
}

INT32 UnlockScienceInfo::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byUnlockNum);
	memcpy(pDataBuff + dwOffset, &byUnlockNum, sizeof(byUnlockNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(byUnlockNum > MAX_SCIENCE_ATTR_NUM)
	{
		byUnlockNum = MAX_SCIENCE_ATTR_NUM;
	}
	pstIndex->dwContextLen = byUnlockNum * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byUnlockNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyUnlockScienceID, byUnlockNum * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 UnlockScienceInfo::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byUnlockNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byUnlockNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUnlockNum, 0, sizeof(byUnlockNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyUnlockScienceID) >= dwContextLen) && (wArrNum == byUnlockNum) && (wArrNum <= MAX_SCIENCE_ATTR_NUM))
				{
					memcpy(&abyUnlockScienceID, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyUnlockScienceID, 0, sizeof(abyUnlockScienceID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_UPGRADE_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_UPGRADE_DATA *pstIn = (DT_HERO_UPGRADE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUpgradeFlag))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEncExperience))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwExperience))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwUpgradeExperience))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCanUseBoxGoodsID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_UPGRADE_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_UPGRADE_DATA *pstOut = (DT_HERO_UPGRADE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUpgradeFlag))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEncExperience))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwExperience))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwUpgradeExperience))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCanUseBoxGoodsID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_UPGRADE_DATA(DT_HERO_UPGRADE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));
	cJSON_AddNumberToObject(root,"UpgradeFlag", (double)(data.byUpgradeFlag));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"EncExperience", (double)(data.dwEncExperience));
	cJSON_AddNumberToObject(root,"Experience", (double)(data.dwExperience));
	cJSON_AddNumberToObject(root,"UpgradeExperience", (double)(data.dwUpgradeExperience));
	cJSON_AddNumberToObject(root,"CanUseBoxGoodsID", (double)(data.wCanUseBoxGoodsID));

	return root;
}

INT32 DT_HERO_UPGRADE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byUpgradeFlag);
	memcpy(pDataBuff + dwOffset, &byUpgradeFlag, sizeof(byUpgradeFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwEncExperience);
	memcpy(pDataBuff + dwOffset, &dwEncExperience, sizeof(dwEncExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwExperience);
	memcpy(pDataBuff + dwOffset, &dwExperience, sizeof(dwExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwUpgradeExperience);
	memcpy(pDataBuff + dwOffset, &dwUpgradeExperience, sizeof(dwUpgradeExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wCanUseBoxGoodsID);
	memcpy(pDataBuff + dwOffset, &wCanUseBoxGoodsID, sizeof(wCanUseBoxGoodsID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_UPGRADE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byUpgradeFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byUpgradeFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUpgradeFlag, 0, sizeof(byUpgradeFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwEncExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEncExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEncExperience, 0, sizeof(dwEncExperience));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwExperience, 0, sizeof(dwExperience));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwUpgradeExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwUpgradeExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwUpgradeExperience, 0, sizeof(dwUpgradeExperience));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wCanUseBoxGoodsID) >= pstIndex->dwContextLen)
				{
					memcpy(&wCanUseBoxGoodsID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCanUseBoxGoodsID, 0, sizeof(wCanUseBoxGoodsID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_STATE_DATA(void *pHost, CNetData* poNetData)
{
	DT_STATE_DATA *pstIn = (DT_STATE_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwInstanceMAXHP))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwInstanceCurHP))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wDoubleExpNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byOpenBoxFlag))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ENCOURAGE_BOX_GROUP_NUM; i++)
	{
		if(-1 == poNetData->AddByte(pstIn->abyHitItemIdx[i]))
			return -1;
	}

	for(i = 0; i < MAX_UNLOCK_HERO_NUM; i++)
	{
		if(-1 == poNetData->AddWord(pstIn->awUnlockHeroID[i]))
			return -1;
	}

	if(-1 == poNetData->AddWord(pstIn->wUnlockSkillID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wUnlockEquipLevel))
		return -1;

	if(-1 == EncodeUnlockScienceInfo(&pstIn->stUnlockScienceList, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwRegisterDispNameTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwUnlockElite))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUpgradeHeroNum))
		return -1;

	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byUpgradeHeroNum)
			break;
		if(-1 == EncodeDT_HERO_UPGRADE_DATA(&pstIn->astHeroUpgradeInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_STATE_DATA(void *pHost, CNetData* poNetData)
{
	DT_STATE_DATA *pstOut = (DT_STATE_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwInstanceMAXHP))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwInstanceCurHP))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wDoubleExpNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byOpenBoxFlag))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ENCOURAGE_BOX_GROUP_NUM; i++)
	{
		if(-1 == poNetData->DelByte(pstOut->abyHitItemIdx[i]))
			return -1;
	}

	for(i = 0; i < MAX_UNLOCK_HERO_NUM; i++)
	{
		if(-1 == poNetData->DelWord(pstOut->awUnlockHeroID[i]))
			return -1;
	}

	if(-1 == poNetData->DelWord(pstOut->wUnlockSkillID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wUnlockEquipLevel))
		return -1;

	if(-1 == DecodeUnlockScienceInfo(&pstOut->stUnlockScienceList, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwRegisterDispNameTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwUnlockElite))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUpgradeHeroNum))
		return -1;

	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byUpgradeHeroNum)
			break;
		if(-1 == DecodeDT_HERO_UPGRADE_DATA(&pstOut->astHeroUpgradeInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_STATE_DATA(DT_STATE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"InstanceMAXHP", (double)(data.dwInstanceMAXHP));
	cJSON_AddNumberToObject(root,"InstanceCurHP", (double)(data.dwInstanceCurHP));
	cJSON_AddNumberToObject(root,"DoubleExpNum", (double)(data.wDoubleExpNum));
	cJSON_AddNumberToObject(root,"OpenBoxFlag", (double)(data.byOpenBoxFlag));
	cJSON *HitItemIdx = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HitItemIdx", HitItemIdx);
	for( UINT32 dwIndex=0; dwIndex<MAX_ENCOURAGE_BOX_GROUP_NUM; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"HitItemIdx", (double)(data.abyHitItemIdx[dwIndex]));
	}
	cJSON *UnlockHeroID = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "UnlockHeroID", UnlockHeroID);
	for( UINT32 dwIndex=0; dwIndex<MAX_UNLOCK_HERO_NUM; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"UnlockHeroID", (double)(data.awUnlockHeroID[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"UnlockSkillID", (double)(data.wUnlockSkillID));
	cJSON_AddNumberToObject(root,"UnlockEquipLevel", (double)(data.wUnlockEquipLevel));
	cJSON_AddItemToObject(root, "UnlockScienceList", GetJsonUnlockScienceInfo(data.stUnlockScienceList));
	cJSON_AddNumberToObject(root,"RegisterDispNameTime", (double)(data.qwRegisterDispNameTime));
	cJSON_AddNumberToObject(root,"UnlockElite", (double)(data.dwUnlockElite));
	cJSON_AddNumberToObject(root,"UpgradeHeroNum", (double)(data.byUpgradeHeroNum));
	cJSON *HeroUpgradeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HeroUpgradeInfo", HeroUpgradeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byUpgradeHeroNum; ++dwIndex)
	{
		cJSON_AddItemToObject(HeroUpgradeInfo, " ", GetJsonDT_HERO_UPGRADE_DATA(data.astHeroUpgradeInfo[dwIndex]));
	}

	return root;
}

INT32 DT_STATE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 13;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwInstanceMAXHP);
	memcpy(pDataBuff + dwOffset, &dwInstanceMAXHP, sizeof(dwInstanceMAXHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwInstanceCurHP);
	memcpy(pDataBuff + dwOffset, &dwInstanceCurHP, sizeof(dwInstanceCurHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wDoubleExpNum);
	memcpy(pDataBuff + dwOffset, &wDoubleExpNum, sizeof(wDoubleExpNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byOpenBoxFlag);
	memcpy(pDataBuff + dwOffset, &byOpenBoxFlag, sizeof(byOpenBoxFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(abyHitItemIdx) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_ENCOURAGE_BOX_GROUP_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyHitItemIdx, sizeof(abyHitItemIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(awUnlockHeroID) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_UNLOCK_HERO_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awUnlockHeroID, sizeof(awUnlockHeroID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wUnlockSkillID);
	memcpy(pDataBuff + dwOffset, &wUnlockSkillID, sizeof(wUnlockSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wUnlockEquipLevel);
	memcpy(pDataBuff + dwOffset, &wUnlockEquipLevel, sizeof(wUnlockEquipLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stUnlockScienceList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(qwRegisterDispNameTime);
	memcpy(pDataBuff + dwOffset, &qwRegisterDispNameTime, sizeof(qwRegisterDispNameTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(dwUnlockElite);
	memcpy(pDataBuff + dwOffset, &dwUnlockElite, sizeof(dwUnlockElite));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(byUpgradeHeroNum);
	memcpy(pDataBuff + dwOffset, &byUpgradeHeroNum, sizeof(byUpgradeHeroNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	dwContextLenTmp = 0;
	if(byUpgradeHeroNum > MAX_FORMATION_IDX_NUM)
	{
		byUpgradeHeroNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byUpgradeHeroNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byUpgradeHeroNum; i++)
	{
		dwContextLenTmp += astHeroUpgradeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_STATE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwInstanceMAXHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwInstanceMAXHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwInstanceMAXHP, 0, sizeof(dwInstanceMAXHP));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwInstanceCurHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwInstanceCurHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwInstanceCurHP, 0, sizeof(dwInstanceCurHP));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wDoubleExpNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wDoubleExpNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDoubleExpNum, 0, sizeof(wDoubleExpNum));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byOpenBoxFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byOpenBoxFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byOpenBoxFlag, 0, sizeof(byOpenBoxFlag));
				}
			}
			break;
		case 5:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyHitItemIdx) >= dwContextLen) && (wArrNum <= MAX_ENCOURAGE_BOX_GROUP_NUM))
				{
					memcpy(&abyHitItemIdx, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyHitItemIdx, 0, sizeof(abyHitItemIdx));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awUnlockHeroID) >= dwContextLen) && (wArrNum <= MAX_UNLOCK_HERO_NUM))
				{
					memcpy(&awUnlockHeroID, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awUnlockHeroID, 0, sizeof(awUnlockHeroID));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wUnlockSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wUnlockSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wUnlockSkillID, 0, sizeof(wUnlockSkillID));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wUnlockEquipLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wUnlockEquipLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wUnlockEquipLevel, 0, sizeof(wUnlockEquipLevel));
				}
			}
			break;
		case 9:
			{
				stUnlockScienceList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 10:
			{
				if(sizeof(qwRegisterDispNameTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwRegisterDispNameTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwRegisterDispNameTime, 0, sizeof(qwRegisterDispNameTime));
				}
			}
			break;
		case 11:
			{
				if(sizeof(dwUnlockElite) >= pstIndex->dwContextLen)
				{
					memcpy(&dwUnlockElite, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwUnlockElite, 0, sizeof(dwUnlockElite));
				}
			}
			break;
		case 12:
			{
				if(sizeof(byUpgradeHeroNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byUpgradeHeroNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUpgradeHeroNum, 0, sizeof(byUpgradeHeroNum));
				}
			}
			break;
		case 13:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byUpgradeHeroNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byUpgradeHeroNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astHeroUpgradeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astHeroUpgradeInfo, 0, sizeof(astHeroUpgradeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astHeroUpgradeInfo, 0, sizeof(astHeroUpgradeInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MONSTER_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_MONSTER_BASE_DATA *pstIn = (DT_MONSTER_BASE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MONSTER_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_MONSTER_BASE_DATA *pstOut = (DT_MONSTER_BASE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MONSTER_BASE_DATA(DT_MONSTER_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));

	return root;
}

INT32 DT_MONSTER_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MONSTER_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MONSTER_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_MONSTER_DATA_LIST *pstIn = (DT_MONSTER_DATA_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wMonsterNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_INSTANCE_MONSTER_NUM; i++)
	{
		if(i >= (INT32)pstIn->wMonsterNum)
			break;
		if(-1 == EncodeDT_MONSTER_BASE_DATA(&pstIn->astMonsterInfListo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MONSTER_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_MONSTER_DATA_LIST *pstOut = (DT_MONSTER_DATA_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wMonsterNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_INSTANCE_MONSTER_NUM; i++)
	{
		if(i >= (INT32)pstOut->wMonsterNum)
			break;
		if(-1 == DecodeDT_MONSTER_BASE_DATA(&pstOut->astMonsterInfListo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MONSTER_DATA_LIST(DT_MONSTER_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MonsterNum", (double)(data.wMonsterNum));
	cJSON *MonsterInfListo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "MonsterInfListo", MonsterInfListo);
	for( UINT32 dwIndex=0; dwIndex<data.wMonsterNum; ++dwIndex)
	{
		cJSON_AddItemToObject(MonsterInfListo, " ", GetJsonDT_MONSTER_BASE_DATA(data.astMonsterInfListo[dwIndex]));
	}

	return root;
}

INT32 DT_MONSTER_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wMonsterNum);
	memcpy(pDataBuff + dwOffset, &wMonsterNum, sizeof(wMonsterNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wMonsterNum > MAX_INSTANCE_MONSTER_NUM)
	{
		wMonsterNum = MAX_INSTANCE_MONSTER_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wMonsterNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wMonsterNum; i++)
	{
		dwContextLenTmp += astMonsterInfListo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MONSTER_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wMonsterNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wMonsterNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMonsterNum, 0, sizeof(wMonsterNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wMonsterNum)
				{
					wArrNum = wArrNum <= MAX_INSTANCE_MONSTER_NUM ? wArrNum : MAX_INSTANCE_MONSTER_NUM;
					wMonsterNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astMonsterInfListo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astMonsterInfListo, 0, sizeof(astMonsterInfListo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astMonsterInfListo, 0, sizeof(astMonsterInfListo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GODWEAPON_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_BATTLE_DATA *pstIn = (DT_GODWEAPON_BATTLE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wQuality))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHPGridNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMaxQuality))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GODWEAPON_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_BATTLE_DATA *pstOut = (DT_GODWEAPON_BATTLE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wQuality))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHPGridNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMaxQuality))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GODWEAPON_BATTLE_DATA(DT_GODWEAPON_BATTLE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Quality", (double)(data.wQuality));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddItemToObject(root, "BattleAttr", GetJsonDT_BATTLE_ATTRIBUTE(data.stBattleAttr));
	cJSON_AddNumberToObject(root,"HPGridNum", (double)(data.byHPGridNum));
	cJSON_AddNumberToObject(root,"MaxQuality", (double)(data.wMaxQuality));

	return root;
}

INT32 DT_GODWEAPON_BATTLE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wQuality);
	memcpy(pDataBuff + dwOffset, &wQuality, sizeof(wQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stBattleAttr.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byHPGridNum);
	memcpy(pDataBuff + dwOffset, &byHPGridNum, sizeof(byHPGridNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wMaxQuality);
	memcpy(pDataBuff + dwOffset, &wMaxQuality, sizeof(wMaxQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GODWEAPON_BATTLE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&wQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wQuality, 0, sizeof(wQuality));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 3:
			{
				stBattleAttr.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				if(sizeof(byHPGridNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHPGridNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHPGridNum, 0, sizeof(byHPGridNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wMaxQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaxQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaxQuality, 0, sizeof(wMaxQuality));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_OBJ_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_DATA *pstIn = (DT_BATTLE_OBJ_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCareerID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFomationIdx))
		return -1;

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSkillActionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSkillActionLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNeedAngry))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wInitAngry))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHPGridNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byColor))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_OBJ_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_DATA *pstOut = (DT_BATTLE_OBJ_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCareerID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFomationIdx))
		return -1;

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSkillActionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSkillActionLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNeedAngry))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wInitAngry))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHPGridNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byColor))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_OBJ_DATA(DT_BATTLE_OBJ_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"CareerID", (double)(data.byCareerID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"FomationIdx", (double)(data.byFomationIdx));
	cJSON_AddItemToObject(root, "BattleAttr", GetJsonDT_BATTLE_ATTRIBUTE(data.stBattleAttr));
	cJSON_AddNumberToObject(root,"SkillActionID", (double)(data.wSkillActionID));
	cJSON_AddNumberToObject(root,"SkillActionLevel", (double)(data.wSkillActionLevel));
	cJSON_AddNumberToObject(root,"NeedAngry", (double)(data.wNeedAngry));
	cJSON_AddNumberToObject(root,"InitAngry", (double)(data.wInitAngry));
	cJSON_AddNumberToObject(root,"HPGridNum", (double)(data.byHPGridNum));
	cJSON_AddNumberToObject(root,"Color", (double)(data.byColor));

	return root;
}

INT32 DT_BATTLE_OBJ_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 11;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCareerID);
	memcpy(pDataBuff + dwOffset, &byCareerID, sizeof(byCareerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byFomationIdx);
	memcpy(pDataBuff + dwOffset, &byFomationIdx, sizeof(byFomationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stBattleAttr.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wSkillActionID);
	memcpy(pDataBuff + dwOffset, &wSkillActionID, sizeof(wSkillActionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wSkillActionLevel);
	memcpy(pDataBuff + dwOffset, &wSkillActionLevel, sizeof(wSkillActionLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wNeedAngry);
	memcpy(pDataBuff + dwOffset, &wNeedAngry, sizeof(wNeedAngry));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wInitAngry);
	memcpy(pDataBuff + dwOffset, &wInitAngry, sizeof(wInitAngry));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byHPGridNum);
	memcpy(pDataBuff + dwOffset, &byHPGridNum, sizeof(byHPGridNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byColor);
	memcpy(pDataBuff + dwOffset, &byColor, sizeof(byColor));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_OBJ_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCareerID) >= pstIndex->dwContextLen)
				{
					memcpy(&byCareerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCareerID, 0, sizeof(byCareerID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byFomationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFomationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFomationIdx, 0, sizeof(byFomationIdx));
				}
			}
			break;
		case 5:
			{
				stBattleAttr.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				if(sizeof(wSkillActionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSkillActionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSkillActionID, 0, sizeof(wSkillActionID));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wSkillActionLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wSkillActionLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSkillActionLevel, 0, sizeof(wSkillActionLevel));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wNeedAngry) >= pstIndex->dwContextLen)
				{
					memcpy(&wNeedAngry, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNeedAngry, 0, sizeof(wNeedAngry));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wInitAngry) >= pstIndex->dwContextLen)
				{
					memcpy(&wInitAngry, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wInitAngry, 0, sizeof(wInitAngry));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byHPGridNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHPGridNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHPGridNum, 0, sizeof(byHPGridNum));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byColor) >= pstIndex->dwContextLen)
				{
					memcpy(&byColor, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byColor, 0, sizeof(byColor));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_OBJ_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_DATA2 *pstIn = (DT_BATTLE_OBJ_DATA2*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCareerID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFomationIdx))
		return -1;

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSkillActionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSkillActionLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNeedAngry))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wInitAngry))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHPGridNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byColor))
		return -1;

	if(-1 == EncodeDT_GODWEAPON_BATTLE_DATA(&pstIn->stGodweaponInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_OBJ_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_DATA2 *pstOut = (DT_BATTLE_OBJ_DATA2*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCareerID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFomationIdx))
		return -1;

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stBattleAttr, poNetData))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSkillActionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSkillActionLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNeedAngry))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wInitAngry))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHPGridNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byColor))
		return -1;

	if(-1 == DecodeDT_GODWEAPON_BATTLE_DATA(&pstOut->stGodweaponInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_OBJ_DATA2(DT_BATTLE_OBJ_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"CareerID", (double)(data.byCareerID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"FomationIdx", (double)(data.byFomationIdx));
	cJSON_AddItemToObject(root, "BattleAttr", GetJsonDT_BATTLE_ATTRIBUTE(data.stBattleAttr));
	cJSON_AddNumberToObject(root,"SkillActionID", (double)(data.wSkillActionID));
	cJSON_AddNumberToObject(root,"SkillActionLevel", (double)(data.wSkillActionLevel));
	cJSON_AddNumberToObject(root,"NeedAngry", (double)(data.wNeedAngry));
	cJSON_AddNumberToObject(root,"InitAngry", (double)(data.wInitAngry));
	cJSON_AddNumberToObject(root,"HPGridNum", (double)(data.byHPGridNum));
	cJSON_AddNumberToObject(root,"Color", (double)(data.byColor));
	cJSON_AddItemToObject(root, "GodweaponInfo", GetJsonDT_GODWEAPON_BATTLE_DATA(data.stGodweaponInfo));

	return root;
}

INT32 DT_BATTLE_OBJ_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 12;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCareerID);
	memcpy(pDataBuff + dwOffset, &byCareerID, sizeof(byCareerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byFomationIdx);
	memcpy(pDataBuff + dwOffset, &byFomationIdx, sizeof(byFomationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stBattleAttr.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wSkillActionID);
	memcpy(pDataBuff + dwOffset, &wSkillActionID, sizeof(wSkillActionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wSkillActionLevel);
	memcpy(pDataBuff + dwOffset, &wSkillActionLevel, sizeof(wSkillActionLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wNeedAngry);
	memcpy(pDataBuff + dwOffset, &wNeedAngry, sizeof(wNeedAngry));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wInitAngry);
	memcpy(pDataBuff + dwOffset, &wInitAngry, sizeof(wInitAngry));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byHPGridNum);
	memcpy(pDataBuff + dwOffset, &byHPGridNum, sizeof(byHPGridNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byColor);
	memcpy(pDataBuff + dwOffset, &byColor, sizeof(byColor));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = stGodweaponInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_OBJ_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCareerID) >= pstIndex->dwContextLen)
				{
					memcpy(&byCareerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCareerID, 0, sizeof(byCareerID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byFomationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFomationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFomationIdx, 0, sizeof(byFomationIdx));
				}
			}
			break;
		case 5:
			{
				stBattleAttr.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				if(sizeof(wSkillActionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSkillActionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSkillActionID, 0, sizeof(wSkillActionID));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wSkillActionLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wSkillActionLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSkillActionLevel, 0, sizeof(wSkillActionLevel));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wNeedAngry) >= pstIndex->dwContextLen)
				{
					memcpy(&wNeedAngry, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNeedAngry, 0, sizeof(wNeedAngry));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wInitAngry) >= pstIndex->dwContextLen)
				{
					memcpy(&wInitAngry, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wInitAngry, 0, sizeof(wInitAngry));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byHPGridNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHPGridNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHPGridNum, 0, sizeof(byHPGridNum));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byColor) >= pstIndex->dwContextLen)
				{
					memcpy(&byColor, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byColor, 0, sizeof(byColor));
				}
			}
			break;
		case 12:
			{
				stGodweaponInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_OBJ_GROUP_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_GROUP_DATA *pstIn = (DT_BATTLE_OBJ_GROUP_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byObjNum)
			break;
		if(-1 == EncodeDT_BATTLE_OBJ_DATA(&pstIn->astBattleObjInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddTString(pstIn->aszDispName, sizeof(pstIn->aszDispName)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_OBJ_GROUP_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_GROUP_DATA *pstOut = (DT_BATTLE_OBJ_GROUP_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byObjNum)
			break;
		if(-1 == DecodeDT_BATTLE_OBJ_DATA(&pstOut->astBattleObjInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelTString(pstOut->aszDispName, sizeof(pstOut->aszDispName)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_OBJ_GROUP_DATA(DT_BATTLE_OBJ_GROUP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ObjNum", (double)(data.byObjNum));
	cJSON *BattleObjInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleObjInfo", BattleObjInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byObjNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleObjInfo, " ", GetJsonDT_BATTLE_OBJ_DATA(data.astBattleObjInfo[dwIndex]));
	}
	cJSON_AddStringToObject(root,"DispName", data.aszDispName );
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));

	return root;
}

INT32 DT_BATTLE_OBJ_GROUP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byObjNum);
	memcpy(pDataBuff + dwOffset, &byObjNum, sizeof(byObjNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byObjNum > MAX_FORMATION_IDX_NUM)
	{
		byObjNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byObjNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byObjNum; i++)
	{
		dwContextLenTmp += astBattleObjInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszDispName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispName, sizeof(aszDispName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_OBJ_GROUP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byObjNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byObjNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byObjNum, 0, sizeof(byObjNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byObjNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byObjNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleObjInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleObjInfo, 0, sizeof(astBattleObjInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleObjInfo, 0, sizeof(astBattleObjInfo));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispName, 0, sizeof(aszDispName));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_OBJ_GROUP_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_GROUP_DATA2 *pstIn = (DT_BATTLE_OBJ_GROUP_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byObjNum)
			break;
		if(-1 == EncodeDT_BATTLE_OBJ_DATA2(&pstIn->astBattleObjInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddTString(pstIn->aszDispName, sizeof(pstIn->aszDispName)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_OBJ_GROUP_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_GROUP_DATA2 *pstOut = (DT_BATTLE_OBJ_GROUP_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byObjNum)
			break;
		if(-1 == DecodeDT_BATTLE_OBJ_DATA2(&pstOut->astBattleObjInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelTString(pstOut->aszDispName, sizeof(pstOut->aszDispName)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_OBJ_GROUP_DATA2(DT_BATTLE_OBJ_GROUP_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ObjNum", (double)(data.byObjNum));
	cJSON *BattleObjInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleObjInfo", BattleObjInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byObjNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleObjInfo, " ", GetJsonDT_BATTLE_OBJ_DATA2(data.astBattleObjInfo[dwIndex]));
	}
	cJSON_AddStringToObject(root,"DispName", data.aszDispName );
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));

	return root;
}

INT32 DT_BATTLE_OBJ_GROUP_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byObjNum);
	memcpy(pDataBuff + dwOffset, &byObjNum, sizeof(byObjNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byObjNum > MAX_FORMATION_IDX_NUM)
	{
		byObjNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byObjNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byObjNum; i++)
	{
		dwContextLenTmp += astBattleObjInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszDispName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispName, sizeof(aszDispName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_OBJ_GROUP_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byObjNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byObjNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byObjNum, 0, sizeof(byObjNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byObjNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byObjNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleObjInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleObjInfo, 0, sizeof(astBattleObjInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleObjInfo, 0, sizeof(astBattleObjInfo));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispName, 0, sizeof(aszDispName));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BUFF_DATA(void *pHost, CNetData* poNetData)
{
	DT_BUFF_DATA *pstIn = (DT_BUFF_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAddDelFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBuffID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BUFF_DATA(void *pHost, CNetData* poNetData)
{
	DT_BUFF_DATA *pstOut = (DT_BUFF_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAddDelFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBuffID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BUFF_DATA(DT_BUFF_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"AddDelFlag", (double)(data.wAddDelFlag));
	cJSON_AddNumberToObject(root,"BuffID", (double)(data.byBuffID));

	return root;
}

INT32 DT_BUFF_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAddDelFlag);
	memcpy(pDataBuff + dwOffset, &wAddDelFlag, sizeof(wAddDelFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBuffID);
	memcpy(pDataBuff + dwOffset, &byBuffID, sizeof(byBuffID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BUFF_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAddDelFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&wAddDelFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAddDelFlag, 0, sizeof(wAddDelFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byBuffID) >= pstIndex->dwContextLen)
				{
					memcpy(&byBuffID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBuffID, 0, sizeof(byBuffID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HP_DATA(void *pHost, CNetData* poNetData)
{
	DT_HP_DATA *pstIn = (DT_HP_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddInt(pstIn->nHP))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HP_DATA(void *pHost, CNetData* poNetData)
{
	DT_HP_DATA *pstOut = (DT_HP_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelInt(pstOut->nHP))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HP_DATA(DT_HP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"HP", (double)(data.nHP));

	return root;
}

INT32 DT_HP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(nHP);
	memcpy(pDataBuff + dwOffset, &nHP, sizeof(nHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(nHP) >= pstIndex->dwContextLen)
				{
					memcpy(&nHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&nHP, 0, sizeof(nHP));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ANGRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_ANGRY_DATA *pstIn = (DT_ANGRY_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddShort(pstIn->shAngry))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ANGRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_ANGRY_DATA *pstOut = (DT_ANGRY_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelShort(pstOut->shAngry))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ANGRY_DATA(DT_ANGRY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"Angry", (double)(data.shAngry));

	return root;
}

INT32 DT_ANGRY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(shAngry);
	memcpy(pDataBuff + dwOffset, &shAngry, sizeof(shAngry));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ANGRY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(shAngry) >= pstIndex->dwContextLen)
				{
					memcpy(&shAngry, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&shAngry, 0, sizeof(shAngry));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PARRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_PARRY_DATA *pstIn = (DT_PARRY_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byParryFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeCritFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PARRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_PARRY_DATA *pstOut = (DT_PARRY_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byParryFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeCritFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PARRY_DATA(DT_PARRY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"ParryFlag", (double)(data.byParryFlag));
	cJSON_AddNumberToObject(root,"BeCritFlag", (double)(data.byBeCritFlag));

	return root;
}

INT32 DT_PARRY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byParryFlag);
	memcpy(pDataBuff + dwOffset, &byParryFlag, sizeof(byParryFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBeCritFlag);
	memcpy(pDataBuff + dwOffset, &byBeCritFlag, sizeof(byBeCritFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PARRY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byParryFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byParryFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byParryFlag, 0, sizeof(byParryFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byBeCritFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeCritFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeCritFlag, 0, sizeof(byBeCritFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SKILL_EFFECT_ID_DATA(void *pHost, CNetData* poNetData)
{
	DT_SKILL_EFFECT_ID_DATA *pstIn = (DT_SKILL_EFFECT_ID_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wEffectID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SKILL_EFFECT_ID_DATA(void *pHost, CNetData* poNetData)
{
	DT_SKILL_EFFECT_ID_DATA *pstOut = (DT_SKILL_EFFECT_ID_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wEffectID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SKILL_EFFECT_ID_DATA(DT_SKILL_EFFECT_ID_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"EffectID", (double)(data.wEffectID));

	return root;
}

INT32 DT_SKILL_EFFECT_ID_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wEffectID);
	memcpy(pDataBuff + dwOffset, &wEffectID, sizeof(wEffectID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SKILL_EFFECT_ID_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wEffectID) >= pstIndex->dwContextLen)
				{
					memcpy(&wEffectID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEffectID, 0, sizeof(wEffectID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_OBJ_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_OBJ_DATA *pstIn = (DT_ATTACK_OBJ_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBuffChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byBuffChangeNum)
			break;
		if(-1 == EncodeDT_BUFF_DATA(&pstIn->astBuffChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHpChangeNum))
		return -1;

	for(i = 0; i < MAX_HP_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byHpChangeNum)
			break;
		if(-1 == EncodeDT_HP_DATA(&pstIn->astHpChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byAngryChangeNum))
		return -1;

	for(i = 0; i < MAX_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byAngryChangeNum)
			break;
		if(-1 == EncodeDT_ANGRY_DATA(&pstIn->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->bySkillEffectIDChangeNum))
		return -1;

	for(i = 0; i < MAX_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->bySkillEffectIDChangeNum)
			break;
		if(-1 == EncodeDT_SKILL_EFFECT_ID_DATA(&pstIn->astSkillEffectIDChangeInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_OBJ_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_OBJ_DATA *pstOut = (DT_ATTACK_OBJ_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBuffChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byBuffChangeNum)
			break;
		if(-1 == DecodeDT_BUFF_DATA(&pstOut->astBuffChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHpChangeNum))
		return -1;

	for(i = 0; i < MAX_HP_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byHpChangeNum)
			break;
		if(-1 == DecodeDT_HP_DATA(&pstOut->astHpChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byAngryChangeNum))
		return -1;

	for(i = 0; i < MAX_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byAngryChangeNum)
			break;
		if(-1 == DecodeDT_ANGRY_DATA(&pstOut->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->bySkillEffectIDChangeNum))
		return -1;

	for(i = 0; i < MAX_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->bySkillEffectIDChangeNum)
			break;
		if(-1 == DecodeDT_SKILL_EFFECT_ID_DATA(&pstOut->astSkillEffectIDChangeInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_OBJ_DATA(DT_ATTACK_OBJ_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BuffChangeNum", (double)(data.byBuffChangeNum));
	cJSON *BuffChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BuffChangeInfo", BuffChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBuffChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BuffChangeInfo, " ", GetJsonDT_BUFF_DATA(data.astBuffChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HpChangeNum", (double)(data.byHpChangeNum));
	cJSON *HpChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HpChangeInfo", HpChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byHpChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(HpChangeInfo, " ", GetJsonDT_HP_DATA(data.astHpChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"AngryChangeNum", (double)(data.byAngryChangeNum));
	cJSON *AngryChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "AngryChangeInfo", AngryChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byAngryChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(AngryChangeInfo, " ", GetJsonDT_ANGRY_DATA(data.astAngryChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"SkillEffectIDChangeNum", (double)(data.bySkillEffectIDChangeNum));
	cJSON *SkillEffectIDChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SkillEffectIDChangeInfo", SkillEffectIDChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.bySkillEffectIDChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SkillEffectIDChangeInfo, " ", GetJsonDT_SKILL_EFFECT_ID_DATA(data.astSkillEffectIDChangeInfo[dwIndex]));
	}

	return root;
}

INT32 DT_ATTACK_OBJ_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBuffChangeNum);
	memcpy(pDataBuff + dwOffset, &byBuffChangeNum, sizeof(byBuffChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byBuffChangeNum > MAX_BUFF_CHANGE_TIMES_PER_ROUND)
	{
		byBuffChangeNum = MAX_BUFF_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBuffChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBuffChangeNum; i++)
	{
		dwContextLenTmp += astBuffChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byHpChangeNum);
	memcpy(pDataBuff + dwOffset, &byHpChangeNum, sizeof(byHpChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(byHpChangeNum > MAX_HP_CHANGE_TIMES_PER_ROUND)
	{
		byHpChangeNum = MAX_HP_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byHpChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byHpChangeNum; i++)
	{
		dwContextLenTmp += astHpChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byAngryChangeNum);
	memcpy(pDataBuff + dwOffset, &byAngryChangeNum, sizeof(byAngryChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byAngryChangeNum > MAX_ANGRY_CHANGE_TIMES_PER_ROUND)
	{
		byAngryChangeNum = MAX_ANGRY_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAngryChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAngryChangeNum; i++)
	{
		dwContextLenTmp += astAngryChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(bySkillEffectIDChangeNum);
	memcpy(pDataBuff + dwOffset, &bySkillEffectIDChangeNum, sizeof(bySkillEffectIDChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	dwContextLenTmp = 0;
	if(bySkillEffectIDChangeNum > MAX_BUFF_CHANGE_TIMES_PER_ROUND)
	{
		bySkillEffectIDChangeNum = MAX_BUFF_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = bySkillEffectIDChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < bySkillEffectIDChangeNum; i++)
	{
		dwContextLenTmp += astSkillEffectIDChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_OBJ_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBuffChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBuffChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBuffChangeNum, 0, sizeof(byBuffChangeNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBuffChangeNum)
				{
					wArrNum = wArrNum <= MAX_BUFF_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_BUFF_CHANGE_TIMES_PER_ROUND;
					byBuffChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBuffChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBuffChangeInfo, 0, sizeof(astBuffChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBuffChangeInfo, 0, sizeof(astBuffChangeInfo));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byHpChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHpChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHpChangeNum, 0, sizeof(byHpChangeNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byHpChangeNum)
				{
					wArrNum = wArrNum <= MAX_HP_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_HP_CHANGE_TIMES_PER_ROUND;
					byHpChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astHpChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astHpChangeInfo, 0, sizeof(astHpChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astHpChangeInfo, 0, sizeof(astHpChangeInfo));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byAngryChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAngryChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAngryChangeNum, 0, sizeof(byAngryChangeNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAngryChangeNum)
				{
					wArrNum = wArrNum <= MAX_ANGRY_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_ANGRY_CHANGE_TIMES_PER_ROUND;
					byAngryChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astAngryChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
				}
			}
			break;
		case 7:
			{
				if(sizeof(bySkillEffectIDChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkillEffectIDChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkillEffectIDChangeNum, 0, sizeof(bySkillEffectIDChangeNum));
				}
			}
			break;
		case 8:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == bySkillEffectIDChangeNum)
				{
					wArrNum = wArrNum <= MAX_BUFF_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_BUFF_CHANGE_TIMES_PER_ROUND;
					bySkillEffectIDChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSkillEffectIDChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSkillEffectIDChangeInfo, 0, sizeof(astSkillEffectIDChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSkillEffectIDChangeInfo, 0, sizeof(astSkillEffectIDChangeInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_OBJ_DATA2(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_OBJ_DATA2 *pstIn = (DT_ATTACK_OBJ_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBuffChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byBuffChangeNum)
			break;
		if(-1 == EncodeDT_BUFF_DATA(&pstIn->astBuffChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHpChangeNum))
		return -1;

	for(i = 0; i < MAX_HP_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byHpChangeNum)
			break;
		if(-1 == EncodeDT_HP_DATA(&pstIn->astHpChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byAngryChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byAngryChangeNum)
			break;
		if(-1 == EncodeDT_ANGRY_DATA(&pstIn->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->bySkillEffectIDChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->bySkillEffectIDChangeNum)
			break;
		if(-1 == EncodeDT_SKILL_EFFECT_ID_DATA(&pstIn->astSkillEffectIDChangeInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_OBJ_DATA2(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_OBJ_DATA2 *pstOut = (DT_ATTACK_OBJ_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBuffChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byBuffChangeNum)
			break;
		if(-1 == DecodeDT_BUFF_DATA(&pstOut->astBuffChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHpChangeNum))
		return -1;

	for(i = 0; i < MAX_HP_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byHpChangeNum)
			break;
		if(-1 == DecodeDT_HP_DATA(&pstOut->astHpChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byAngryChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byAngryChangeNum)
			break;
		if(-1 == DecodeDT_ANGRY_DATA(&pstOut->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->bySkillEffectIDChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->bySkillEffectIDChangeNum)
			break;
		if(-1 == DecodeDT_SKILL_EFFECT_ID_DATA(&pstOut->astSkillEffectIDChangeInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_OBJ_DATA2(DT_ATTACK_OBJ_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BuffChangeNum", (double)(data.byBuffChangeNum));
	cJSON *BuffChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BuffChangeInfo", BuffChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBuffChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BuffChangeInfo, " ", GetJsonDT_BUFF_DATA(data.astBuffChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HpChangeNum", (double)(data.byHpChangeNum));
	cJSON *HpChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HpChangeInfo", HpChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byHpChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(HpChangeInfo, " ", GetJsonDT_HP_DATA(data.astHpChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"AngryChangeNum", (double)(data.byAngryChangeNum));
	cJSON *AngryChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "AngryChangeInfo", AngryChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byAngryChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(AngryChangeInfo, " ", GetJsonDT_ANGRY_DATA(data.astAngryChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"SkillEffectIDChangeNum", (double)(data.bySkillEffectIDChangeNum));
	cJSON *SkillEffectIDChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SkillEffectIDChangeInfo", SkillEffectIDChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.bySkillEffectIDChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SkillEffectIDChangeInfo, " ", GetJsonDT_SKILL_EFFECT_ID_DATA(data.astSkillEffectIDChangeInfo[dwIndex]));
	}

	return root;
}

INT32 DT_ATTACK_OBJ_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBuffChangeNum);
	memcpy(pDataBuff + dwOffset, &byBuffChangeNum, sizeof(byBuffChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byBuffChangeNum > MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND)
	{
		byBuffChangeNum = MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBuffChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBuffChangeNum; i++)
	{
		dwContextLenTmp += astBuffChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byHpChangeNum);
	memcpy(pDataBuff + dwOffset, &byHpChangeNum, sizeof(byHpChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(byHpChangeNum > MAX_HP_CHANGE_TIMES_PER_ROUND)
	{
		byHpChangeNum = MAX_HP_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byHpChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byHpChangeNum; i++)
	{
		dwContextLenTmp += astHpChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byAngryChangeNum);
	memcpy(pDataBuff + dwOffset, &byAngryChangeNum, sizeof(byAngryChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byAngryChangeNum > MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND)
	{
		byAngryChangeNum = MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAngryChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAngryChangeNum; i++)
	{
		dwContextLenTmp += astAngryChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(bySkillEffectIDChangeNum);
	memcpy(pDataBuff + dwOffset, &bySkillEffectIDChangeNum, sizeof(bySkillEffectIDChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	dwContextLenTmp = 0;
	if(bySkillEffectIDChangeNum > MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND)
	{
		bySkillEffectIDChangeNum = MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = bySkillEffectIDChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < bySkillEffectIDChangeNum; i++)
	{
		dwContextLenTmp += astSkillEffectIDChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_OBJ_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBuffChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBuffChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBuffChangeNum, 0, sizeof(byBuffChangeNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBuffChangeNum)
				{
					wArrNum = wArrNum <= MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
					byBuffChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBuffChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBuffChangeInfo, 0, sizeof(astBuffChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBuffChangeInfo, 0, sizeof(astBuffChangeInfo));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byHpChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHpChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHpChangeNum, 0, sizeof(byHpChangeNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byHpChangeNum)
				{
					wArrNum = wArrNum <= MAX_HP_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_HP_CHANGE_TIMES_PER_ROUND;
					byHpChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astHpChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astHpChangeInfo, 0, sizeof(astHpChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astHpChangeInfo, 0, sizeof(astHpChangeInfo));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byAngryChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAngryChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAngryChangeNum, 0, sizeof(byAngryChangeNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAngryChangeNum)
				{
					wArrNum = wArrNum <= MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND;
					byAngryChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astAngryChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
				}
			}
			break;
		case 7:
			{
				if(sizeof(bySkillEffectIDChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkillEffectIDChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkillEffectIDChangeNum, 0, sizeof(bySkillEffectIDChangeNum));
				}
			}
			break;
		case 8:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == bySkillEffectIDChangeNum)
				{
					wArrNum = wArrNum <= MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
					bySkillEffectIDChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSkillEffectIDChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSkillEffectIDChangeInfo, 0, sizeof(astSkillEffectIDChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSkillEffectIDChangeInfo, 0, sizeof(astSkillEffectIDChangeInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_DATA *pstIn = (DT_ATTACK_DATA*)pHost;

	if(-1 == EncodeDT_ATTACK_OBJ_DATA(&pstIn->stMyselfObjInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_OBJ_DATA(&pstIn->stEnemyObjInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_DATA *pstOut = (DT_ATTACK_DATA*)pHost;

	if(-1 == DecodeDT_ATTACK_OBJ_DATA(&pstOut->stMyselfObjInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_OBJ_DATA(&pstOut->stEnemyObjInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_DATA(DT_ATTACK_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfObjInfo", GetJsonDT_ATTACK_OBJ_DATA(data.stMyselfObjInfo));
	cJSON_AddItemToObject(root, "EnemyObjInfo", GetJsonDT_ATTACK_OBJ_DATA(data.stEnemyObjInfo));

	return root;
}

INT32 DT_ATTACK_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfObjInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyObjInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfObjInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyObjInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_DATA2(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_DATA2 *pstIn = (DT_ATTACK_DATA2*)pHost;

	if(-1 == EncodeDT_ATTACK_OBJ_DATA2(&pstIn->stMyselfObjInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_OBJ_DATA2(&pstIn->stEnemyObjInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_DATA2(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_DATA2 *pstOut = (DT_ATTACK_DATA2*)pHost;

	if(-1 == DecodeDT_ATTACK_OBJ_DATA2(&pstOut->stMyselfObjInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_OBJ_DATA2(&pstOut->stEnemyObjInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_DATA2(DT_ATTACK_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfObjInfo", GetJsonDT_ATTACK_OBJ_DATA2(data.stMyselfObjInfo));
	cJSON_AddItemToObject(root, "EnemyObjInfo", GetJsonDT_ATTACK_OBJ_DATA2(data.stEnemyObjInfo));

	return root;
}

INT32 DT_ATTACK_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfObjInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyObjInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfObjInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyObjInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GODWEAPON_ATTACK_DATA(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_ATTACK_DATA *pstIn = (DT_GODWEAPON_ATTACK_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackFlag))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAttackHurtValue))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAngryChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byAngryChangeNum)
			break;
		if(-1 == EncodeDT_ANGRY_DATA(&pstIn->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GODWEAPON_ATTACK_DATA(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_ATTACK_DATA *pstOut = (DT_GODWEAPON_ATTACK_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackFlag))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAttackHurtValue))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAngryChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byAngryChangeNum)
			break;
		if(-1 == DecodeDT_ANGRY_DATA(&pstOut->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GODWEAPON_ATTACK_DATA(DT_GODWEAPON_ATTACK_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackFlag", (double)(data.byAttackFlag));
	cJSON_AddNumberToObject(root,"AttackHurtValue", (double)(data.dwAttackHurtValue));
	cJSON_AddNumberToObject(root,"AngryChangeNum", (double)(data.byAngryChangeNum));
	cJSON *AngryChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "AngryChangeInfo", AngryChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byAngryChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(AngryChangeInfo, " ", GetJsonDT_ANGRY_DATA(data.astAngryChangeInfo[dwIndex]));
	}

	return root;
}

INT32 DT_GODWEAPON_ATTACK_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackFlag);
	memcpy(pDataBuff + dwOffset, &byAttackFlag, sizeof(byAttackFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwAttackHurtValue);
	memcpy(pDataBuff + dwOffset, &dwAttackHurtValue, sizeof(dwAttackHurtValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byAngryChangeNum);
	memcpy(pDataBuff + dwOffset, &byAngryChangeNum, sizeof(byAngryChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(byAngryChangeNum > MAX_ANGRY_CHANGE_TIMES_PER_ROUND)
	{
		byAngryChangeNum = MAX_ANGRY_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAngryChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAngryChangeNum; i++)
	{
		dwContextLenTmp += astAngryChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GODWEAPON_ATTACK_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackFlag, 0, sizeof(byAttackFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwAttackHurtValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAttackHurtValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAttackHurtValue, 0, sizeof(dwAttackHurtValue));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byAngryChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAngryChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAngryChangeNum, 0, sizeof(byAngryChangeNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAngryChangeNum)
				{
					wArrNum = wArrNum <= MAX_ANGRY_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_ANGRY_CHANGE_TIMES_PER_ROUND;
					byAngryChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astAngryChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GODWEAPON_ATTACK_DATA2(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_ATTACK_DATA2 *pstIn = (DT_GODWEAPON_ATTACK_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackFlag))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAttackHurtValue))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byEnemyFormationIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAngryChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byAngryChangeNum)
			break;
		if(-1 == EncodeDT_ANGRY_DATA(&pstIn->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GODWEAPON_ATTACK_DATA2(void *pHost, CNetData* poNetData)
{
	DT_GODWEAPON_ATTACK_DATA2 *pstOut = (DT_GODWEAPON_ATTACK_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackFlag))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAttackHurtValue))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byEnemyFormationIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAngryChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byAngryChangeNum)
			break;
		if(-1 == DecodeDT_ANGRY_DATA(&pstOut->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GODWEAPON_ATTACK_DATA2(DT_GODWEAPON_ATTACK_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackFlag", (double)(data.byAttackFlag));
	cJSON_AddNumberToObject(root,"AttackHurtValue", (double)(data.dwAttackHurtValue));
	cJSON_AddNumberToObject(root,"EnemyFormationIdx", (double)(data.byEnemyFormationIdx));
	cJSON_AddNumberToObject(root,"AngryChangeNum", (double)(data.byAngryChangeNum));
	cJSON *AngryChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "AngryChangeInfo", AngryChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byAngryChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(AngryChangeInfo, " ", GetJsonDT_ANGRY_DATA(data.astAngryChangeInfo[dwIndex]));
	}

	return root;
}

INT32 DT_GODWEAPON_ATTACK_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackFlag);
	memcpy(pDataBuff + dwOffset, &byAttackFlag, sizeof(byAttackFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwAttackHurtValue);
	memcpy(pDataBuff + dwOffset, &dwAttackHurtValue, sizeof(dwAttackHurtValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byEnemyFormationIdx);
	memcpy(pDataBuff + dwOffset, &byEnemyFormationIdx, sizeof(byEnemyFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byAngryChangeNum);
	memcpy(pDataBuff + dwOffset, &byAngryChangeNum, sizeof(byAngryChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	dwContextLenTmp = 0;
	if(byAngryChangeNum > MAX_ANGRY_CHANGE_TIMES_PER_ROUND)
	{
		byAngryChangeNum = MAX_ANGRY_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAngryChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAngryChangeNum; i++)
	{
		dwContextLenTmp += astAngryChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GODWEAPON_ATTACK_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackFlag, 0, sizeof(byAttackFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwAttackHurtValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAttackHurtValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAttackHurtValue, 0, sizeof(dwAttackHurtValue));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byEnemyFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byEnemyFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEnemyFormationIdx, 0, sizeof(byEnemyFormationIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byAngryChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAngryChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAngryChangeNum, 0, sizeof(byAngryChangeNum));
				}
			}
			break;
		case 5:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAngryChangeNum)
				{
					wArrNum = wArrNum <= MAX_ANGRY_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_ANGRY_CHANGE_TIMES_PER_ROUND;
					byAngryChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astAngryChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_ALL_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA *pstIn = (DT_ATTACK_ALL_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttackSkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySkipFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBeAttackerIdxNum)
			break;
		if(-1 == EncodeDT_PARRY_DATA(&pstIn->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_ATTACK_DATA(&pstIn->stBeforeAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_DATA(&pstIn->stAfterAttack, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_ALL_DATA(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA *pstOut = (DT_ATTACK_ALL_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttackSkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySkipFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBeAttackerIdxNum)
			break;
		if(-1 == DecodeDT_PARRY_DATA(&pstOut->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_ATTACK_DATA(&pstOut->stBeforeAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_DATA(&pstOut->stAfterAttack, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_ALL_DATA(DT_ATTACK_ALL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerIdx", (double)(data.byAttackerIdx));
	cJSON_AddNumberToObject(root,"AttackSkillID", (double)(data.wAttackSkillID));
	cJSON_AddNumberToObject(root,"SkipFlag", (double)(data.bySkipFlag));
	cJSON_AddNumberToObject(root,"BeAttackerIdxNum", (double)(data.byBeAttackerIdxNum));
	cJSON *BeAttackerIdxInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BeAttackerIdxInfo", BeAttackerIdxInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBeAttackerIdxNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BeAttackerIdxInfo, " ", GetJsonDT_PARRY_DATA(data.astBeAttackerIdxInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "BeforeAttack", GetJsonDT_ATTACK_DATA(data.stBeforeAttack));
	cJSON_AddItemToObject(root, "AfterAttack", GetJsonDT_ATTACK_DATA(data.stAfterAttack));

	return root;
}

INT32 DT_ATTACK_ALL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerIdx);
	memcpy(pDataBuff + dwOffset, &byAttackerIdx, sizeof(byAttackerIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAttackSkillID);
	memcpy(pDataBuff + dwOffset, &wAttackSkillID, sizeof(wAttackSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(bySkipFlag);
	memcpy(pDataBuff + dwOffset, &bySkipFlag, sizeof(bySkipFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBeAttackerIdxNum);
	memcpy(pDataBuff + dwOffset, &byBeAttackerIdxNum, sizeof(byBeAttackerIdxNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBeAttackerIdxNum > MAX_FORMATION_IDX_NUM)
	{
		byBeAttackerIdxNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBeAttackerIdxNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBeAttackerIdxNum; i++)
	{
		dwContextLenTmp += astBeAttackerIdxInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stBeforeAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stAfterAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_ALL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerIdx, 0, sizeof(byAttackerIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAttackSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttackSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttackSkillID, 0, sizeof(wAttackSkillID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(bySkipFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkipFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkipFlag, 0, sizeof(bySkipFlag));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBeAttackerIdxNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeAttackerIdxNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeAttackerIdxNum, 0, sizeof(byBeAttackerIdxNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBeAttackerIdxNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byBeAttackerIdxNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBeAttackerIdxInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
				}
			}
			break;
		case 7:
			{
				stBeforeAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stAfterAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_ALL_DATA2(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA2 *pstIn = (DT_ATTACK_ALL_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttackSkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySkipFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBeAttackerIdxNum)
			break;
		if(-1 == EncodeDT_PARRY_DATA(&pstIn->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_ATTACK_DATA(&pstIn->stBeforeAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_DATA(&pstIn->stAfterAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_GODWEAPON_ATTACK_DATA(&pstIn->stGodweaponAttackInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_ALL_DATA2(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA2 *pstOut = (DT_ATTACK_ALL_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttackSkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySkipFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBeAttackerIdxNum)
			break;
		if(-1 == DecodeDT_PARRY_DATA(&pstOut->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_ATTACK_DATA(&pstOut->stBeforeAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_DATA(&pstOut->stAfterAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_GODWEAPON_ATTACK_DATA(&pstOut->stGodweaponAttackInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_ALL_DATA2(DT_ATTACK_ALL_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerIdx", (double)(data.byAttackerIdx));
	cJSON_AddNumberToObject(root,"AttackSkillID", (double)(data.wAttackSkillID));
	cJSON_AddNumberToObject(root,"SkipFlag", (double)(data.bySkipFlag));
	cJSON_AddNumberToObject(root,"BeAttackerIdxNum", (double)(data.byBeAttackerIdxNum));
	cJSON *BeAttackerIdxInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BeAttackerIdxInfo", BeAttackerIdxInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBeAttackerIdxNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BeAttackerIdxInfo, " ", GetJsonDT_PARRY_DATA(data.astBeAttackerIdxInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "BeforeAttack", GetJsonDT_ATTACK_DATA(data.stBeforeAttack));
	cJSON_AddItemToObject(root, "AfterAttack", GetJsonDT_ATTACK_DATA(data.stAfterAttack));
	cJSON_AddItemToObject(root, "GodweaponAttackInfo", GetJsonDT_GODWEAPON_ATTACK_DATA(data.stGodweaponAttackInfo));

	return root;
}

INT32 DT_ATTACK_ALL_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerIdx);
	memcpy(pDataBuff + dwOffset, &byAttackerIdx, sizeof(byAttackerIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAttackSkillID);
	memcpy(pDataBuff + dwOffset, &wAttackSkillID, sizeof(wAttackSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(bySkipFlag);
	memcpy(pDataBuff + dwOffset, &bySkipFlag, sizeof(bySkipFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBeAttackerIdxNum);
	memcpy(pDataBuff + dwOffset, &byBeAttackerIdxNum, sizeof(byBeAttackerIdxNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBeAttackerIdxNum > MAX_FORMATION_IDX_NUM)
	{
		byBeAttackerIdxNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBeAttackerIdxNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBeAttackerIdxNum; i++)
	{
		dwContextLenTmp += astBeAttackerIdxInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stBeforeAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stAfterAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stGodweaponAttackInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_ALL_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerIdx, 0, sizeof(byAttackerIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAttackSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttackSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttackSkillID, 0, sizeof(wAttackSkillID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(bySkipFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkipFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkipFlag, 0, sizeof(bySkipFlag));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBeAttackerIdxNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeAttackerIdxNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeAttackerIdxNum, 0, sizeof(byBeAttackerIdxNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBeAttackerIdxNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byBeAttackerIdxNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBeAttackerIdxInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
				}
			}
			break;
		case 7:
			{
				stBeforeAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stAfterAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stGodweaponAttackInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_ALL_DATA3(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA3 *pstIn = (DT_ATTACK_ALL_DATA3*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttackSkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySkipFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBeAttackerIdxNum)
			break;
		if(-1 == EncodeDT_PARRY_DATA(&pstIn->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_ATTACK_DATA2(&pstIn->stBeforeAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_DATA2(&pstIn->stAfterAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_GODWEAPON_ATTACK_DATA(&pstIn->stGodweaponAttackInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_ALL_DATA3(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA3 *pstOut = (DT_ATTACK_ALL_DATA3*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttackSkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySkipFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBeAttackerIdxNum)
			break;
		if(-1 == DecodeDT_PARRY_DATA(&pstOut->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_ATTACK_DATA2(&pstOut->stBeforeAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_DATA2(&pstOut->stAfterAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_GODWEAPON_ATTACK_DATA(&pstOut->stGodweaponAttackInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_ALL_DATA3(DT_ATTACK_ALL_DATA3 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerIdx", (double)(data.byAttackerIdx));
	cJSON_AddNumberToObject(root,"AttackSkillID", (double)(data.wAttackSkillID));
	cJSON_AddNumberToObject(root,"SkipFlag", (double)(data.bySkipFlag));
	cJSON_AddNumberToObject(root,"BeAttackerIdxNum", (double)(data.byBeAttackerIdxNum));
	cJSON *BeAttackerIdxInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BeAttackerIdxInfo", BeAttackerIdxInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBeAttackerIdxNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BeAttackerIdxInfo, " ", GetJsonDT_PARRY_DATA(data.astBeAttackerIdxInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "BeforeAttack", GetJsonDT_ATTACK_DATA2(data.stBeforeAttack));
	cJSON_AddItemToObject(root, "AfterAttack", GetJsonDT_ATTACK_DATA2(data.stAfterAttack));
	cJSON_AddItemToObject(root, "GodweaponAttackInfo", GetJsonDT_GODWEAPON_ATTACK_DATA(data.stGodweaponAttackInfo));

	return root;
}

INT32 DT_ATTACK_ALL_DATA3::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerIdx);
	memcpy(pDataBuff + dwOffset, &byAttackerIdx, sizeof(byAttackerIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAttackSkillID);
	memcpy(pDataBuff + dwOffset, &wAttackSkillID, sizeof(wAttackSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(bySkipFlag);
	memcpy(pDataBuff + dwOffset, &bySkipFlag, sizeof(bySkipFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBeAttackerIdxNum);
	memcpy(pDataBuff + dwOffset, &byBeAttackerIdxNum, sizeof(byBeAttackerIdxNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBeAttackerIdxNum > MAX_FORMATION_IDX_NUM)
	{
		byBeAttackerIdxNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBeAttackerIdxNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBeAttackerIdxNum; i++)
	{
		dwContextLenTmp += astBeAttackerIdxInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stBeforeAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stAfterAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stGodweaponAttackInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_ALL_DATA3::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerIdx, 0, sizeof(byAttackerIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAttackSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttackSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttackSkillID, 0, sizeof(wAttackSkillID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(bySkipFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkipFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkipFlag, 0, sizeof(bySkipFlag));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBeAttackerIdxNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeAttackerIdxNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeAttackerIdxNum, 0, sizeof(byBeAttackerIdxNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBeAttackerIdxNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byBeAttackerIdxNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBeAttackerIdxInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
				}
			}
			break;
		case 7:
			{
				stBeforeAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stAfterAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stGodweaponAttackInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ANGRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ANGRY_DATA *pstIn = (DT_BATTLE_ANGRY_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->bySlot))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCurAngry))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ANGRY_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ANGRY_DATA *pstOut = (DT_BATTLE_ANGRY_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->bySlot))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCurAngry))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ANGRY_DATA(DT_BATTLE_ANGRY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Slot", (double)(data.bySlot));
	cJSON_AddNumberToObject(root,"CurAngry", (double)(data.wCurAngry));

	return root;
}

INT32 DT_BATTLE_ANGRY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(bySlot);
	memcpy(pDataBuff + dwOffset, &bySlot, sizeof(bySlot));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wCurAngry);
	memcpy(pDataBuff + dwOffset, &wCurAngry, sizeof(wCurAngry));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ANGRY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(bySlot) >= pstIndex->dwContextLen)
				{
					memcpy(&bySlot, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySlot, 0, sizeof(bySlot));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wCurAngry) >= pstIndex->dwContextLen)
				{
					memcpy(&wCurAngry, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCurAngry, 0, sizeof(wCurAngry));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ROUND_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA *pstIn = (DT_BATTLE_ROUND_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerFlag))
		return -1;

	if(-1 == EncodeDT_ATTACK_ALL_DATA(&pstIn->stAttackData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ROUND_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA *pstOut = (DT_BATTLE_ROUND_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerFlag))
		return -1;

	if(-1 == DecodeDT_ATTACK_ALL_DATA(&pstOut->stAttackData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ROUND_DATA(DT_BATTLE_ROUND_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerFlag", (double)(data.byAttackerFlag));
	cJSON_AddItemToObject(root, "AttackData", GetJsonDT_ATTACK_ALL_DATA(data.stAttackData));

	return root;
}

INT32 DT_BATTLE_ROUND_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerFlag);
	memcpy(pDataBuff + dwOffset, &byAttackerFlag, sizeof(byAttackerFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stAttackData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ROUND_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerFlag, 0, sizeof(byAttackerFlag));
				}
			}
			break;
		case 2:
			{
				stAttackData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ROUND_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA2 *pstIn = (DT_BATTLE_ROUND_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerFlag))
		return -1;

	if(-1 == EncodeDT_ATTACK_ALL_DATA2(&pstIn->stAttackData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ROUND_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA2 *pstOut = (DT_BATTLE_ROUND_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerFlag))
		return -1;

	if(-1 == DecodeDT_ATTACK_ALL_DATA2(&pstOut->stAttackData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ROUND_DATA2(DT_BATTLE_ROUND_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerFlag", (double)(data.byAttackerFlag));
	cJSON_AddItemToObject(root, "AttackData", GetJsonDT_ATTACK_ALL_DATA2(data.stAttackData));

	return root;
}

INT32 DT_BATTLE_ROUND_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerFlag);
	memcpy(pDataBuff + dwOffset, &byAttackerFlag, sizeof(byAttackerFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stAttackData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ROUND_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerFlag, 0, sizeof(byAttackerFlag));
				}
			}
			break;
		case 2:
			{
				stAttackData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ROUND_DATA3(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA3 *pstIn = (DT_BATTLE_ROUND_DATA3*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerFlag))
		return -1;

	if(-1 == EncodeDT_ATTACK_ALL_DATA3(&pstIn->stAttackData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ROUND_DATA3(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA3 *pstOut = (DT_BATTLE_ROUND_DATA3*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerFlag))
		return -1;

	if(-1 == DecodeDT_ATTACK_ALL_DATA3(&pstOut->stAttackData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ROUND_DATA3(DT_BATTLE_ROUND_DATA3 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerFlag", (double)(data.byAttackerFlag));
	cJSON_AddItemToObject(root, "AttackData", GetJsonDT_ATTACK_ALL_DATA3(data.stAttackData));

	return root;
}

INT32 DT_BATTLE_ROUND_DATA3::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerFlag);
	memcpy(pDataBuff + dwOffset, &byAttackerFlag, sizeof(byAttackerFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stAttackData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ROUND_DATA3::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerFlag, 0, sizeof(byAttackerFlag));
				}
			}
			break;
		case 2:
			{
				stAttackData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA *pstIn = (DT_BATTLE_DATA*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA(&pstIn->stMyselfInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA(&pstIn->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleRoundNum)
			break;
		if(-1 == EncodeDT_BATTLE_ROUND_DATA(&pstIn->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA *pstOut = (DT_BATTLE_DATA*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA(&pstOut->stMyselfInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA(&pstOut->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleRoundNum)
			break;
		if(-1 == DecodeDT_BATTLE_ROUND_DATA(&pstOut->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_DATA(DT_BATTLE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA(data.stMyselfInfo));
	cJSON_AddItemToObject(root, "EnemyInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA(data.stEnemyInfo));
	cJSON_AddNumberToObject(root,"BattleResult", (double)(data.byBattleResult));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));
	cJSON_AddNumberToObject(root,"BattleRoundNum", (double)(data.byBattleRoundNum));
	cJSON *BattleRoundInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleRoundInfo", BattleRoundInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleRoundNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleRoundInfo, " ", GetJsonDT_BATTLE_ROUND_DATA(data.astBattleRoundInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "MyselfInfoAfterBattle", GetJsonDT_BATTLE_ATTRIBUTE(data.stMyselfInfoAfterBattle));

	return root;
}

INT32 DT_BATTLE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBattleResult);
	memcpy(pDataBuff + dwOffset, &byBattleResult, sizeof(byBattleResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBattleRoundNum);
	memcpy(pDataBuff + dwOffset, &byBattleRoundNum, sizeof(byBattleRoundNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBattleRoundNum > MAX_BATTLE_ROUND_NUM)
	{
		byBattleRoundNum = MAX_BATTLE_ROUND_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleRoundNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleRoundNum; i++)
	{
		dwContextLenTmp += astBattleRoundInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stMyselfInfoAfterBattle.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(byBattleResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleResult, 0, sizeof(byBattleResult));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBattleRoundNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleRoundNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleRoundNum, 0, sizeof(byBattleRoundNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleRoundNum)
				{
					wArrNum = wArrNum <= MAX_BATTLE_ROUND_NUM ? wArrNum : MAX_BATTLE_ROUND_NUM;
					byBattleRoundNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleRoundInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
				}
			}
			break;
		case 7:
			{
				stMyselfInfoAfterBattle.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA2 *pstIn = (DT_BATTLE_DATA2*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA2(&pstIn->stMyselfInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA2(&pstIn->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleRoundNum)
			break;
		if(-1 == EncodeDT_BATTLE_ROUND_DATA2(&pstIn->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_DATA2(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA2 *pstOut = (DT_BATTLE_DATA2*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA2(&pstOut->stMyselfInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA2(&pstOut->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleRoundNum)
			break;
		if(-1 == DecodeDT_BATTLE_ROUND_DATA2(&pstOut->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_DATA2(DT_BATTLE_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA2(data.stMyselfInfo));
	cJSON_AddItemToObject(root, "EnemyInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA2(data.stEnemyInfo));
	cJSON_AddNumberToObject(root,"BattleResult", (double)(data.byBattleResult));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));
	cJSON_AddNumberToObject(root,"BattleRoundNum", (double)(data.byBattleRoundNum));
	cJSON *BattleRoundInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleRoundInfo", BattleRoundInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleRoundNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleRoundInfo, " ", GetJsonDT_BATTLE_ROUND_DATA2(data.astBattleRoundInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "MyselfInfoAfterBattle", GetJsonDT_BATTLE_ATTRIBUTE(data.stMyselfInfoAfterBattle));

	return root;
}

INT32 DT_BATTLE_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBattleResult);
	memcpy(pDataBuff + dwOffset, &byBattleResult, sizeof(byBattleResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBattleRoundNum);
	memcpy(pDataBuff + dwOffset, &byBattleRoundNum, sizeof(byBattleRoundNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBattleRoundNum > MAX_BATTLE_ROUND_NUM)
	{
		byBattleRoundNum = MAX_BATTLE_ROUND_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleRoundNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleRoundNum; i++)
	{
		dwContextLenTmp += astBattleRoundInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stMyselfInfoAfterBattle.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(byBattleResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleResult, 0, sizeof(byBattleResult));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBattleRoundNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleRoundNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleRoundNum, 0, sizeof(byBattleRoundNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleRoundNum)
				{
					wArrNum = wArrNum <= MAX_BATTLE_ROUND_NUM ? wArrNum : MAX_BATTLE_ROUND_NUM;
					byBattleRoundNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleRoundInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
				}
			}
			break;
		case 7:
			{
				stMyselfInfoAfterBattle.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_DATA3(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA3 *pstIn = (DT_BATTLE_DATA3*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA2(&pstIn->stMyselfInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA2(&pstIn->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleRoundNum)
			break;
		if(-1 == EncodeDT_BATTLE_ROUND_DATA3(&pstIn->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_DATA3(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA3 *pstOut = (DT_BATTLE_DATA3*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA2(&pstOut->stMyselfInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA2(&pstOut->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleRoundNum)
			break;
		if(-1 == DecodeDT_BATTLE_ROUND_DATA3(&pstOut->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_DATA3(DT_BATTLE_DATA3 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA2(data.stMyselfInfo));
	cJSON_AddItemToObject(root, "EnemyInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA2(data.stEnemyInfo));
	cJSON_AddNumberToObject(root,"BattleResult", (double)(data.byBattleResult));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));
	cJSON_AddNumberToObject(root,"BattleRoundNum", (double)(data.byBattleRoundNum));
	cJSON *BattleRoundInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleRoundInfo", BattleRoundInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleRoundNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleRoundInfo, " ", GetJsonDT_BATTLE_ROUND_DATA3(data.astBattleRoundInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "MyselfInfoAfterBattle", GetJsonDT_BATTLE_ATTRIBUTE(data.stMyselfInfoAfterBattle));

	return root;
}

INT32 DT_BATTLE_DATA3::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBattleResult);
	memcpy(pDataBuff + dwOffset, &byBattleResult, sizeof(byBattleResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBattleRoundNum);
	memcpy(pDataBuff + dwOffset, &byBattleRoundNum, sizeof(byBattleRoundNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBattleRoundNum > MAX_NEW_BATTLE_ROUND_NUM)
	{
		byBattleRoundNum = MAX_NEW_BATTLE_ROUND_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleRoundNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleRoundNum; i++)
	{
		dwContextLenTmp += astBattleRoundInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stMyselfInfoAfterBattle.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_DATA3::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(byBattleResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleResult, 0, sizeof(byBattleResult));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBattleRoundNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleRoundNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleRoundNum, 0, sizeof(byBattleRoundNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleRoundNum)
				{
					wArrNum = wArrNum <= MAX_NEW_BATTLE_ROUND_NUM ? wArrNum : MAX_NEW_BATTLE_ROUND_NUM;
					byBattleRoundNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleRoundInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
				}
			}
			break;
		case 7:
			{
				stMyselfInfoAfterBattle.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SHIELD_DATA(void *pHost, CNetData* poNetData)
{
	DT_SHIELD_DATA *pstIn = (DT_SHIELD_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAddDelFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySheldID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SHIELD_DATA(void *pHost, CNetData* poNetData)
{
	DT_SHIELD_DATA *pstOut = (DT_SHIELD_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAddDelFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySheldID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SHIELD_DATA(DT_SHIELD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"AddDelFlag", (double)(data.byAddDelFlag));
	cJSON_AddNumberToObject(root,"SheldID", (double)(data.bySheldID));

	return root;
}

INT32 DT_SHIELD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byAddDelFlag);
	memcpy(pDataBuff + dwOffset, &byAddDelFlag, sizeof(byAddDelFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(bySheldID);
	memcpy(pDataBuff + dwOffset, &bySheldID, sizeof(bySheldID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SHIELD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byAddDelFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAddDelFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAddDelFlag, 0, sizeof(byAddDelFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(bySheldID) >= pstIndex->dwContextLen)
				{
					memcpy(&bySheldID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySheldID, 0, sizeof(bySheldID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HP_DATA2(void *pHost, CNetData* poNetData)
{
	DT_HP_DATA2 *pstIn = (DT_HP_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddInt(pstIn->nHP))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byEnemyIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byReason))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HP_DATA2(void *pHost, CNetData* poNetData)
{
	DT_HP_DATA2 *pstOut = (DT_HP_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelInt(pstOut->nHP))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byEnemyIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byReason))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HP_DATA2(DT_HP_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"HP", (double)(data.nHP));
	cJSON_AddNumberToObject(root,"EnemyIdx", (double)(data.byEnemyIdx));
	cJSON_AddNumberToObject(root,"Reason", (double)(data.byReason));

	return root;
}

INT32 DT_HP_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(nHP);
	memcpy(pDataBuff + dwOffset, &nHP, sizeof(nHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byEnemyIdx);
	memcpy(pDataBuff + dwOffset, &byEnemyIdx, sizeof(byEnemyIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byReason);
	memcpy(pDataBuff + dwOffset, &byReason, sizeof(byReason));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HP_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(nHP) >= pstIndex->dwContextLen)
				{
					memcpy(&nHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&nHP, 0, sizeof(nHP));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byEnemyIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byEnemyIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEnemyIdx, 0, sizeof(byEnemyIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byReason) >= pstIndex->dwContextLen)
				{
					memcpy(&byReason, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byReason, 0, sizeof(byReason));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_OBJ_DATA3(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_OBJ_DATA3 *pstIn = (DT_ATTACK_OBJ_DATA3*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBuffChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byBuffChangeNum)
			break;
		if(-1 == EncodeDT_BUFF_DATA(&pstIn->astBuffChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHpChangeNum))
		return -1;

	for(i = 0; i < MAX_HP_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byHpChangeNum)
			break;
		if(-1 == EncodeDT_HP_DATA2(&pstIn->astHpChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byAngryChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->byAngryChangeNum)
			break;
		if(-1 == EncodeDT_ANGRY_DATA(&pstIn->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->bySkillEffectIDChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstIn->bySkillEffectIDChangeNum)
			break;
		if(-1 == EncodeDT_SKILL_EFFECT_ID_DATA(&pstIn->astSkillEffectIDChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byShieldChangeNum))
		return -1;

	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byShieldChangeNum)
			break;
		if(-1 == EncodeDT_SHIELD_DATA(&pstIn->astShieldChangeInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_OBJ_DATA3(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_OBJ_DATA3 *pstOut = (DT_ATTACK_OBJ_DATA3*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBuffChangeNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byBuffChangeNum)
			break;
		if(-1 == DecodeDT_BUFF_DATA(&pstOut->astBuffChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHpChangeNum))
		return -1;

	for(i = 0; i < MAX_HP_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byHpChangeNum)
			break;
		if(-1 == DecodeDT_HP_DATA2(&pstOut->astHpChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byAngryChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->byAngryChangeNum)
			break;
		if(-1 == DecodeDT_ANGRY_DATA(&pstOut->astAngryChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->bySkillEffectIDChangeNum))
		return -1;

	for(i = 0; i < MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND; i++)
	{
		if(i >= (INT32)pstOut->bySkillEffectIDChangeNum)
			break;
		if(-1 == DecodeDT_SKILL_EFFECT_ID_DATA(&pstOut->astSkillEffectIDChangeInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byShieldChangeNum))
		return -1;

	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byShieldChangeNum)
			break;
		if(-1 == DecodeDT_SHIELD_DATA(&pstOut->astShieldChangeInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_OBJ_DATA3(DT_ATTACK_OBJ_DATA3 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BuffChangeNum", (double)(data.byBuffChangeNum));
	cJSON *BuffChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BuffChangeInfo", BuffChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBuffChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BuffChangeInfo, " ", GetJsonDT_BUFF_DATA(data.astBuffChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HpChangeNum", (double)(data.byHpChangeNum));
	cJSON *HpChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HpChangeInfo", HpChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byHpChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(HpChangeInfo, " ", GetJsonDT_HP_DATA2(data.astHpChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"AngryChangeNum", (double)(data.byAngryChangeNum));
	cJSON *AngryChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "AngryChangeInfo", AngryChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byAngryChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(AngryChangeInfo, " ", GetJsonDT_ANGRY_DATA(data.astAngryChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"SkillEffectIDChangeNum", (double)(data.bySkillEffectIDChangeNum));
	cJSON *SkillEffectIDChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SkillEffectIDChangeInfo", SkillEffectIDChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.bySkillEffectIDChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SkillEffectIDChangeInfo, " ", GetJsonDT_SKILL_EFFECT_ID_DATA(data.astSkillEffectIDChangeInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"ShieldChangeNum", (double)(data.byShieldChangeNum));
	cJSON *ShieldChangeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ShieldChangeInfo", ShieldChangeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byShieldChangeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ShieldChangeInfo, " ", GetJsonDT_SHIELD_DATA(data.astShieldChangeInfo[dwIndex]));
	}

	return root;
}

INT32 DT_ATTACK_OBJ_DATA3::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBuffChangeNum);
	memcpy(pDataBuff + dwOffset, &byBuffChangeNum, sizeof(byBuffChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byBuffChangeNum > MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND)
	{
		byBuffChangeNum = MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBuffChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBuffChangeNum; i++)
	{
		dwContextLenTmp += astBuffChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byHpChangeNum);
	memcpy(pDataBuff + dwOffset, &byHpChangeNum, sizeof(byHpChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(byHpChangeNum > MAX_HP_CHANGE_TIMES_PER_ROUND)
	{
		byHpChangeNum = MAX_HP_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byHpChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byHpChangeNum; i++)
	{
		dwContextLenTmp += astHpChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byAngryChangeNum);
	memcpy(pDataBuff + dwOffset, &byAngryChangeNum, sizeof(byAngryChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byAngryChangeNum > MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND)
	{
		byAngryChangeNum = MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAngryChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAngryChangeNum; i++)
	{
		dwContextLenTmp += astAngryChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(bySkillEffectIDChangeNum);
	memcpy(pDataBuff + dwOffset, &bySkillEffectIDChangeNum, sizeof(bySkillEffectIDChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	dwContextLenTmp = 0;
	if(bySkillEffectIDChangeNum > MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND)
	{
		bySkillEffectIDChangeNum = MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
	}
	*(UINT16*)(pDataBuff + dwOffset) = bySkillEffectIDChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < bySkillEffectIDChangeNum; i++)
	{
		dwContextLenTmp += astSkillEffectIDChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byShieldChangeNum);
	memcpy(pDataBuff + dwOffset, &byShieldChangeNum, sizeof(byShieldChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	dwContextLenTmp = 0;
	if(byShieldChangeNum > MAX_FORMATION_IDX_NUM)
	{
		byShieldChangeNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byShieldChangeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byShieldChangeNum; i++)
	{
		dwContextLenTmp += astShieldChangeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_OBJ_DATA3::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBuffChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBuffChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBuffChangeNum, 0, sizeof(byBuffChangeNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBuffChangeNum)
				{
					wArrNum = wArrNum <= MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
					byBuffChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBuffChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBuffChangeInfo, 0, sizeof(astBuffChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBuffChangeInfo, 0, sizeof(astBuffChangeInfo));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byHpChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHpChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHpChangeNum, 0, sizeof(byHpChangeNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byHpChangeNum)
				{
					wArrNum = wArrNum <= MAX_HP_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_HP_CHANGE_TIMES_PER_ROUND;
					byHpChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astHpChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astHpChangeInfo, 0, sizeof(astHpChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astHpChangeInfo, 0, sizeof(astHpChangeInfo));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byAngryChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAngryChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAngryChangeNum, 0, sizeof(byAngryChangeNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAngryChangeNum)
				{
					wArrNum = wArrNum <= MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_NEW_ANGRY_CHANGE_TIMES_PER_ROUND;
					byAngryChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astAngryChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astAngryChangeInfo, 0, sizeof(astAngryChangeInfo));
				}
			}
			break;
		case 7:
			{
				if(sizeof(bySkillEffectIDChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkillEffectIDChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkillEffectIDChangeNum, 0, sizeof(bySkillEffectIDChangeNum));
				}
			}
			break;
		case 8:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == bySkillEffectIDChangeNum)
				{
					wArrNum = wArrNum <= MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND ? wArrNum : MAX_NEW_BUFF_CHANGE_TIMES_PER_ROUND;
					bySkillEffectIDChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSkillEffectIDChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSkillEffectIDChangeInfo, 0, sizeof(astSkillEffectIDChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSkillEffectIDChangeInfo, 0, sizeof(astSkillEffectIDChangeInfo));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byShieldChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byShieldChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byShieldChangeNum, 0, sizeof(byShieldChangeNum));
				}
			}
			break;
		case 10:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byShieldChangeNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byShieldChangeNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astShieldChangeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astShieldChangeInfo, 0, sizeof(astShieldChangeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astShieldChangeInfo, 0, sizeof(astShieldChangeInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_DATA3(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_DATA3 *pstIn = (DT_ATTACK_DATA3*)pHost;

	if(-1 == EncodeDT_ATTACK_OBJ_DATA3(&pstIn->stMyselfObjInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_OBJ_DATA3(&pstIn->stEnemyObjInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_DATA3(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_DATA3 *pstOut = (DT_ATTACK_DATA3*)pHost;

	if(-1 == DecodeDT_ATTACK_OBJ_DATA3(&pstOut->stMyselfObjInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_OBJ_DATA3(&pstOut->stEnemyObjInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_DATA3(DT_ATTACK_DATA3 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfObjInfo", GetJsonDT_ATTACK_OBJ_DATA3(data.stMyselfObjInfo));
	cJSON_AddItemToObject(root, "EnemyObjInfo", GetJsonDT_ATTACK_OBJ_DATA3(data.stEnemyObjInfo));

	return root;
}

INT32 DT_ATTACK_DATA3::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfObjInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyObjInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_DATA3::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfObjInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyObjInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PARRY_DATA2(void *pHost, CNetData* poNetData)
{
	DT_PARRY_DATA2 *pstIn = (DT_PARRY_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byParryFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeCritFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDodge))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PARRY_DATA2(void *pHost, CNetData* poNetData)
{
	DT_PARRY_DATA2 *pstOut = (DT_PARRY_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byParryFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeCritFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDodge))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PARRY_DATA2(DT_PARRY_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"ParryFlag", (double)(data.byParryFlag));
	cJSON_AddNumberToObject(root,"BeCritFlag", (double)(data.byBeCritFlag));
	cJSON_AddNumberToObject(root,"Dodge", (double)(data.byDodge));

	return root;
}

INT32 DT_PARRY_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byParryFlag);
	memcpy(pDataBuff + dwOffset, &byParryFlag, sizeof(byParryFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBeCritFlag);
	memcpy(pDataBuff + dwOffset, &byBeCritFlag, sizeof(byBeCritFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byDodge);
	memcpy(pDataBuff + dwOffset, &byDodge, sizeof(byDodge));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PARRY_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byParryFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byParryFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byParryFlag, 0, sizeof(byParryFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byBeCritFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeCritFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeCritFlag, 0, sizeof(byBeCritFlag));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byDodge) >= pstIndex->dwContextLen)
				{
					memcpy(&byDodge, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDodge, 0, sizeof(byDodge));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_ALL_DATA4(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA4 *pstIn = (DT_ATTACK_ALL_DATA4*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttackSkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySkipFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBeAttackerIdxNum)
			break;
		if(-1 == EncodeDT_PARRY_DATA2(&pstIn->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_ATTACK_DATA3(&pstIn->stBeforeAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_DATA3(&pstIn->stAfterAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_GODWEAPON_ATTACK_DATA2(&pstIn->stGodweaponAttackInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAttackSpecialEffectFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byEnemySpecialEffectFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_ALL_DATA4(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA4 *pstOut = (DT_ATTACK_ALL_DATA4*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttackSkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySkipFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBeAttackerIdxNum)
			break;
		if(-1 == DecodeDT_PARRY_DATA2(&pstOut->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_ATTACK_DATA3(&pstOut->stBeforeAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_DATA3(&pstOut->stAfterAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_GODWEAPON_ATTACK_DATA2(&pstOut->stGodweaponAttackInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAttackSpecialEffectFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byEnemySpecialEffectFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_ALL_DATA4(DT_ATTACK_ALL_DATA4 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerIdx", (double)(data.byAttackerIdx));
	cJSON_AddNumberToObject(root,"AttackSkillID", (double)(data.wAttackSkillID));
	cJSON_AddNumberToObject(root,"SkipFlag", (double)(data.bySkipFlag));
	cJSON_AddNumberToObject(root,"BeAttackerIdxNum", (double)(data.byBeAttackerIdxNum));
	cJSON *BeAttackerIdxInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BeAttackerIdxInfo", BeAttackerIdxInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBeAttackerIdxNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BeAttackerIdxInfo, " ", GetJsonDT_PARRY_DATA2(data.astBeAttackerIdxInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "BeforeAttack", GetJsonDT_ATTACK_DATA3(data.stBeforeAttack));
	cJSON_AddItemToObject(root, "AfterAttack", GetJsonDT_ATTACK_DATA3(data.stAfterAttack));
	cJSON_AddItemToObject(root, "GodweaponAttackInfo", GetJsonDT_GODWEAPON_ATTACK_DATA2(data.stGodweaponAttackInfo));
	cJSON_AddNumberToObject(root,"AttackSpecialEffectFlag", (double)(data.byAttackSpecialEffectFlag));
	cJSON_AddNumberToObject(root,"EnemySpecialEffectFlag", (double)(data.byEnemySpecialEffectFlag));

	return root;
}

INT32 DT_ATTACK_ALL_DATA4::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerIdx);
	memcpy(pDataBuff + dwOffset, &byAttackerIdx, sizeof(byAttackerIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAttackSkillID);
	memcpy(pDataBuff + dwOffset, &wAttackSkillID, sizeof(wAttackSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(bySkipFlag);
	memcpy(pDataBuff + dwOffset, &bySkipFlag, sizeof(bySkipFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBeAttackerIdxNum);
	memcpy(pDataBuff + dwOffset, &byBeAttackerIdxNum, sizeof(byBeAttackerIdxNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBeAttackerIdxNum > MAX_FORMATION_IDX_NUM)
	{
		byBeAttackerIdxNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBeAttackerIdxNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBeAttackerIdxNum; i++)
	{
		dwContextLenTmp += astBeAttackerIdxInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stBeforeAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stAfterAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stGodweaponAttackInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byAttackSpecialEffectFlag);
	memcpy(pDataBuff + dwOffset, &byAttackSpecialEffectFlag, sizeof(byAttackSpecialEffectFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byEnemySpecialEffectFlag);
	memcpy(pDataBuff + dwOffset, &byEnemySpecialEffectFlag, sizeof(byEnemySpecialEffectFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_ALL_DATA4::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerIdx, 0, sizeof(byAttackerIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAttackSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttackSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttackSkillID, 0, sizeof(wAttackSkillID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(bySkipFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkipFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkipFlag, 0, sizeof(bySkipFlag));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBeAttackerIdxNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeAttackerIdxNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeAttackerIdxNum, 0, sizeof(byBeAttackerIdxNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBeAttackerIdxNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byBeAttackerIdxNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBeAttackerIdxInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
				}
			}
			break;
		case 7:
			{
				stBeforeAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stAfterAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stGodweaponAttackInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 10:
			{
				if(sizeof(byAttackSpecialEffectFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackSpecialEffectFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackSpecialEffectFlag, 0, sizeof(byAttackSpecialEffectFlag));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byEnemySpecialEffectFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byEnemySpecialEffectFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEnemySpecialEffectFlag, 0, sizeof(byEnemySpecialEffectFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ROUND_DATA4(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA4 *pstIn = (DT_BATTLE_ROUND_DATA4*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerFlag))
		return -1;

	if(-1 == EncodeDT_ATTACK_ALL_DATA4(&pstIn->stAttackData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ROUND_DATA4(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA4 *pstOut = (DT_BATTLE_ROUND_DATA4*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerFlag))
		return -1;

	if(-1 == DecodeDT_ATTACK_ALL_DATA4(&pstOut->stAttackData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ROUND_DATA4(DT_BATTLE_ROUND_DATA4 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerFlag", (double)(data.byAttackerFlag));
	cJSON_AddItemToObject(root, "AttackData", GetJsonDT_ATTACK_ALL_DATA4(data.stAttackData));

	return root;
}

INT32 DT_BATTLE_ROUND_DATA4::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerFlag);
	memcpy(pDataBuff + dwOffset, &byAttackerFlag, sizeof(byAttackerFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stAttackData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ROUND_DATA4::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerFlag, 0, sizeof(byAttackerFlag));
				}
			}
			break;
		case 2:
			{
				stAttackData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_DATA4(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA4 *pstIn = (DT_BATTLE_DATA4*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA2(&pstIn->stMyselfInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA2(&pstIn->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleRoundNum)
			break;
		if(-1 == EncodeDT_BATTLE_ROUND_DATA4(&pstIn->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_DATA4(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA4 *pstOut = (DT_BATTLE_DATA4*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA2(&pstOut->stMyselfInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA2(&pstOut->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleRoundNum)
			break;
		if(-1 == DecodeDT_BATTLE_ROUND_DATA4(&pstOut->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_DATA4(DT_BATTLE_DATA4 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA2(data.stMyselfInfo));
	cJSON_AddItemToObject(root, "EnemyInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA2(data.stEnemyInfo));
	cJSON_AddNumberToObject(root,"BattleResult", (double)(data.byBattleResult));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));
	cJSON_AddNumberToObject(root,"BattleRoundNum", (double)(data.byBattleRoundNum));
	cJSON *BattleRoundInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleRoundInfo", BattleRoundInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleRoundNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleRoundInfo, " ", GetJsonDT_BATTLE_ROUND_DATA4(data.astBattleRoundInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "MyselfInfoAfterBattle", GetJsonDT_BATTLE_ATTRIBUTE(data.stMyselfInfoAfterBattle));

	return root;
}

INT32 DT_BATTLE_DATA4::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBattleResult);
	memcpy(pDataBuff + dwOffset, &byBattleResult, sizeof(byBattleResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBattleRoundNum);
	memcpy(pDataBuff + dwOffset, &byBattleRoundNum, sizeof(byBattleRoundNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBattleRoundNum > MAX_NEW_BATTLE_ROUND_NUM)
	{
		byBattleRoundNum = MAX_NEW_BATTLE_ROUND_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleRoundNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleRoundNum; i++)
	{
		dwContextLenTmp += astBattleRoundInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stMyselfInfoAfterBattle.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_DATA4::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(byBattleResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleResult, 0, sizeof(byBattleResult));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBattleRoundNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleRoundNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleRoundNum, 0, sizeof(byBattleRoundNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleRoundNum)
				{
					wArrNum = wArrNum <= MAX_NEW_BATTLE_ROUND_NUM ? wArrNum : MAX_NEW_BATTLE_ROUND_NUM;
					byBattleRoundNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleRoundInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
				}
			}
			break;
		case 7:
			{
				stMyselfInfoAfterBattle.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ATTACK_ALL_DATA5(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA5 *pstIn = (DT_ATTACK_ALL_DATA5*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttackSkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySkipFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBeAttackerIdxNum)
			break;
		if(-1 == EncodeDT_PARRY_DATA2(&pstIn->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_ATTACK_DATA3(&pstIn->stBeforeAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_ATTACK_DATA3(&pstIn->stAfterAttack, poNetData))
		return -1;

	if(-1 == EncodeDT_GODWEAPON_ATTACK_DATA2(&pstIn->stGodweaponAttackInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAttackSpecialEffectFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byEnemySpecialEffectFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPetAttack))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPetSkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAttackObj))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ATTACK_ALL_DATA5(void *pHost, CNetData* poNetData)
{
	DT_ATTACK_ALL_DATA5 *pstOut = (DT_ATTACK_ALL_DATA5*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttackSkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySkipFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeAttackerIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBeAttackerIdxNum)
			break;
		if(-1 == DecodeDT_PARRY_DATA2(&pstOut->astBeAttackerIdxInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_ATTACK_DATA3(&pstOut->stBeforeAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_ATTACK_DATA3(&pstOut->stAfterAttack, poNetData))
		return -1;

	if(-1 == DecodeDT_GODWEAPON_ATTACK_DATA2(&pstOut->stGodweaponAttackInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAttackSpecialEffectFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byEnemySpecialEffectFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPetAttack))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPetSkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAttackObj))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ATTACK_ALL_DATA5(DT_ATTACK_ALL_DATA5 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerIdx", (double)(data.byAttackerIdx));
	cJSON_AddNumberToObject(root,"AttackSkillID", (double)(data.wAttackSkillID));
	cJSON_AddNumberToObject(root,"SkipFlag", (double)(data.bySkipFlag));
	cJSON_AddNumberToObject(root,"BeAttackerIdxNum", (double)(data.byBeAttackerIdxNum));
	cJSON *BeAttackerIdxInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BeAttackerIdxInfo", BeAttackerIdxInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBeAttackerIdxNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BeAttackerIdxInfo, " ", GetJsonDT_PARRY_DATA2(data.astBeAttackerIdxInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "BeforeAttack", GetJsonDT_ATTACK_DATA3(data.stBeforeAttack));
	cJSON_AddItemToObject(root, "AfterAttack", GetJsonDT_ATTACK_DATA3(data.stAfterAttack));
	cJSON_AddItemToObject(root, "GodweaponAttackInfo", GetJsonDT_GODWEAPON_ATTACK_DATA2(data.stGodweaponAttackInfo));
	cJSON_AddNumberToObject(root,"AttackSpecialEffectFlag", (double)(data.byAttackSpecialEffectFlag));
	cJSON_AddNumberToObject(root,"EnemySpecialEffectFlag", (double)(data.byEnemySpecialEffectFlag));
	cJSON_AddNumberToObject(root,"PetAttack", (double)(data.byPetAttack));
	cJSON_AddNumberToObject(root,"PetSkillID", (double)(data.wPetSkillID));
	cJSON_AddNumberToObject(root,"AttackObj", (double)(data.byAttackObj));

	return root;
}

INT32 DT_ATTACK_ALL_DATA5::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 13;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerIdx);
	memcpy(pDataBuff + dwOffset, &byAttackerIdx, sizeof(byAttackerIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wAttackSkillID);
	memcpy(pDataBuff + dwOffset, &wAttackSkillID, sizeof(wAttackSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(bySkipFlag);
	memcpy(pDataBuff + dwOffset, &bySkipFlag, sizeof(bySkipFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBeAttackerIdxNum);
	memcpy(pDataBuff + dwOffset, &byBeAttackerIdxNum, sizeof(byBeAttackerIdxNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBeAttackerIdxNum > MAX_FORMATION_IDX_NUM)
	{
		byBeAttackerIdxNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBeAttackerIdxNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBeAttackerIdxNum; i++)
	{
		dwContextLenTmp += astBeAttackerIdxInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stBeforeAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stAfterAttack.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stGodweaponAttackInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byAttackSpecialEffectFlag);
	memcpy(pDataBuff + dwOffset, &byAttackSpecialEffectFlag, sizeof(byAttackSpecialEffectFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byEnemySpecialEffectFlag);
	memcpy(pDataBuff + dwOffset, &byEnemySpecialEffectFlag, sizeof(byEnemySpecialEffectFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(byPetAttack);
	memcpy(pDataBuff + dwOffset, &byPetAttack, sizeof(byPetAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(wPetSkillID);
	memcpy(pDataBuff + dwOffset, &wPetSkillID, sizeof(wPetSkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(byAttackObj);
	memcpy(pDataBuff + dwOffset, &byAttackObj, sizeof(byAttackObj));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ATTACK_ALL_DATA5::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerIdx, 0, sizeof(byAttackerIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wAttackSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttackSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttackSkillID, 0, sizeof(wAttackSkillID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(bySkipFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkipFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkipFlag, 0, sizeof(bySkipFlag));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBeAttackerIdxNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeAttackerIdxNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeAttackerIdxNum, 0, sizeof(byBeAttackerIdxNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBeAttackerIdxNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byBeAttackerIdxNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBeAttackerIdxInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBeAttackerIdxInfo, 0, sizeof(astBeAttackerIdxInfo));
				}
			}
			break;
		case 7:
			{
				stBeforeAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stAfterAttack.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stGodweaponAttackInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 10:
			{
				if(sizeof(byAttackSpecialEffectFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackSpecialEffectFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackSpecialEffectFlag, 0, sizeof(byAttackSpecialEffectFlag));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byEnemySpecialEffectFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byEnemySpecialEffectFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEnemySpecialEffectFlag, 0, sizeof(byEnemySpecialEffectFlag));
				}
			}
			break;
		case 12:
			{
				if(sizeof(byPetAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&byPetAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPetAttack, 0, sizeof(byPetAttack));
				}
			}
			break;
		case 13:
			{
				if(sizeof(wPetSkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetSkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetSkillID, 0, sizeof(wPetSkillID));
				}
			}
			break;
		case 14:
			{
				if(sizeof(byAttackObj) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackObj, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackObj, 0, sizeof(byAttackObj));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_ROUND_DATA5(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA5 *pstIn = (DT_BATTLE_ROUND_DATA5*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byAttackerFlag))
		return -1;

	if(-1 == EncodeDT_ATTACK_ALL_DATA5(&pstIn->stAttackData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_ROUND_DATA5(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_ROUND_DATA5 *pstOut = (DT_BATTLE_ROUND_DATA5*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byAttackerFlag))
		return -1;

	if(-1 == DecodeDT_ATTACK_ALL_DATA5(&pstOut->stAttackData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_ROUND_DATA5(DT_BATTLE_ROUND_DATA5 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttackerFlag", (double)(data.byAttackerFlag));
	cJSON_AddItemToObject(root, "AttackData", GetJsonDT_ATTACK_ALL_DATA5(data.stAttackData));

	return root;
}

INT32 DT_BATTLE_ROUND_DATA5::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byAttackerFlag);
	memcpy(pDataBuff + dwOffset, &byAttackerFlag, sizeof(byAttackerFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stAttackData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_ROUND_DATA5::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byAttackerFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byAttackerFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAttackerFlag, 0, sizeof(byAttackerFlag));
				}
			}
			break;
		case 2:
			{
				stAttackData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PET_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_BATTLE_DATA *pstIn = (DT_PET_BATTLE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPetID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPetLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPetQuality))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PET_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_BATTLE_DATA *pstOut = (DT_PET_BATTLE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPetID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPetLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPetQuality))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PET_BATTLE_DATA(DT_PET_BATTLE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PetID", (double)(data.wPetID));
	cJSON_AddNumberToObject(root,"PetLevel", (double)(data.wPetLevel));
	cJSON_AddNumberToObject(root,"PetQuality", (double)(data.byPetQuality));

	return root;
}

INT32 DT_PET_BATTLE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPetID);
	memcpy(pDataBuff + dwOffset, &wPetID, sizeof(wPetID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wPetLevel);
	memcpy(pDataBuff + dwOffset, &wPetLevel, sizeof(wPetLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byPetQuality);
	memcpy(pDataBuff + dwOffset, &byPetQuality, sizeof(byPetQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PET_BATTLE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPetID) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetID, 0, sizeof(wPetID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wPetLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetLevel, 0, sizeof(wPetLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byPetQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&byPetQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPetQuality, 0, sizeof(byPetQuality));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_OBJ_GROUP_DATA3(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_GROUP_DATA3 *pstIn = (DT_BATTLE_OBJ_GROUP_DATA3*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byObjNum)
			break;
		if(-1 == EncodeDT_BATTLE_OBJ_DATA2(&pstIn->astBattleObjInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddTString(pstIn->aszDispName, sizeof(pstIn->aszDispName)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == EncodeDT_PET_BATTLE_DATA(&pstIn->stPetInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_OBJ_GROUP_DATA3(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_GROUP_DATA3 *pstOut = (DT_BATTLE_OBJ_GROUP_DATA3*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byObjNum)
			break;
		if(-1 == DecodeDT_BATTLE_OBJ_DATA2(&pstOut->astBattleObjInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelTString(pstOut->aszDispName, sizeof(pstOut->aszDispName)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == DecodeDT_PET_BATTLE_DATA(&pstOut->stPetInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_OBJ_GROUP_DATA3(DT_BATTLE_OBJ_GROUP_DATA3 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ObjNum", (double)(data.byObjNum));
	cJSON *BattleObjInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleObjInfo", BattleObjInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byObjNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleObjInfo, " ", GetJsonDT_BATTLE_OBJ_DATA2(data.astBattleObjInfo[dwIndex]));
	}
	cJSON_AddStringToObject(root,"DispName", data.aszDispName );
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddItemToObject(root, "PetInfo", GetJsonDT_PET_BATTLE_DATA(data.stPetInfo));

	return root;
}

INT32 DT_BATTLE_OBJ_GROUP_DATA3::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byObjNum);
	memcpy(pDataBuff + dwOffset, &byObjNum, sizeof(byObjNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byObjNum > MAX_FORMATION_IDX_NUM)
	{
		byObjNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byObjNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byObjNum; i++)
	{
		dwContextLenTmp += astBattleObjInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszDispName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispName, sizeof(aszDispName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stPetInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_OBJ_GROUP_DATA3::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byObjNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byObjNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byObjNum, 0, sizeof(byObjNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byObjNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byObjNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleObjInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleObjInfo, 0, sizeof(astBattleObjInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleObjInfo, 0, sizeof(astBattleObjInfo));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispName, 0, sizeof(aszDispName));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 5:
			{
				stPetInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_DATA5(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA5 *pstIn = (DT_BATTLE_DATA5*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA3(&pstIn->stMyselfInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA3(&pstIn->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleRoundNum)
			break;
		if(-1 == EncodeDT_BATTLE_ROUND_DATA5(&pstIn->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_BATTLE_ATTRIBUTE(&pstIn->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_DATA5(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_DATA5 *pstOut = (DT_BATTLE_DATA5*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA3(&pstOut->stMyselfInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA3(&pstOut->stEnemyInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleRoundNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_BATTLE_ROUND_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleRoundNum)
			break;
		if(-1 == DecodeDT_BATTLE_ROUND_DATA5(&pstOut->astBattleRoundInfo[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_BATTLE_ATTRIBUTE(&pstOut->stMyselfInfoAfterBattle, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_DATA5(DT_BATTLE_DATA5 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA3(data.stMyselfInfo));
	cJSON_AddItemToObject(root, "EnemyInfo", GetJsonDT_BATTLE_OBJ_GROUP_DATA3(data.stEnemyInfo));
	cJSON_AddNumberToObject(root,"BattleResult", (double)(data.byBattleResult));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));
	cJSON_AddNumberToObject(root,"BattleRoundNum", (double)(data.byBattleRoundNum));
	cJSON *BattleRoundInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleRoundInfo", BattleRoundInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleRoundNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleRoundInfo, " ", GetJsonDT_BATTLE_ROUND_DATA5(data.astBattleRoundInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "MyselfInfoAfterBattle", GetJsonDT_BATTLE_ATTRIBUTE(data.stMyselfInfoAfterBattle));

	return root;
}

INT32 DT_BATTLE_DATA5::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBattleResult);
	memcpy(pDataBuff + dwOffset, &byBattleResult, sizeof(byBattleResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBattleRoundNum);
	memcpy(pDataBuff + dwOffset, &byBattleRoundNum, sizeof(byBattleRoundNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(byBattleRoundNum > MAX_NEW_BATTLE_ROUND_NUM)
	{
		byBattleRoundNum = MAX_NEW_BATTLE_ROUND_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleRoundNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleRoundNum; i++)
	{
		dwContextLenTmp += astBattleRoundInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stMyselfInfoAfterBattle.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_DATA5::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(byBattleResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleResult, 0, sizeof(byBattleResult));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBattleRoundNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleRoundNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleRoundNum, 0, sizeof(byBattleRoundNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleRoundNum)
				{
					wArrNum = wArrNum <= MAX_NEW_BATTLE_ROUND_NUM ? wArrNum : MAX_NEW_BATTLE_ROUND_NUM;
					byBattleRoundNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleRoundInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleRoundInfo, 0, sizeof(astBattleRoundInfo));
				}
			}
			break;
		case 7:
			{
				stMyselfInfoAfterBattle.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_OBJ_MAX_HP(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_MAX_HP *pstIn = (DT_BATTLE_OBJ_MAX_HP*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFomationIdx))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwMaxHP))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_OBJ_MAX_HP(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_MAX_HP *pstOut = (DT_BATTLE_OBJ_MAX_HP*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFomationIdx))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwMaxHP))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_OBJ_MAX_HP(DT_BATTLE_OBJ_MAX_HP &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FomationIdx", (double)(data.byFomationIdx));
	cJSON_AddNumberToObject(root,"MaxHP", (double)(data.dwMaxHP));

	return root;
}

INT32 DT_BATTLE_OBJ_MAX_HP::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFomationIdx);
	memcpy(pDataBuff + dwOffset, &byFomationIdx, sizeof(byFomationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwMaxHP);
	memcpy(pDataBuff + dwOffset, &dwMaxHP, sizeof(dwMaxHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_OBJ_MAX_HP::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFomationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFomationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFomationIdx, 0, sizeof(byFomationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwMaxHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwMaxHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwMaxHP, 0, sizeof(dwMaxHP));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_OBJ_MAX_HP_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_MAX_HP_INFO *pstIn = (DT_BATTLE_OBJ_MAX_HP_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byObjNum)
			break;
		if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP(&pstIn->astBattleObjMaxHPInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_OBJ_MAX_HP_INFO(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_OBJ_MAX_HP_INFO *pstOut = (DT_BATTLE_OBJ_MAX_HP_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byObjNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byObjNum)
			break;
		if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP(&pstOut->astBattleObjMaxHPInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(DT_BATTLE_OBJ_MAX_HP_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ObjNum", (double)(data.byObjNum));
	cJSON *BattleObjMaxHPInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleObjMaxHPInfo", BattleObjMaxHPInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byObjNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleObjMaxHPInfo, " ", GetJsonDT_BATTLE_OBJ_MAX_HP(data.astBattleObjMaxHPInfo[dwIndex]));
	}

	return root;
}

INT32 DT_BATTLE_OBJ_MAX_HP_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byObjNum);
	memcpy(pDataBuff + dwOffset, &byObjNum, sizeof(byObjNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byObjNum > MAX_FORMATION_IDX_NUM)
	{
		byObjNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byObjNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byObjNum; i++)
	{
		dwContextLenTmp += astBattleObjMaxHPInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_OBJ_MAX_HP_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byObjNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byObjNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byObjNum, 0, sizeof(byObjNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byObjNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byObjNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleObjMaxHPInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleObjMaxHPInfo, 0, sizeof(astBattleObjMaxHPInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleObjMaxHPInfo, 0, sizeof(astBattleObjMaxHPInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EMPTY_HP_VIDEO_v400(void *pHost, CNetData* poNetData)
{
	DT_EMPTY_HP_VIDEO_v400 *pstIn = (DT_EMPTY_HP_VIDEO_v400*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stMyselfMaxHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stEnemyMaxHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stMyselfBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stEnemyBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_DATA4(&pstIn->stEmptyHPVideo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EMPTY_HP_VIDEO_v400(void *pHost, CNetData* poNetData)
{
	DT_EMPTY_HP_VIDEO_v400 *pstOut = (DT_EMPTY_HP_VIDEO_v400*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stMyselfMaxHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stEnemyMaxHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stMyselfBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stEnemyBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_DATA4(&pstOut->stEmptyHPVideo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EMPTY_HP_VIDEO_v400(DT_EMPTY_HP_VIDEO_v400 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfMaxHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stMyselfMaxHPInfo));
	cJSON_AddItemToObject(root, "EnemyMaxHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stEnemyMaxHPInfo));
	cJSON_AddItemToObject(root, "MyselfBeforeRecoverHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stMyselfBeforeRecoverHPInfo));
	cJSON_AddItemToObject(root, "EnemyBeforeRecoverHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stEnemyBeforeRecoverHPInfo));
	cJSON_AddItemToObject(root, "EmptyHPVideo", GetJsonDT_BATTLE_DATA4(data.stEmptyHPVideo));

	return root;
}

INT32 DT_EMPTY_HP_VIDEO_v400::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfMaxHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyMaxHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stMyselfBeforeRecoverHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stEnemyBeforeRecoverHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stEmptyHPVideo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EMPTY_HP_VIDEO_v400::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfMaxHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyMaxHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stMyselfBeforeRecoverHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stEnemyBeforeRecoverHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stEmptyHPVideo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EMPTY_HP_VIDEO(void *pHost, CNetData* poNetData)
{
	DT_EMPTY_HP_VIDEO *pstIn = (DT_EMPTY_HP_VIDEO*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stMyselfMaxHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stEnemyMaxHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stMyselfBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstIn->stEnemyBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_DATA5(&pstIn->stEmptyHPVideo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EMPTY_HP_VIDEO(void *pHost, CNetData* poNetData)
{
	DT_EMPTY_HP_VIDEO *pstOut = (DT_EMPTY_HP_VIDEO*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stMyselfMaxHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stEnemyMaxHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stMyselfBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_MAX_HP_INFO(&pstOut->stEnemyBeforeRecoverHPInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_DATA5(&pstOut->stEmptyHPVideo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EMPTY_HP_VIDEO(DT_EMPTY_HP_VIDEO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfMaxHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stMyselfMaxHPInfo));
	cJSON_AddItemToObject(root, "EnemyMaxHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stEnemyMaxHPInfo));
	cJSON_AddItemToObject(root, "MyselfBeforeRecoverHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stMyselfBeforeRecoverHPInfo));
	cJSON_AddItemToObject(root, "EnemyBeforeRecoverHPInfo", GetJsonDT_BATTLE_OBJ_MAX_HP_INFO(data.stEnemyBeforeRecoverHPInfo));
	cJSON_AddItemToObject(root, "EmptyHPVideo", GetJsonDT_BATTLE_DATA5(data.stEmptyHPVideo));

	return root;
}

INT32 DT_EMPTY_HP_VIDEO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfMaxHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyMaxHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stMyselfBeforeRecoverHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stEnemyBeforeRecoverHPInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stEmptyHPVideo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EMPTY_HP_VIDEO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfMaxHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyMaxHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stMyselfBeforeRecoverHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stEnemyBeforeRecoverHPInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stEmptyHPVideo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FINAL_ROUND_BATTLE_OBJ_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_ROUND_BATTLE_OBJ_INFO *pstIn = (DT_FINAL_ROUND_BATTLE_OBJ_INFO*)pHost;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA3(&pstIn->stMyselfObj, poNetData))
		return -1;

	if(-1 == EncodeDT_BATTLE_OBJ_GROUP_DATA3(&pstIn->stEnemyObj, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FINAL_ROUND_BATTLE_OBJ_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_ROUND_BATTLE_OBJ_INFO *pstOut = (DT_FINAL_ROUND_BATTLE_OBJ_INFO*)pHost;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA3(&pstOut->stMyselfObj, poNetData))
		return -1;

	if(-1 == DecodeDT_BATTLE_OBJ_GROUP_DATA3(&pstOut->stEnemyObj, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FINAL_ROUND_BATTLE_OBJ_INFO(DT_FINAL_ROUND_BATTLE_OBJ_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "MyselfObj", GetJsonDT_BATTLE_OBJ_GROUP_DATA3(data.stMyselfObj));
	cJSON_AddItemToObject(root, "EnemyObj", GetJsonDT_BATTLE_OBJ_GROUP_DATA3(data.stEnemyObj));

	return root;
}

INT32 DT_FINAL_ROUND_BATTLE_OBJ_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stMyselfObj.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEnemyObj.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FINAL_ROUND_BATTLE_OBJ_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stMyselfObj.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEnemyObj.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ONLINE_ENCOURAGE_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_ONLINE_ENCOURAGE_RECORD_DATA *pstIn = (DT_ONLINE_ENCOURAGE_RECORD_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byRecvDays))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastRecvTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastRecvIndex))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ONLINE_ENCOURAGE_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_ONLINE_ENCOURAGE_RECORD_DATA *pstOut = (DT_ONLINE_ENCOURAGE_RECORD_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byRecvDays))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastRecvTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastRecvIndex))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ONLINE_ENCOURAGE_RECORD_DATA(DT_ONLINE_ENCOURAGE_RECORD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RecvDays", (double)(data.byRecvDays));
	cJSON_AddNumberToObject(root,"LastRecvTime", (double)(data.qwLastRecvTime));
	cJSON_AddNumberToObject(root,"LastRecvIndex", (double)(data.byLastRecvIndex));

	return root;
}

INT32 DT_ONLINE_ENCOURAGE_RECORD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byRecvDays);
	memcpy(pDataBuff + dwOffset, &byRecvDays, sizeof(byRecvDays));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastRecvTime);
	memcpy(pDataBuff + dwOffset, &qwLastRecvTime, sizeof(qwLastRecvTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byLastRecvIndex);
	memcpy(pDataBuff + dwOffset, &byLastRecvIndex, sizeof(byLastRecvIndex));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ONLINE_ENCOURAGE_RECORD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byRecvDays) >= pstIndex->dwContextLen)
				{
					memcpy(&byRecvDays, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRecvDays, 0, sizeof(byRecvDays));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLastRecvTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastRecvTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastRecvTime, 0, sizeof(qwLastRecvTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byLastRecvIndex) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastRecvIndex, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastRecvIndex, 0, sizeof(byLastRecvIndex));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LOGIN_ENCOURAGE_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_LOGIN_ENCOURAGE_RECORD_DATA *pstIn = (DT_LOGIN_ENCOURAGE_RECORD_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKeepDays))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastRecvNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastRecvTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastSelectIndex))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byStateFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOGIN_ENCOURAGE_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_LOGIN_ENCOURAGE_RECORD_DATA *pstOut = (DT_LOGIN_ENCOURAGE_RECORD_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKeepDays))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastRecvNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastRecvTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastSelectIndex))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byStateFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOGIN_ENCOURAGE_RECORD_DATA(DT_LOGIN_ENCOURAGE_RECORD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KeepDays", (double)(data.wKeepDays));
	cJSON_AddNumberToObject(root,"LastRecvNum", (double)(data.byLastRecvNum));
	cJSON_AddNumberToObject(root,"LastRecvTime", (double)(data.qwLastRecvTime));
	cJSON_AddNumberToObject(root,"LastSelectIndex", (double)(data.byLastSelectIndex));
	cJSON_AddNumberToObject(root,"StateFlag", (double)(data.byStateFlag));

	return root;
}

INT32 DT_LOGIN_ENCOURAGE_RECORD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKeepDays);
	memcpy(pDataBuff + dwOffset, &wKeepDays, sizeof(wKeepDays));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byLastRecvNum);
	memcpy(pDataBuff + dwOffset, &byLastRecvNum, sizeof(byLastRecvNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastRecvTime);
	memcpy(pDataBuff + dwOffset, &qwLastRecvTime, sizeof(qwLastRecvTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byLastSelectIndex);
	memcpy(pDataBuff + dwOffset, &byLastSelectIndex, sizeof(byLastSelectIndex));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byStateFlag);
	memcpy(pDataBuff + dwOffset, &byStateFlag, sizeof(byStateFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOGIN_ENCOURAGE_RECORD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKeepDays) >= pstIndex->dwContextLen)
				{
					memcpy(&wKeepDays, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKeepDays, 0, sizeof(wKeepDays));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byLastRecvNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastRecvNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastRecvNum, 0, sizeof(byLastRecvNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastRecvTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastRecvTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastRecvTime, 0, sizeof(qwLastRecvTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byLastSelectIndex) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastSelectIndex, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastSelectIndex, 0, sizeof(byLastSelectIndex));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byStateFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byStateFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStateFlag, 0, sizeof(byStateFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RACE_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_RACE_BATTLELOG_DATA *pstIn = (DT_RACE_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byChallengeFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwChallengeTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEnemyPlayerID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byResult))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwBeginChallengeRank))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAfterChallengeRank))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNewFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RACE_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_RACE_BATTLELOG_DATA *pstOut = (DT_RACE_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byChallengeFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwChallengeTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEnemyPlayerID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byResult))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwBeginChallengeRank))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAfterChallengeRank))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNewFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RACE_BATTLELOG_DATA(DT_RACE_BATTLELOG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ChallengeFlag", (double)(data.byChallengeFlag));
	cJSON_AddNumberToObject(root,"ChallengeTime", (double)(data.qwChallengeTime));
	cJSON_AddNumberToObject(root,"EnemyPlayerID", (double)(data.dwEnemyPlayerID));
	cJSON_AddNumberToObject(root,"Result", (double)(data.byResult));
	cJSON_AddNumberToObject(root,"BeginChallengeRank", (double)(data.dwBeginChallengeRank));
	cJSON_AddNumberToObject(root,"AfterChallengeRank", (double)(data.dwAfterChallengeRank));
	cJSON_AddNumberToObject(root,"NewFlag", (double)(data.byNewFlag));

	return root;
}

INT32 DT_RACE_BATTLELOG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byChallengeFlag);
	memcpy(pDataBuff + dwOffset, &byChallengeFlag, sizeof(byChallengeFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwChallengeTime);
	memcpy(pDataBuff + dwOffset, &qwChallengeTime, sizeof(qwChallengeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwEnemyPlayerID);
	memcpy(pDataBuff + dwOffset, &dwEnemyPlayerID, sizeof(dwEnemyPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byResult);
	memcpy(pDataBuff + dwOffset, &byResult, sizeof(byResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwBeginChallengeRank);
	memcpy(pDataBuff + dwOffset, &dwBeginChallengeRank, sizeof(dwBeginChallengeRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwAfterChallengeRank);
	memcpy(pDataBuff + dwOffset, &dwAfterChallengeRank, sizeof(dwAfterChallengeRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byNewFlag);
	memcpy(pDataBuff + dwOffset, &byNewFlag, sizeof(byNewFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RACE_BATTLELOG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byChallengeFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byChallengeFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChallengeFlag, 0, sizeof(byChallengeFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwChallengeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwChallengeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwChallengeTime, 0, sizeof(qwChallengeTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwEnemyPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEnemyPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEnemyPlayerID, 0, sizeof(dwEnemyPlayerID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResult, 0, sizeof(byResult));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwBeginChallengeRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBeginChallengeRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBeginChallengeRank, 0, sizeof(dwBeginChallengeRank));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwAfterChallengeRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAfterChallengeRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAfterChallengeRank, 0, sizeof(dwAfterChallengeRank));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byNewFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byNewFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNewFlag, 0, sizeof(byNewFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RACE_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_RACE_BATTLELOG_DATA_LIST *pstIn = (DT_RACE_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBattleLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RACE_BATTLELOG_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleLogNum)
			break;
		if(-1 == EncodeDT_RACE_BATTLELOG_DATA(&pstIn->astBattleLogInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RACE_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_RACE_BATTLELOG_DATA_LIST *pstOut = (DT_RACE_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBattleLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RACE_BATTLELOG_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleLogNum)
			break;
		if(-1 == DecodeDT_RACE_BATTLELOG_DATA(&pstOut->astBattleLogInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RACE_BATTLELOG_DATA_LIST(DT_RACE_BATTLELOG_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BattleLogNum", (double)(data.byBattleLogNum));
	cJSON *BattleLogInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleLogInfo", BattleLogInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleLogInfo, " ", GetJsonDT_RACE_BATTLELOG_DATA(data.astBattleLogInfo[dwIndex]));
	}

	return root;
}

INT32 DT_RACE_BATTLELOG_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBattleLogNum);
	memcpy(pDataBuff + dwOffset, &byBattleLogNum, sizeof(byBattleLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byBattleLogNum > MAX_RACE_BATTLELOG_NUM)
	{
		byBattleLogNum = MAX_RACE_BATTLELOG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleLogNum; i++)
	{
		dwContextLenTmp += astBattleLogInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RACE_BATTLELOG_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBattleLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleLogNum, 0, sizeof(byBattleLogNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleLogNum)
				{
					wArrNum = wArrNum <= MAX_RACE_BATTLELOG_NUM ? wArrNum : MAX_RACE_BATTLELOG_NUM;
					byBattleLogNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleLogInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleLogInfo, 0, sizeof(astBattleLogInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleLogInfo, 0, sizeof(astBattleLogInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CAPTURE_DATA(void *pHost, CNetData* poNetData)
{
	DT_CAPTURE_DATA *pstIn = (DT_CAPTURE_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwCapturePlayerID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwCaptureTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCaptureGridIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIncomeType))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastCollectTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CAPTURE_DATA(void *pHost, CNetData* poNetData)
{
	DT_CAPTURE_DATA *pstOut = (DT_CAPTURE_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwCapturePlayerID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwCaptureTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCaptureGridIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIncomeType))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastCollectTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CAPTURE_DATA(DT_CAPTURE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CapturePlayerID", (double)(data.dwCapturePlayerID));
	cJSON_AddNumberToObject(root,"CaptureTime", (double)(data.qwCaptureTime));
	cJSON_AddNumberToObject(root,"CaptureGridIdx", (double)(data.byCaptureGridIdx));
	cJSON_AddNumberToObject(root,"IncomeType", (double)(data.byIncomeType));
	cJSON_AddNumberToObject(root,"LastCollectTime", (double)(data.qwLastCollectTime));

	return root;
}

INT32 DT_CAPTURE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwCapturePlayerID);
	memcpy(pDataBuff + dwOffset, &dwCapturePlayerID, sizeof(dwCapturePlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwCaptureTime);
	memcpy(pDataBuff + dwOffset, &qwCaptureTime, sizeof(qwCaptureTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byCaptureGridIdx);
	memcpy(pDataBuff + dwOffset, &byCaptureGridIdx, sizeof(byCaptureGridIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byIncomeType);
	memcpy(pDataBuff + dwOffset, &byIncomeType, sizeof(byIncomeType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwLastCollectTime);
	memcpy(pDataBuff + dwOffset, &qwLastCollectTime, sizeof(qwLastCollectTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CAPTURE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwCapturePlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCapturePlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCapturePlayerID, 0, sizeof(dwCapturePlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwCaptureTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwCaptureTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwCaptureTime, 0, sizeof(qwCaptureTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byCaptureGridIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byCaptureGridIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCaptureGridIdx, 0, sizeof(byCaptureGridIdx));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byIncomeType) >= pstIndex->dwContextLen)
				{
					memcpy(&byIncomeType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIncomeType, 0, sizeof(byIncomeType));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwLastCollectTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastCollectTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastCollectTime, 0, sizeof(qwLastCollectTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CAPTURE_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_CAPTURE_DATA_LIST *pstIn = (DT_CAPTURE_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byCaptureNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_CAPTURE_NUM; i++)
	{
		if(i >= (INT32)pstIn->byCaptureNum)
			break;
		if(-1 == EncodeDT_CAPTURE_DATA(&pstIn->astCaptureInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CAPTURE_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_CAPTURE_DATA_LIST *pstOut = (DT_CAPTURE_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byCaptureNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_CAPTURE_NUM; i++)
	{
		if(i >= (INT32)pstOut->byCaptureNum)
			break;
		if(-1 == DecodeDT_CAPTURE_DATA(&pstOut->astCaptureInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CAPTURE_DATA_LIST(DT_CAPTURE_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CaptureNum", (double)(data.byCaptureNum));
	cJSON *CaptureInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "CaptureInfo", CaptureInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byCaptureNum; ++dwIndex)
	{
		cJSON_AddItemToObject(CaptureInfo, " ", GetJsonDT_CAPTURE_DATA(data.astCaptureInfo[dwIndex]));
	}

	return root;
}

INT32 DT_CAPTURE_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byCaptureNum);
	memcpy(pDataBuff + dwOffset, &byCaptureNum, sizeof(byCaptureNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byCaptureNum > MAX_CAPTURE_NUM)
	{
		byCaptureNum = MAX_CAPTURE_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byCaptureNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byCaptureNum; i++)
	{
		dwContextLenTmp += astCaptureInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CAPTURE_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byCaptureNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byCaptureNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCaptureNum, 0, sizeof(byCaptureNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byCaptureNum)
				{
					wArrNum = wArrNum <= MAX_CAPTURE_NUM ? wArrNum : MAX_CAPTURE_NUM;
					byCaptureNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astCaptureInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astCaptureInfo, 0, sizeof(astCaptureInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astCaptureInfo, 0, sizeof(astCaptureInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLUNDER_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_BATTLELOG_DATA *pstIn = (DT_PLUNDER_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPlunderFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwPlunderTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwActivePlayerID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPassivePlayerID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCapturePlayerID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byResult))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwPlunderCoin))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwPlunderScience))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNewFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLUNDER_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_BATTLELOG_DATA *pstOut = (DT_PLUNDER_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPlunderFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwPlunderTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwActivePlayerID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPassivePlayerID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCapturePlayerID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byResult))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwPlunderCoin))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwPlunderScience))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNewFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLUNDER_BATTLELOG_DATA(DT_PLUNDER_BATTLELOG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlunderFlag", (double)(data.byPlunderFlag));
	cJSON_AddNumberToObject(root,"PlunderTime", (double)(data.qwPlunderTime));
	cJSON_AddNumberToObject(root,"ActivePlayerID", (double)(data.dwActivePlayerID));
	cJSON_AddNumberToObject(root,"PassivePlayerID", (double)(data.dwPassivePlayerID));
	cJSON_AddNumberToObject(root,"CapturePlayerID", (double)(data.dwCapturePlayerID));
	cJSON_AddNumberToObject(root,"Result", (double)(data.byResult));
	cJSON_AddNumberToObject(root,"PlunderCoin", (double)(data.qwPlunderCoin));
	cJSON_AddNumberToObject(root,"PlunderScience", (double)(data.qwPlunderScience));
	cJSON_AddNumberToObject(root,"NewFlag", (double)(data.byNewFlag));

	return root;
}

INT32 DT_PLUNDER_BATTLELOG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPlunderFlag);
	memcpy(pDataBuff + dwOffset, &byPlunderFlag, sizeof(byPlunderFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwPlunderTime);
	memcpy(pDataBuff + dwOffset, &qwPlunderTime, sizeof(qwPlunderTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwActivePlayerID);
	memcpy(pDataBuff + dwOffset, &dwActivePlayerID, sizeof(dwActivePlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwPassivePlayerID);
	memcpy(pDataBuff + dwOffset, &dwPassivePlayerID, sizeof(dwPassivePlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwCapturePlayerID);
	memcpy(pDataBuff + dwOffset, &dwCapturePlayerID, sizeof(dwCapturePlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byResult);
	memcpy(pDataBuff + dwOffset, &byResult, sizeof(byResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwPlunderCoin);
	memcpy(pDataBuff + dwOffset, &qwPlunderCoin, sizeof(qwPlunderCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(qwPlunderScience);
	memcpy(pDataBuff + dwOffset, &qwPlunderScience, sizeof(qwPlunderScience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byNewFlag);
	memcpy(pDataBuff + dwOffset, &byNewFlag, sizeof(byNewFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLUNDER_BATTLELOG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPlunderFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlunderFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlunderFlag, 0, sizeof(byPlunderFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwPlunderTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwPlunderTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwPlunderTime, 0, sizeof(qwPlunderTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwActivePlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwActivePlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwActivePlayerID, 0, sizeof(dwActivePlayerID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwPassivePlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPassivePlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPassivePlayerID, 0, sizeof(dwPassivePlayerID));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwCapturePlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCapturePlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCapturePlayerID, 0, sizeof(dwCapturePlayerID));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResult, 0, sizeof(byResult));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwPlunderCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&qwPlunderCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwPlunderCoin, 0, sizeof(qwPlunderCoin));
				}
			}
			break;
		case 8:
			{
				if(sizeof(qwPlunderScience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwPlunderScience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwPlunderScience, 0, sizeof(qwPlunderScience));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byNewFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byNewFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNewFlag, 0, sizeof(byNewFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLUNDER_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_BATTLELOG_DATA_LIST *pstIn = (DT_PLUNDER_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBattleLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PLUNDER_BATTLELOG_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleLogNum)
			break;
		if(-1 == EncodeDT_PLUNDER_BATTLELOG_DATA(&pstIn->astBattleLogInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLUNDER_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_BATTLELOG_DATA_LIST *pstOut = (DT_PLUNDER_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBattleLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PLUNDER_BATTLELOG_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleLogNum)
			break;
		if(-1 == DecodeDT_PLUNDER_BATTLELOG_DATA(&pstOut->astBattleLogInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLUNDER_BATTLELOG_DATA_LIST(DT_PLUNDER_BATTLELOG_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BattleLogNum", (double)(data.byBattleLogNum));
	cJSON *BattleLogInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleLogInfo", BattleLogInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleLogInfo, " ", GetJsonDT_PLUNDER_BATTLELOG_DATA(data.astBattleLogInfo[dwIndex]));
	}

	return root;
}

INT32 DT_PLUNDER_BATTLELOG_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBattleLogNum);
	memcpy(pDataBuff + dwOffset, &byBattleLogNum, sizeof(byBattleLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byBattleLogNum > MAX_PLUNDER_BATTLELOG_NUM)
	{
		byBattleLogNum = MAX_PLUNDER_BATTLELOG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleLogNum; i++)
	{
		dwContextLenTmp += astBattleLogInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLUNDER_BATTLELOG_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBattleLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleLogNum, 0, sizeof(byBattleLogNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleLogNum)
				{
					wArrNum = wArrNum <= MAX_PLUNDER_BATTLELOG_NUM ? wArrNum : MAX_PLUNDER_BATTLELOG_NUM;
					byBattleLogNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleLogInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleLogInfo, 0, sizeof(astBattleLogInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleLogInfo, 0, sizeof(astBattleLogInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLUNDER_GRID_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_GRID_DATA *pstIn = (DT_PLUNDER_GRID_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byIncomeType))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwIncomeValue))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLUNDER_GRID_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_GRID_DATA *pstOut = (DT_PLUNDER_GRID_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byIncomeType))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwIncomeValue))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLUNDER_GRID_DATA(DT_PLUNDER_GRID_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"IncomeType", (double)(data.byIncomeType));
	cJSON_AddNumberToObject(root,"IncomeValue", (double)(data.dwIncomeValue));

	return root;
}

INT32 DT_PLUNDER_GRID_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byIncomeType);
	memcpy(pDataBuff + dwOffset, &byIncomeType, sizeof(byIncomeType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwIncomeValue);
	memcpy(pDataBuff + dwOffset, &dwIncomeValue, sizeof(dwIncomeValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLUNDER_GRID_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byIncomeType) >= pstIndex->dwContextLen)
				{
					memcpy(&byIncomeType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIncomeType, 0, sizeof(byIncomeType));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwIncomeValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwIncomeValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwIncomeValue, 0, sizeof(dwIncomeValue));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLUNDER_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_BASE_DATA *pstIn = (DT_PLUNDER_BASE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCaptureOwnerPlayerID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBeCaptureTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wExtPlunderNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastPlunderTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastPlunderNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUnreadBattleLogNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastDriveAwayTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastDriveAwayNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_CAPTURE_NUM; i++)
	{
		if(-1 == EncodeDT_PLUNDER_GRID_DATA(&pstIn->astCaptureGridInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLUNDER_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_BASE_DATA *pstOut = (DT_PLUNDER_BASE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCaptureOwnerPlayerID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBeCaptureTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wExtPlunderNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastPlunderTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastPlunderNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUnreadBattleLogNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastDriveAwayTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastDriveAwayNum))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_CAPTURE_NUM; i++)
		{
			if(-1 == DecodeDT_PLUNDER_GRID_DATA(&pstOut->astCaptureGridInfo[i], poNetData))
				return -1;
		}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLUNDER_BASE_DATA(DT_PLUNDER_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"CaptureOwnerPlayerID", (double)(data.dwCaptureOwnerPlayerID));
	cJSON_AddNumberToObject(root,"BeCaptureTime", (double)(data.qwBeCaptureTime));
	cJSON_AddNumberToObject(root,"ExtPlunderNum", (double)(data.wExtPlunderNum));
	cJSON_AddNumberToObject(root,"LastPlunderTime", (double)(data.qwLastPlunderTime));
	cJSON_AddNumberToObject(root,"LastPlunderNum", (double)(data.wLastPlunderNum));
	cJSON_AddNumberToObject(root,"UnreadBattleLogNum", (double)(data.byUnreadBattleLogNum));
	cJSON_AddNumberToObject(root,"LastDriveAwayTime", (double)(data.qwLastDriveAwayTime));
	cJSON_AddNumberToObject(root,"LastDriveAwayNum", (double)(data.wLastDriveAwayNum));
	cJSON *CaptureGridInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "CaptureGridInfo", CaptureGridInfo);
	for( UINT32 dwIndex=0; dwIndex<MAX_CAPTURE_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(CaptureGridInfo, " ", GetJsonDT_PLUNDER_GRID_DATA(data.astCaptureGridInfo[dwIndex]));
	}

	return root;
}

INT32 DT_PLUNDER_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwCaptureOwnerPlayerID);
	memcpy(pDataBuff + dwOffset, &dwCaptureOwnerPlayerID, sizeof(dwCaptureOwnerPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwBeCaptureTime);
	memcpy(pDataBuff + dwOffset, &qwBeCaptureTime, sizeof(qwBeCaptureTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wExtPlunderNum);
	memcpy(pDataBuff + dwOffset, &wExtPlunderNum, sizeof(wExtPlunderNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwLastPlunderTime);
	memcpy(pDataBuff + dwOffset, &qwLastPlunderTime, sizeof(qwLastPlunderTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wLastPlunderNum);
	memcpy(pDataBuff + dwOffset, &wLastPlunderNum, sizeof(wLastPlunderNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byUnreadBattleLogNum);
	memcpy(pDataBuff + dwOffset, &byUnreadBattleLogNum, sizeof(byUnreadBattleLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(qwLastDriveAwayTime);
	memcpy(pDataBuff + dwOffset, &qwLastDriveAwayTime, sizeof(qwLastDriveAwayTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wLastDriveAwayNum);
	memcpy(pDataBuff + dwOffset, &wLastDriveAwayNum, sizeof(wLastDriveAwayNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_CAPTURE_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_CAPTURE_NUM; i++)
	{
		dwContextLenTmp += astCaptureGridInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLUNDER_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwCaptureOwnerPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCaptureOwnerPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCaptureOwnerPlayerID, 0, sizeof(dwCaptureOwnerPlayerID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwBeCaptureTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBeCaptureTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBeCaptureTime, 0, sizeof(qwBeCaptureTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wExtPlunderNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wExtPlunderNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wExtPlunderNum, 0, sizeof(wExtPlunderNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwLastPlunderTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastPlunderTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastPlunderTime, 0, sizeof(qwLastPlunderTime));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wLastPlunderNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastPlunderNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastPlunderNum, 0, sizeof(wLastPlunderNum));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byUnreadBattleLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byUnreadBattleLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUnreadBattleLogNum, 0, sizeof(byUnreadBattleLogNum));
				}
			}
			break;
		case 8:
			{
				if(sizeof(qwLastDriveAwayTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastDriveAwayTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastDriveAwayTime, 0, sizeof(qwLastDriveAwayTime));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wLastDriveAwayNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastDriveAwayNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastDriveAwayNum, 0, sizeof(wLastDriveAwayNum));
				}
			}
			break;
		case 10:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_CAPTURE_NUM ? wArrNum : MAX_CAPTURE_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astCaptureGridInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astCaptureGridInfo, 0, sizeof(astCaptureGridInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ENEMY_DATA(void *pHost, CNetData* poNetData)
{
	DT_ENEMY_DATA *pstIn = (DT_ENEMY_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwEnemyPlayerID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBattleNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ENEMY_DATA(void *pHost, CNetData* poNetData)
{
	DT_ENEMY_DATA *pstOut = (DT_ENEMY_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwEnemyPlayerID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBattleNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ENEMY_DATA(DT_ENEMY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EnemyPlayerID", (double)(data.dwEnemyPlayerID));
	cJSON_AddNumberToObject(root,"BattleNum", (double)(data.wBattleNum));
	cJSON_AddNumberToObject(root,"AddTime", (double)(data.qwAddTime));

	return root;
}

INT32 DT_ENEMY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwEnemyPlayerID);
	memcpy(pDataBuff + dwOffset, &dwEnemyPlayerID, sizeof(dwEnemyPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wBattleNum);
	memcpy(pDataBuff + dwOffset, &wBattleNum, sizeof(wBattleNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwAddTime);
	memcpy(pDataBuff + dwOffset, &qwAddTime, sizeof(qwAddTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ENEMY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwEnemyPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEnemyPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEnemyPlayerID, 0, sizeof(dwEnemyPlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wBattleNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wBattleNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBattleNum, 0, sizeof(wBattleNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwAddTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddTime, 0, sizeof(qwAddTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ENEMY_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_ENEMY_DATA_LIST *pstIn = (DT_ENEMY_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byEnemyNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ENEMY_NUM; i++)
	{
		if(i >= (INT32)pstIn->byEnemyNum)
			break;
		if(-1 == EncodeDT_ENEMY_DATA(&pstIn->astEnemyInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ENEMY_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_ENEMY_DATA_LIST *pstOut = (DT_ENEMY_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byEnemyNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ENEMY_NUM; i++)
	{
		if(i >= (INT32)pstOut->byEnemyNum)
			break;
		if(-1 == DecodeDT_ENEMY_DATA(&pstOut->astEnemyInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ENEMY_DATA_LIST(DT_ENEMY_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EnemyNum", (double)(data.byEnemyNum));
	cJSON *EnemyInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EnemyInfo", EnemyInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byEnemyNum; ++dwIndex)
	{
		cJSON_AddItemToObject(EnemyInfo, " ", GetJsonDT_ENEMY_DATA(data.astEnemyInfo[dwIndex]));
	}

	return root;
}

INT32 DT_ENEMY_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byEnemyNum);
	memcpy(pDataBuff + dwOffset, &byEnemyNum, sizeof(byEnemyNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byEnemyNum > MAX_ENEMY_NUM)
	{
		byEnemyNum = MAX_ENEMY_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byEnemyNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byEnemyNum; i++)
	{
		dwContextLenTmp += astEnemyInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ENEMY_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byEnemyNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byEnemyNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEnemyNum, 0, sizeof(byEnemyNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byEnemyNum)
				{
					wArrNum = wArrNum <= MAX_ENEMY_NUM ? wArrNum : MAX_ENEMY_NUM;
					byEnemyNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astEnemyInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astEnemyInfo, 0, sizeof(astEnemyInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astEnemyInfo, 0, sizeof(astEnemyInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MONEY_TREE_DATA(void *pHost, CNetData* poNetData)
{
	DT_MONEY_TREE_DATA *pstIn = (DT_MONEY_TREE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wRockNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwRockTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byMoodValue))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwMoodStartTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MONEY_TREE_DATA(void *pHost, CNetData* poNetData)
{
	DT_MONEY_TREE_DATA *pstOut = (DT_MONEY_TREE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wRockNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwRockTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byMoodValue))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwMoodStartTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MONEY_TREE_DATA(DT_MONEY_TREE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"RockNum", (double)(data.wRockNum));
	cJSON_AddNumberToObject(root,"RockTime", (double)(data.qwRockTime));
	cJSON_AddNumberToObject(root,"MoodValue", (double)(data.byMoodValue));
	cJSON_AddNumberToObject(root,"MoodStartTime", (double)(data.qwMoodStartTime));

	return root;
}

INT32 DT_MONEY_TREE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wRockNum);
	memcpy(pDataBuff + dwOffset, &wRockNum, sizeof(wRockNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwRockTime);
	memcpy(pDataBuff + dwOffset, &qwRockTime, sizeof(qwRockTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byMoodValue);
	memcpy(pDataBuff + dwOffset, &byMoodValue, sizeof(byMoodValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwMoodStartTime);
	memcpy(pDataBuff + dwOffset, &qwMoodStartTime, sizeof(qwMoodStartTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MONEY_TREE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wRockNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wRockNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRockNum, 0, sizeof(wRockNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwRockTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwRockTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwRockTime, 0, sizeof(qwRockTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byMoodValue) >= pstIndex->dwContextLen)
				{
					memcpy(&byMoodValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMoodValue, 0, sizeof(byMoodValue));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwMoodStartTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwMoodStartTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwMoodStartTime, 0, sizeof(qwMoodStartTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_INSTANCE_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_BATTLE_DATA *pstIn = (DT_INSTANCE_BATTLE_DATA*)pHost;

	if(-1 == EncodeDT_INSTANCE_ID(&pstIn->stInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleIndex))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBattleTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMaxRounds))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMaxPercentageHp))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_INSTANCE_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_BATTLE_DATA *pstOut = (DT_INSTANCE_BATTLE_DATA*)pHost;

	if(-1 == DecodeDT_INSTANCE_ID(&pstOut->stInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleIndex))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBattleTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMaxRounds))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMaxPercentageHp))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_INSTANCE_BATTLE_DATA(DT_INSTANCE_BATTLE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "InstanceID", GetJsonDT_INSTANCE_ID(data.stInstanceID));
	cJSON_AddNumberToObject(root,"BattleIndex", (double)(data.byBattleIndex));
	cJSON_AddNumberToObject(root,"BattleTime", (double)(data.qwBattleTime));
	cJSON_AddNumberToObject(root,"MaxRounds", (double)(data.wMaxRounds));
	cJSON_AddNumberToObject(root,"MaxPercentageHp", (double)(data.wMaxPercentageHp));

	return root;
}

INT32 DT_INSTANCE_BATTLE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stInstanceID.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byBattleIndex);
	memcpy(pDataBuff + dwOffset, &byBattleIndex, sizeof(byBattleIndex));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwBattleTime);
	memcpy(pDataBuff + dwOffset, &qwBattleTime, sizeof(qwBattleTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wMaxRounds);
	memcpy(pDataBuff + dwOffset, &wMaxRounds, sizeof(wMaxRounds));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wMaxPercentageHp);
	memcpy(pDataBuff + dwOffset, &wMaxPercentageHp, sizeof(wMaxPercentageHp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_INSTANCE_BATTLE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stInstanceID.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				if(sizeof(byBattleIndex) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleIndex, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleIndex, 0, sizeof(byBattleIndex));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwBattleTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBattleTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBattleTime, 0, sizeof(qwBattleTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wMaxRounds) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaxRounds, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaxRounds, 0, sizeof(wMaxRounds));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wMaxPercentageHp) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaxPercentageHp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaxPercentageHp, 0, sizeof(wMaxPercentageHp));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PHYSTRENGTH_DATA(void *pHost, CNetData* poNetData)
{
	DT_PHYSTRENGTH_DATA *pstIn = (DT_PHYSTRENGTH_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastPhyStrengthRefreshTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastBuyPhyStrengthTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastBuyPhyStrengthNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PHYSTRENGTH_DATA(void *pHost, CNetData* poNetData)
{
	DT_PHYSTRENGTH_DATA *pstOut = (DT_PHYSTRENGTH_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastPhyStrengthRefreshTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastBuyPhyStrengthTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastBuyPhyStrengthNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PHYSTRENGTH_DATA(DT_PHYSTRENGTH_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastPhyStrengthRefreshTime", (double)(data.qwLastPhyStrengthRefreshTime));
	cJSON_AddNumberToObject(root,"LastBuyPhyStrengthTime", (double)(data.qwLastBuyPhyStrengthTime));
	cJSON_AddNumberToObject(root,"LastBuyPhyStrengthNum", (double)(data.wLastBuyPhyStrengthNum));

	return root;
}

INT32 DT_PHYSTRENGTH_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastPhyStrengthRefreshTime);
	memcpy(pDataBuff + dwOffset, &qwLastPhyStrengthRefreshTime, sizeof(qwLastPhyStrengthRefreshTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastBuyPhyStrengthTime);
	memcpy(pDataBuff + dwOffset, &qwLastBuyPhyStrengthTime, sizeof(qwLastBuyPhyStrengthTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wLastBuyPhyStrengthNum);
	memcpy(pDataBuff + dwOffset, &wLastBuyPhyStrengthNum, sizeof(wLastBuyPhyStrengthNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PHYSTRENGTH_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastPhyStrengthRefreshTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastPhyStrengthRefreshTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastPhyStrengthRefreshTime, 0, sizeof(qwLastPhyStrengthRefreshTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLastBuyPhyStrengthTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastBuyPhyStrengthTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastBuyPhyStrengthTime, 0, sizeof(qwLastBuyPhyStrengthTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wLastBuyPhyStrengthNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastBuyPhyStrengthNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastBuyPhyStrengthNum, 0, sizeof(wLastBuyPhyStrengthNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ONHOOK_RESULT(void *pHost, CNetData* poNetData)
{
	DT_ONHOOK_RESULT *pstIn = (DT_ONHOOK_RESULT*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byCurRunTimes))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAllRunTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwStory))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwExperience))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCoin))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGold))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byItemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ENCOURAGE_ITEM_KIND_NUM; i++)
	{
		if(i >= (INT32)pstIn->byItemNum)
			break;
		if(-1 == EncodeDT_ITEM_DATA(&pstIn->astItemInfoList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddDword(pstIn->dwBlueGas))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ONHOOK_RESULT(void *pHost, CNetData* poNetData)
{
	DT_ONHOOK_RESULT *pstOut = (DT_ONHOOK_RESULT*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byCurRunTimes))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAllRunTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwStory))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwExperience))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCoin))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGold))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byItemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ENCOURAGE_ITEM_KIND_NUM; i++)
	{
		if(i >= (INT32)pstOut->byItemNum)
			break;
		if(-1 == DecodeDT_ITEM_DATA(&pstOut->astItemInfoList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelDword(pstOut->dwBlueGas))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ONHOOK_RESULT(DT_ONHOOK_RESULT &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CurRunTimes", (double)(data.byCurRunTimes));
	cJSON_AddNumberToObject(root,"AllRunTimes", (double)(data.byAllRunTimes));
	cJSON_AddNumberToObject(root,"Story", (double)(data.dwStory));
	cJSON_AddNumberToObject(root,"Experience", (double)(data.dwExperience));
	cJSON_AddNumberToObject(root,"Coin", (double)(data.dwCoin));
	cJSON_AddNumberToObject(root,"Gold", (double)(data.dwGold));
	cJSON_AddNumberToObject(root,"ItemNum", (double)(data.byItemNum));
	cJSON *ItemInfoList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ItemInfoList", ItemInfoList);
	for( UINT32 dwIndex=0; dwIndex<data.byItemNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ItemInfoList, " ", GetJsonDT_ITEM_DATA(data.astItemInfoList[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"BlueGas", (double)(data.dwBlueGas));

	return root;
}

INT32 DT_ONHOOK_RESULT::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byCurRunTimes);
	memcpy(pDataBuff + dwOffset, &byCurRunTimes, sizeof(byCurRunTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byAllRunTimes);
	memcpy(pDataBuff + dwOffset, &byAllRunTimes, sizeof(byAllRunTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwStory);
	memcpy(pDataBuff + dwOffset, &dwStory, sizeof(dwStory));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwExperience);
	memcpy(pDataBuff + dwOffset, &dwExperience, sizeof(dwExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwCoin);
	memcpy(pDataBuff + dwOffset, &dwCoin, sizeof(dwCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwGold);
	memcpy(pDataBuff + dwOffset, &dwGold, sizeof(dwGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byItemNum);
	memcpy(pDataBuff + dwOffset, &byItemNum, sizeof(byItemNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	dwContextLenTmp = 0;
	if(byItemNum > MAX_ENCOURAGE_ITEM_KIND_NUM)
	{
		byItemNum = MAX_ENCOURAGE_ITEM_KIND_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byItemNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byItemNum; i++)
	{
		dwContextLenTmp += astItemInfoList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwBlueGas);
	memcpy(pDataBuff + dwOffset, &dwBlueGas, sizeof(dwBlueGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ONHOOK_RESULT::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byCurRunTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurRunTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurRunTimes, 0, sizeof(byCurRunTimes));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byAllRunTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byAllRunTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAllRunTimes, 0, sizeof(byAllRunTimes));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwStory) >= pstIndex->dwContextLen)
				{
					memcpy(&dwStory, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwStory, 0, sizeof(dwStory));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwExperience, 0, sizeof(dwExperience));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCoin, 0, sizeof(dwCoin));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwGold) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGold, 0, sizeof(dwGold));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byItemNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byItemNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byItemNum, 0, sizeof(byItemNum));
				}
			}
			break;
		case 8:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byItemNum)
				{
					wArrNum = wArrNum <= MAX_ENCOURAGE_ITEM_KIND_NUM ? wArrNum : MAX_ENCOURAGE_ITEM_KIND_NUM;
					byItemNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astItemInfoList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astItemInfoList, 0, sizeof(astItemInfoList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astItemInfoList, 0, sizeof(astItemInfoList));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwBlueGas) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBlueGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBlueGas, 0, sizeof(dwBlueGas));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ONHOOK_RCD_DATA(void *pHost, CNetData* poNetData)
{
	DT_ONHOOK_RCD_DATA *pstIn = (DT_ONHOOK_RCD_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byOnhookFlag))
		return -1;

	if(-1 == EncodeDT_ONHOOK_RESULT(&pstIn->stOnhookResult, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_ID(&pstIn->stOnhookInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastOnhookResultReqTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ONHOOK_RCD_DATA(void *pHost, CNetData* poNetData)
{
	DT_ONHOOK_RCD_DATA *pstOut = (DT_ONHOOK_RCD_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byOnhookFlag))
		return -1;

	if(-1 == DecodeDT_ONHOOK_RESULT(&pstOut->stOnhookResult, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_ID(&pstOut->stOnhookInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastOnhookResultReqTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ONHOOK_RCD_DATA(DT_ONHOOK_RCD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"OnhookFlag", (double)(data.byOnhookFlag));
	cJSON_AddItemToObject(root, "OnhookResult", GetJsonDT_ONHOOK_RESULT(data.stOnhookResult));
	cJSON_AddItemToObject(root, "OnhookInstanceID", GetJsonDT_INSTANCE_ID(data.stOnhookInstanceID));
	cJSON_AddNumberToObject(root,"LastOnhookResultReqTime", (double)(data.qwLastOnhookResultReqTime));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_ONHOOK_RCD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byOnhookFlag);
	memcpy(pDataBuff + dwOffset, &byOnhookFlag, sizeof(byOnhookFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stOnhookResult.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stOnhookInstanceID.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwLastOnhookResultReqTime);
	memcpy(pDataBuff + dwOffset, &qwLastOnhookResultReqTime, sizeof(qwLastOnhookResultReqTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ONHOOK_RCD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byOnhookFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byOnhookFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byOnhookFlag, 0, sizeof(byOnhookFlag));
				}
			}
			break;
		case 2:
			{
				stOnhookResult.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stOnhookInstanceID.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				if(sizeof(qwLastOnhookResultReqTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastOnhookResultReqTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastOnhookResultReqTime, 0, sizeof(qwLastOnhookResultReqTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FEW_PARAM_DATA(void *pHost, CNetData* poNetData)
{
	DT_FEW_PARAM_DATA *pstIn = (DT_FEW_PARAM_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastStrengthenTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastStrengthenCD))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastRefreshEliteTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastRefreshEliteNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwCountTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wGVETimes))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wRaceSuccess))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wRaceFailed))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wTrialSuccess))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wTrialFailed))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wInterceptSuccess))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wInterceptFailed))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAwakenNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wResetTowerNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wWorldPassNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHellPassNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeavenPassNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wXiJingHorse))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wXiJingThird))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wXiJingSecond))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wXiJingFirst))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wXiJingMaster))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wExperienceDrug))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPassNaiDanNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FEW_PARAM_DATA(void *pHost, CNetData* poNetData)
{
	DT_FEW_PARAM_DATA *pstOut = (DT_FEW_PARAM_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastStrengthenTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastStrengthenCD))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastRefreshEliteTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastRefreshEliteNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwCountTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wGVETimes))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wRaceSuccess))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wRaceFailed))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wTrialSuccess))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wTrialFailed))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wInterceptSuccess))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wInterceptFailed))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAwakenNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wResetTowerNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wWorldPassNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHellPassNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeavenPassNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wXiJingHorse))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wXiJingThird))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wXiJingSecond))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wXiJingFirst))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wXiJingMaster))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wExperienceDrug))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPassNaiDanNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FEW_PARAM_DATA(DT_FEW_PARAM_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastStrengthenTime", (double)(data.qwLastStrengthenTime));
	cJSON_AddNumberToObject(root,"LastStrengthenCD", (double)(data.wLastStrengthenCD));
	cJSON_AddNumberToObject(root,"LastRefreshEliteTime", (double)(data.qwLastRefreshEliteTime));
	cJSON_AddNumberToObject(root,"LastRefreshEliteNum", (double)(data.wLastRefreshEliteNum));
	cJSON_AddNumberToObject(root,"CountTime", (double)(data.qwCountTime));
	cJSON_AddNumberToObject(root,"GVETimes", (double)(data.wGVETimes));
	cJSON_AddNumberToObject(root,"RaceSuccess", (double)(data.wRaceSuccess));
	cJSON_AddNumberToObject(root,"RaceFailed", (double)(data.wRaceFailed));
	cJSON_AddNumberToObject(root,"TrialSuccess", (double)(data.wTrialSuccess));
	cJSON_AddNumberToObject(root,"TrialFailed", (double)(data.wTrialFailed));
	cJSON_AddNumberToObject(root,"InterceptSuccess", (double)(data.wInterceptSuccess));
	cJSON_AddNumberToObject(root,"InterceptFailed", (double)(data.wInterceptFailed));
	cJSON_AddNumberToObject(root,"AwakenNum", (double)(data.wAwakenNum));
	cJSON_AddNumberToObject(root,"ResetTowerNum", (double)(data.wResetTowerNum));
	cJSON_AddNumberToObject(root,"WorldPassNum", (double)(data.wWorldPassNum));
	cJSON_AddNumberToObject(root,"HellPassNum", (double)(data.wHellPassNum));
	cJSON_AddNumberToObject(root,"HeavenPassNum", (double)(data.wHeavenPassNum));
	cJSON_AddNumberToObject(root,"XiJingHorse", (double)(data.wXiJingHorse));
	cJSON_AddNumberToObject(root,"XiJingThird", (double)(data.wXiJingThird));
	cJSON_AddNumberToObject(root,"XiJingSecond", (double)(data.wXiJingSecond));
	cJSON_AddNumberToObject(root,"XiJingFirst", (double)(data.wXiJingFirst));
	cJSON_AddNumberToObject(root,"XiJingMaster", (double)(data.wXiJingMaster));
	cJSON_AddNumberToObject(root,"ExperienceDrug", (double)(data.wExperienceDrug));
	cJSON_AddNumberToObject(root,"PassNaiDanNum", (double)(data.wPassNaiDanNum));

	return root;
}

INT32 DT_FEW_PARAM_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 24;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastStrengthenTime);
	memcpy(pDataBuff + dwOffset, &qwLastStrengthenTime, sizeof(qwLastStrengthenTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLastStrengthenCD);
	memcpy(pDataBuff + dwOffset, &wLastStrengthenCD, sizeof(wLastStrengthenCD));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastRefreshEliteTime);
	memcpy(pDataBuff + dwOffset, &qwLastRefreshEliteTime, sizeof(qwLastRefreshEliteTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wLastRefreshEliteNum);
	memcpy(pDataBuff + dwOffset, &wLastRefreshEliteNum, sizeof(wLastRefreshEliteNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwCountTime);
	memcpy(pDataBuff + dwOffset, &qwCountTime, sizeof(qwCountTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wGVETimes);
	memcpy(pDataBuff + dwOffset, &wGVETimes, sizeof(wGVETimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wRaceSuccess);
	memcpy(pDataBuff + dwOffset, &wRaceSuccess, sizeof(wRaceSuccess));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wRaceFailed);
	memcpy(pDataBuff + dwOffset, &wRaceFailed, sizeof(wRaceFailed));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wTrialSuccess);
	memcpy(pDataBuff + dwOffset, &wTrialSuccess, sizeof(wTrialSuccess));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(wTrialFailed);
	memcpy(pDataBuff + dwOffset, &wTrialFailed, sizeof(wTrialFailed));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(wInterceptSuccess);
	memcpy(pDataBuff + dwOffset, &wInterceptSuccess, sizeof(wInterceptSuccess));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(wInterceptFailed);
	memcpy(pDataBuff + dwOffset, &wInterceptFailed, sizeof(wInterceptFailed));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(wAwakenNum);
	memcpy(pDataBuff + dwOffset, &wAwakenNum, sizeof(wAwakenNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(wResetTowerNum);
	memcpy(pDataBuff + dwOffset, &wResetTowerNum, sizeof(wResetTowerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(wWorldPassNum);
	memcpy(pDataBuff + dwOffset, &wWorldPassNum, sizeof(wWorldPassNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = sizeof(wHellPassNum);
	memcpy(pDataBuff + dwOffset, &wHellPassNum, sizeof(wHellPassNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(wHeavenPassNum);
	memcpy(pDataBuff + dwOffset, &wHeavenPassNum, sizeof(wHeavenPassNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(wXiJingHorse);
	memcpy(pDataBuff + dwOffset, &wXiJingHorse, sizeof(wXiJingHorse));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 19;
	pstIndex->dwContextLen = sizeof(wXiJingThird);
	memcpy(pDataBuff + dwOffset, &wXiJingThird, sizeof(wXiJingThird));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 20;
	pstIndex->dwContextLen = sizeof(wXiJingSecond);
	memcpy(pDataBuff + dwOffset, &wXiJingSecond, sizeof(wXiJingSecond));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 21;
	pstIndex->dwContextLen = sizeof(wXiJingFirst);
	memcpy(pDataBuff + dwOffset, &wXiJingFirst, sizeof(wXiJingFirst));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 22;
	pstIndex->dwContextLen = sizeof(wXiJingMaster);
	memcpy(pDataBuff + dwOffset, &wXiJingMaster, sizeof(wXiJingMaster));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 23;
	pstIndex->dwContextLen = sizeof(wExperienceDrug);
	memcpy(pDataBuff + dwOffset, &wExperienceDrug, sizeof(wExperienceDrug));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 24;
	pstIndex->dwContextLen = sizeof(wPassNaiDanNum);
	memcpy(pDataBuff + dwOffset, &wPassNaiDanNum, sizeof(wPassNaiDanNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FEW_PARAM_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastStrengthenTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastStrengthenTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastStrengthenTime, 0, sizeof(qwLastStrengthenTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLastStrengthenCD) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastStrengthenCD, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastStrengthenCD, 0, sizeof(wLastStrengthenCD));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastRefreshEliteTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastRefreshEliteTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastRefreshEliteTime, 0, sizeof(qwLastRefreshEliteTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wLastRefreshEliteNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastRefreshEliteNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastRefreshEliteNum, 0, sizeof(wLastRefreshEliteNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwCountTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwCountTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwCountTime, 0, sizeof(qwCountTime));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wGVETimes) >= pstIndex->dwContextLen)
				{
					memcpy(&wGVETimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wGVETimes, 0, sizeof(wGVETimes));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wRaceSuccess) >= pstIndex->dwContextLen)
				{
					memcpy(&wRaceSuccess, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRaceSuccess, 0, sizeof(wRaceSuccess));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wRaceFailed) >= pstIndex->dwContextLen)
				{
					memcpy(&wRaceFailed, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRaceFailed, 0, sizeof(wRaceFailed));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wTrialSuccess) >= pstIndex->dwContextLen)
				{
					memcpy(&wTrialSuccess, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wTrialSuccess, 0, sizeof(wTrialSuccess));
				}
			}
			break;
		case 10:
			{
				if(sizeof(wTrialFailed) >= pstIndex->dwContextLen)
				{
					memcpy(&wTrialFailed, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wTrialFailed, 0, sizeof(wTrialFailed));
				}
			}
			break;
		case 11:
			{
				if(sizeof(wInterceptSuccess) >= pstIndex->dwContextLen)
				{
					memcpy(&wInterceptSuccess, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wInterceptSuccess, 0, sizeof(wInterceptSuccess));
				}
			}
			break;
		case 12:
			{
				if(sizeof(wInterceptFailed) >= pstIndex->dwContextLen)
				{
					memcpy(&wInterceptFailed, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wInterceptFailed, 0, sizeof(wInterceptFailed));
				}
			}
			break;
		case 13:
			{
				if(sizeof(wAwakenNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wAwakenNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAwakenNum, 0, sizeof(wAwakenNum));
				}
			}
			break;
		case 14:
			{
				if(sizeof(wResetTowerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wResetTowerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wResetTowerNum, 0, sizeof(wResetTowerNum));
				}
			}
			break;
		case 15:
			{
				if(sizeof(wWorldPassNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wWorldPassNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wWorldPassNum, 0, sizeof(wWorldPassNum));
				}
			}
			break;
		case 16:
			{
				if(sizeof(wHellPassNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wHellPassNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHellPassNum, 0, sizeof(wHellPassNum));
				}
			}
			break;
		case 17:
			{
				if(sizeof(wHeavenPassNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeavenPassNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeavenPassNum, 0, sizeof(wHeavenPassNum));
				}
			}
			break;
		case 18:
			{
				if(sizeof(wXiJingHorse) >= pstIndex->dwContextLen)
				{
					memcpy(&wXiJingHorse, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wXiJingHorse, 0, sizeof(wXiJingHorse));
				}
			}
			break;
		case 19:
			{
				if(sizeof(wXiJingThird) >= pstIndex->dwContextLen)
				{
					memcpy(&wXiJingThird, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wXiJingThird, 0, sizeof(wXiJingThird));
				}
			}
			break;
		case 20:
			{
				if(sizeof(wXiJingSecond) >= pstIndex->dwContextLen)
				{
					memcpy(&wXiJingSecond, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wXiJingSecond, 0, sizeof(wXiJingSecond));
				}
			}
			break;
		case 21:
			{
				if(sizeof(wXiJingFirst) >= pstIndex->dwContextLen)
				{
					memcpy(&wXiJingFirst, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wXiJingFirst, 0, sizeof(wXiJingFirst));
				}
			}
			break;
		case 22:
			{
				if(sizeof(wXiJingMaster) >= pstIndex->dwContextLen)
				{
					memcpy(&wXiJingMaster, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wXiJingMaster, 0, sizeof(wXiJingMaster));
				}
			}
			break;
		case 23:
			{
				if(sizeof(wExperienceDrug) >= pstIndex->dwContextLen)
				{
					memcpy(&wExperienceDrug, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wExperienceDrug, 0, sizeof(wExperienceDrug));
				}
			}
			break;
		case 24:
			{
				if(sizeof(wPassNaiDanNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPassNaiDanNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPassNaiDanNum, 0, sizeof(wPassNaiDanNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CROP_INFO_DATA(void *pHost, CNetData* poNetData)
{
	DT_CROP_INFO_DATA *pstIn = (DT_CROP_INFO_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byOpen))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCropKindID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastCropTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFieldLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSeedNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CROP_INFO_DATA(void *pHost, CNetData* poNetData)
{
	DT_CROP_INFO_DATA *pstOut = (DT_CROP_INFO_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byOpen))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCropKindID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastCropTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFieldLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSeedNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CROP_INFO_DATA(DT_CROP_INFO_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Open", (double)(data.byOpen));
	cJSON_AddNumberToObject(root,"CropKindID", (double)(data.wCropKindID));
	cJSON_AddNumberToObject(root,"LastCropTime", (double)(data.qwLastCropTime));
	cJSON_AddNumberToObject(root,"FieldLevel", (double)(data.byFieldLevel));
	cJSON_AddNumberToObject(root,"SeedNum", (double)(data.dwSeedNum));

	return root;
}

INT32 DT_CROP_INFO_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byOpen);
	memcpy(pDataBuff + dwOffset, &byOpen, sizeof(byOpen));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wCropKindID);
	memcpy(pDataBuff + dwOffset, &wCropKindID, sizeof(wCropKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastCropTime);
	memcpy(pDataBuff + dwOffset, &qwLastCropTime, sizeof(qwLastCropTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byFieldLevel);
	memcpy(pDataBuff + dwOffset, &byFieldLevel, sizeof(byFieldLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwSeedNum);
	memcpy(pDataBuff + dwOffset, &dwSeedNum, sizeof(dwSeedNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CROP_INFO_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byOpen) >= pstIndex->dwContextLen)
				{
					memcpy(&byOpen, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byOpen, 0, sizeof(byOpen));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wCropKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wCropKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCropKindID, 0, sizeof(wCropKindID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastCropTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastCropTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastCropTime, 0, sizeof(qwLastCropTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byFieldLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byFieldLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFieldLevel, 0, sizeof(byFieldLevel));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwSeedNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSeedNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSeedNum, 0, sizeof(dwSeedNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CROP_DATA(void *pHost, CNetData* poNetData)
{
	DT_CROP_DATA *pstIn = (DT_CROP_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_CROP_NUM; i++)
	{
		if(-1 == EncodeDT_CROP_INFO_DATA(&pstIn->astCropInfoList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CROP_DATA(void *pHost, CNetData* poNetData)
{
	DT_CROP_DATA *pstOut = (DT_CROP_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_CROP_NUM; i++)
		{
			if(-1 == DecodeDT_CROP_INFO_DATA(&pstOut->astCropInfoList[i], poNetData))
				return -1;
		}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CROP_DATA(DT_CROP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON *CropInfoList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "CropInfoList", CropInfoList);
	for( UINT32 dwIndex=0; dwIndex<MAX_CROP_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(CropInfoList, " ", GetJsonDT_CROP_INFO_DATA(data.astCropInfoList[dwIndex]));
	}

	return root;
}

INT32 DT_CROP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_CROP_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_CROP_NUM; i++)
	{
		dwContextLenTmp += astCropInfoList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CROP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_CROP_NUM ? wArrNum : MAX_CROP_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astCropInfoList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astCropInfoList, 0, sizeof(astCropInfoList));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SCIENCE_TREE_DATA(void *pHost, CNetData* poNetData)
{
	DT_SCIENCE_TREE_DATA *pstIn = (DT_SCIENCE_TREE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wAttractLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHPLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCritLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wShieldLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHitLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wDodgeLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFirstAttack))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCoachTalent))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAttractLevel2))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHPLevel2))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wQingLogLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBaiHuLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wZhuQueLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wXuanWuLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SCIENCE_TREE_DATA(void *pHost, CNetData* poNetData)
{
	DT_SCIENCE_TREE_DATA *pstOut = (DT_SCIENCE_TREE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wAttractLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHPLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCritLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wShieldLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHitLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wDodgeLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFirstAttack))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCoachTalent))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAttractLevel2))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHPLevel2))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wQingLogLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBaiHuLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wZhuQueLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wXuanWuLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SCIENCE_TREE_DATA(DT_SCIENCE_TREE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"AttractLevel", (double)(data.wAttractLevel));
	cJSON_AddNumberToObject(root,"HPLevel", (double)(data.wHPLevel));
	cJSON_AddNumberToObject(root,"CritLevel", (double)(data.wCritLevel));
	cJSON_AddNumberToObject(root,"ShieldLevel", (double)(data.wShieldLevel));
	cJSON_AddNumberToObject(root,"HitLevel", (double)(data.wHitLevel));
	cJSON_AddNumberToObject(root,"DodgeLevel", (double)(data.wDodgeLevel));
	cJSON_AddNumberToObject(root,"FirstAttack", (double)(data.dwFirstAttack));
	cJSON_AddNumberToObject(root,"CoachTalent", (double)(data.wCoachTalent));
	cJSON_AddNumberToObject(root,"AttractLevel2", (double)(data.wAttractLevel2));
	cJSON_AddNumberToObject(root,"HPLevel2", (double)(data.wHPLevel2));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"QingLogLevel", (double)(data.wQingLogLevel));
	cJSON_AddNumberToObject(root,"BaiHuLevel", (double)(data.wBaiHuLevel));
	cJSON_AddNumberToObject(root,"ZhuQueLevel", (double)(data.wZhuQueLevel));
	cJSON_AddNumberToObject(root,"XuanWuLevel", (double)(data.wXuanWuLevel));

	return root;
}

INT32 DT_SCIENCE_TREE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 15;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wAttractLevel);
	memcpy(pDataBuff + dwOffset, &wAttractLevel, sizeof(wAttractLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wHPLevel);
	memcpy(pDataBuff + dwOffset, &wHPLevel, sizeof(wHPLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wCritLevel);
	memcpy(pDataBuff + dwOffset, &wCritLevel, sizeof(wCritLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wShieldLevel);
	memcpy(pDataBuff + dwOffset, &wShieldLevel, sizeof(wShieldLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wHitLevel);
	memcpy(pDataBuff + dwOffset, &wHitLevel, sizeof(wHitLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wDodgeLevel);
	memcpy(pDataBuff + dwOffset, &wDodgeLevel, sizeof(wDodgeLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwFirstAttack);
	memcpy(pDataBuff + dwOffset, &dwFirstAttack, sizeof(dwFirstAttack));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wCoachTalent);
	memcpy(pDataBuff + dwOffset, &wCoachTalent, sizeof(wCoachTalent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wAttractLevel2);
	memcpy(pDataBuff + dwOffset, &wAttractLevel2, sizeof(wAttractLevel2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(wHPLevel2);
	memcpy(pDataBuff + dwOffset, &wHPLevel2, sizeof(wHPLevel2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(wQingLogLevel);
	memcpy(pDataBuff + dwOffset, &wQingLogLevel, sizeof(wQingLogLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(wBaiHuLevel);
	memcpy(pDataBuff + dwOffset, &wBaiHuLevel, sizeof(wBaiHuLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(wZhuQueLevel);
	memcpy(pDataBuff + dwOffset, &wZhuQueLevel, sizeof(wZhuQueLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(wXuanWuLevel);
	memcpy(pDataBuff + dwOffset, &wXuanWuLevel, sizeof(wXuanWuLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SCIENCE_TREE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wAttractLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttractLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttractLevel, 0, sizeof(wAttractLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wHPLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wHPLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHPLevel, 0, sizeof(wHPLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wCritLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wCritLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCritLevel, 0, sizeof(wCritLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wShieldLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wShieldLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wShieldLevel, 0, sizeof(wShieldLevel));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wHitLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wHitLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHitLevel, 0, sizeof(wHitLevel));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wDodgeLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wDodgeLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDodgeLevel, 0, sizeof(wDodgeLevel));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwFirstAttack) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFirstAttack, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFirstAttack, 0, sizeof(dwFirstAttack));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wCoachTalent) >= pstIndex->dwContextLen)
				{
					memcpy(&wCoachTalent, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCoachTalent, 0, sizeof(wCoachTalent));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wAttractLevel2) >= pstIndex->dwContextLen)
				{
					memcpy(&wAttractLevel2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAttractLevel2, 0, sizeof(wAttractLevel2));
				}
			}
			break;
		case 10:
			{
				if(sizeof(wHPLevel2) >= pstIndex->dwContextLen)
				{
					memcpy(&wHPLevel2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHPLevel2, 0, sizeof(wHPLevel2));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 12:
			{
				if(sizeof(wQingLogLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wQingLogLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wQingLogLevel, 0, sizeof(wQingLogLevel));
				}
			}
			break;
		case 13:
			{
				if(sizeof(wBaiHuLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wBaiHuLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBaiHuLevel, 0, sizeof(wBaiHuLevel));
				}
			}
			break;
		case 14:
			{
				if(sizeof(wZhuQueLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wZhuQueLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wZhuQueLevel, 0, sizeof(wZhuQueLevel));
				}
			}
			break;
		case 15:
			{
				if(sizeof(wXuanWuLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wXuanWuLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wXuanWuLevel, 0, sizeof(wXuanWuLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FORMATION_HERO_DATA(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_HERO_DATA *pstIn = (DT_FORMATION_HERO_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FORMATION_HERO_DATA(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_HERO_DATA *pstOut = (DT_FORMATION_HERO_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FORMATION_HERO_DATA(DT_FORMATION_HERO_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));
	cJSON_AddNumberToObject(root,"HeroID", (double)(data.wHeroID));

	return root;
}

INT32 DT_FORMATION_HERO_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wHeroID);
	memcpy(pDataBuff + dwOffset, &wHeroID, sizeof(wHeroID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FORMATION_HERO_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wHeroID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroID, 0, sizeof(wHeroID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FORMATION_IDX_DATA(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_IDX_DATA *pstIn = (DT_FORMATION_IDX_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationKind))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byOpenIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byOpenIdxNum)
			break;
		if(-1 == EncodeDT_FORMATION_HERO_DATA(&pstIn->astOpenIdxInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FORMATION_IDX_DATA(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_IDX_DATA *pstOut = (DT_FORMATION_IDX_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationKind))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byOpenIdxNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byOpenIdxNum)
			break;
		if(-1 == DecodeDT_FORMATION_HERO_DATA(&pstOut->astOpenIdxInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FORMATION_IDX_DATA(DT_FORMATION_IDX_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationKind", (double)(data.byFormationKind));
	cJSON_AddNumberToObject(root,"OpenIdxNum", (double)(data.byOpenIdxNum));
	cJSON *OpenIdxInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "OpenIdxInfo", OpenIdxInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byOpenIdxNum; ++dwIndex)
	{
		cJSON_AddItemToObject(OpenIdxInfo, " ", GetJsonDT_FORMATION_HERO_DATA(data.astOpenIdxInfo[dwIndex]));
	}

	return root;
}

INT32 DT_FORMATION_IDX_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationKind);
	memcpy(pDataBuff + dwOffset, &byFormationKind, sizeof(byFormationKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byOpenIdxNum);
	memcpy(pDataBuff + dwOffset, &byOpenIdxNum, sizeof(byOpenIdxNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(byOpenIdxNum > MAX_FORMATION_IDX_NUM)
	{
		byOpenIdxNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byOpenIdxNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byOpenIdxNum; i++)
	{
		dwContextLenTmp += astOpenIdxInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FORMATION_IDX_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationKind, 0, sizeof(byFormationKind));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byOpenIdxNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byOpenIdxNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byOpenIdxNum, 0, sizeof(byOpenIdxNum));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byOpenIdxNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byOpenIdxNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astOpenIdxInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astOpenIdxInfo, 0, sizeof(astOpenIdxInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astOpenIdxInfo, 0, sizeof(astOpenIdxInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FORMATION_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_DATA_LIST *pstIn = (DT_FORMATION_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationKindNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_NUM; i++)
	{
		if(i >= (INT32)pstIn->byFormationKindNum)
			break;
		if(-1 == EncodeDT_FORMATION_IDX_DATA(&pstIn->astFormationInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FORMATION_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_DATA_LIST *pstOut = (DT_FORMATION_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationKindNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_NUM; i++)
	{
		if(i >= (INT32)pstOut->byFormationKindNum)
			break;
		if(-1 == DecodeDT_FORMATION_IDX_DATA(&pstOut->astFormationInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FORMATION_DATA_LIST(DT_FORMATION_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationKindNum", (double)(data.byFormationKindNum));
	cJSON *FormationInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FormationInfo", FormationInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byFormationKindNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FormationInfo, " ", GetJsonDT_FORMATION_IDX_DATA(data.astFormationInfo[dwIndex]));
	}

	return root;
}

INT32 DT_FORMATION_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationKindNum);
	memcpy(pDataBuff + dwOffset, &byFormationKindNum, sizeof(byFormationKindNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byFormationKindNum > MAX_FORMATION_NUM)
	{
		byFormationKindNum = MAX_FORMATION_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFormationKindNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFormationKindNum; i++)
	{
		dwContextLenTmp += astFormationInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FORMATION_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationKindNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationKindNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationKindNum, 0, sizeof(byFormationKindNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFormationKindNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_NUM ? wArrNum : MAX_FORMATION_NUM;
					byFormationKindNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFormationInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFormationInfo, 0, sizeof(astFormationInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFormationInfo, 0, sizeof(astFormationInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FORMATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_DATA *pstIn = (DT_FORMATION_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->bySelectIdx))
		return -1;

	if(-1 == EncodeDT_FORMATION_DATA_LIST(&pstIn->stFormationList, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FORMATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_FORMATION_DATA *pstOut = (DT_FORMATION_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->bySelectIdx))
		return -1;

	if(-1 == DecodeDT_FORMATION_DATA_LIST(&pstOut->stFormationList, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FORMATION_DATA(DT_FORMATION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SelectIdx", (double)(data.bySelectIdx));
	cJSON_AddItemToObject(root, "FormationList", GetJsonDT_FORMATION_DATA_LIST(data.stFormationList));

	return root;
}

INT32 DT_FORMATION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(bySelectIdx);
	memcpy(pDataBuff + dwOffset, &bySelectIdx, sizeof(bySelectIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stFormationList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FORMATION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(bySelectIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&bySelectIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySelectIdx, 0, sizeof(bySelectIdx));
				}
			}
			break;
		case 2:
			{
				stFormationList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NEW_FORMATION_POSTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_POSTION_INFO *pstIn = (DT_NEW_FORMATION_POSTION_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPostionIndex))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsUnlock))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNeedLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NEW_FORMATION_POSTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_POSTION_INFO *pstOut = (DT_NEW_FORMATION_POSTION_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPostionIndex))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsUnlock))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNeedLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NEW_FORMATION_POSTION_INFO(DT_NEW_FORMATION_POSTION_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PostionIndex", (double)(data.byPostionIndex));
	cJSON_AddNumberToObject(root,"HeroID", (double)(data.wHeroID));
	cJSON_AddNumberToObject(root,"IsUnlock", (double)(data.byIsUnlock));
	cJSON_AddNumberToObject(root,"NeedLevel", (double)(data.byNeedLevel));

	return root;
}

INT32 DT_NEW_FORMATION_POSTION_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPostionIndex);
	memcpy(pDataBuff + dwOffset, &byPostionIndex, sizeof(byPostionIndex));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wHeroID);
	memcpy(pDataBuff + dwOffset, &wHeroID, sizeof(wHeroID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byIsUnlock);
	memcpy(pDataBuff + dwOffset, &byIsUnlock, sizeof(byIsUnlock));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byNeedLevel);
	memcpy(pDataBuff + dwOffset, &byNeedLevel, sizeof(byNeedLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NEW_FORMATION_POSTION_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPostionIndex) >= pstIndex->dwContextLen)
				{
					memcpy(&byPostionIndex, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPostionIndex, 0, sizeof(byPostionIndex));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wHeroID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroID, 0, sizeof(wHeroID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byIsUnlock) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsUnlock, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsUnlock, 0, sizeof(byIsUnlock));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byNeedLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byNeedLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNeedLevel, 0, sizeof(byNeedLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NEW_FORMATION_INFO(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_INFO *pstIn = (DT_NEW_FORMATION_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPostionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byPostionNum)
			break;
		if(-1 == EncodeDT_NEW_FORMATION_POSTION_INFO(&pstIn->astPostionInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byFormationLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NEW_FORMATION_INFO(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_INFO *pstOut = (DT_NEW_FORMATION_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPostionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byPostionNum)
			break;
		if(-1 == DecodeDT_NEW_FORMATION_POSTION_INFO(&pstOut->astPostionInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byFormationLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NEW_FORMATION_INFO(DT_NEW_FORMATION_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationID", (double)(data.byFormationID));
	cJSON_AddNumberToObject(root,"PostionNum", (double)(data.byPostionNum));
	cJSON *PostionInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PostionInfo", PostionInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byPostionNum; ++dwIndex)
	{
		cJSON_AddItemToObject(PostionInfo, " ", GetJsonDT_NEW_FORMATION_POSTION_INFO(data.astPostionInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"FormationLevel", (double)(data.byFormationLevel));

	return root;
}

INT32 DT_NEW_FORMATION_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationID);
	memcpy(pDataBuff + dwOffset, &byFormationID, sizeof(byFormationID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byPostionNum);
	memcpy(pDataBuff + dwOffset, &byPostionNum, sizeof(byPostionNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(byPostionNum > MAX_FORMATION_IDX_NUM)
	{
		byPostionNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byPostionNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byPostionNum; i++)
	{
		dwContextLenTmp += astPostionInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byFormationLevel);
	memcpy(pDataBuff + dwOffset, &byFormationLevel, sizeof(byFormationLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NEW_FORMATION_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationID) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationID, 0, sizeof(byFormationID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byPostionNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byPostionNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPostionNum, 0, sizeof(byPostionNum));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byPostionNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byPostionNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPostionInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPostionInfo, 0, sizeof(astPostionInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPostionInfo, 0, sizeof(astPostionInfo));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byFormationLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationLevel, 0, sizeof(byFormationLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NEW_FORMATION_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_DATA_LST *pstIn = (DT_NEW_FORMATION_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFormationNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_FORMATION_NUM; i++)
	{
		if(i >= (INT32)pstIn->byFormationNum)
			break;
		if(-1 == EncodeDT_NEW_FORMATION_INFO(&pstIn->astFormationArray[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NEW_FORMATION_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_DATA_LST *pstOut = (DT_NEW_FORMATION_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFormationNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEW_FORMATION_NUM; i++)
	{
		if(i >= (INT32)pstOut->byFormationNum)
			break;
		if(-1 == DecodeDT_NEW_FORMATION_INFO(&pstOut->astFormationArray[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NEW_FORMATION_DATA_LST(DT_NEW_FORMATION_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FormationNum", (double)(data.byFormationNum));
	cJSON *FormationArray = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FormationArray", FormationArray);
	for( UINT32 dwIndex=0; dwIndex<data.byFormationNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FormationArray, " ", GetJsonDT_NEW_FORMATION_INFO(data.astFormationArray[dwIndex]));
	}

	return root;
}

INT32 DT_NEW_FORMATION_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFormationNum);
	memcpy(pDataBuff + dwOffset, &byFormationNum, sizeof(byFormationNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byFormationNum > MAX_NEW_FORMATION_NUM)
	{
		byFormationNum = MAX_NEW_FORMATION_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFormationNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFormationNum; i++)
	{
		dwContextLenTmp += astFormationArray[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NEW_FORMATION_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFormationNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationNum, 0, sizeof(byFormationNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFormationNum)
				{
					wArrNum = wArrNum <= MAX_NEW_FORMATION_NUM ? wArrNum : MAX_NEW_FORMATION_NUM;
					byFormationNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFormationArray[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFormationArray, 0, sizeof(astFormationArray));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFormationArray, 0, sizeof(astFormationArray));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NEW_FORMATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_DATA *pstIn = (DT_NEW_FORMATION_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->bySelectIdx))
		return -1;

	if(-1 == EncodeDT_FORMATION_DATA_LIST(&pstIn->stFormationList, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNewSelectIdx))
		return -1;

	if(-1 == EncodeDT_NEW_FORMATION_DATA_LST(&pstIn->stNewFormationLst, poNetData))
		return -1;

	if(-1 == EncodeDT_NEW_FORMATION_DATA_LST(&pstIn->stLockFormationLst, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsUseNewFormation))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NEW_FORMATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_NEW_FORMATION_DATA *pstOut = (DT_NEW_FORMATION_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->bySelectIdx))
		return -1;

	if(-1 == DecodeDT_FORMATION_DATA_LIST(&pstOut->stFormationList, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNewSelectIdx))
		return -1;

	if(-1 == DecodeDT_NEW_FORMATION_DATA_LST(&pstOut->stNewFormationLst, poNetData))
		return -1;

	if(-1 == DecodeDT_NEW_FORMATION_DATA_LST(&pstOut->stLockFormationLst, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsUseNewFormation))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NEW_FORMATION_DATA(DT_NEW_FORMATION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SelectIdx", (double)(data.bySelectIdx));
	cJSON_AddItemToObject(root, "FormationList", GetJsonDT_FORMATION_DATA_LIST(data.stFormationList));
	cJSON_AddNumberToObject(root,"NewSelectIdx", (double)(data.byNewSelectIdx));
	cJSON_AddItemToObject(root, "NewFormationLst", GetJsonDT_NEW_FORMATION_DATA_LST(data.stNewFormationLst));
	cJSON_AddItemToObject(root, "LockFormationLst", GetJsonDT_NEW_FORMATION_DATA_LST(data.stLockFormationLst));
	cJSON_AddNumberToObject(root,"IsUseNewFormation", (double)(data.byIsUseNewFormation));

	return root;
}

INT32 DT_NEW_FORMATION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(bySelectIdx);
	memcpy(pDataBuff + dwOffset, &bySelectIdx, sizeof(bySelectIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stFormationList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byNewSelectIdx);
	memcpy(pDataBuff + dwOffset, &byNewSelectIdx, sizeof(byNewSelectIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stNewFormationLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stLockFormationLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byIsUseNewFormation);
	memcpy(pDataBuff + dwOffset, &byIsUseNewFormation, sizeof(byIsUseNewFormation));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NEW_FORMATION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(bySelectIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&bySelectIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySelectIdx, 0, sizeof(bySelectIdx));
				}
			}
			break;
		case 2:
			{
				stFormationList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(byNewSelectIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byNewSelectIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNewSelectIdx, 0, sizeof(byNewSelectIdx));
				}
			}
			break;
		case 4:
			{
				stNewFormationLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stLockFormationLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				if(sizeof(byIsUseNewFormation) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsUseNewFormation, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsUseNewFormation, 0, sizeof(byIsUseNewFormation));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_VERSION_DATA(void *pHost, CNetData* poNetData)
{
	DT_VERSION_DATA *pstIn = (DT_VERSION_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwVersionID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byForceUpdateFlag))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszUpdateContent, sizeof(pstIn->aszUpdateContent)))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszUpdateURL, sizeof(pstIn->aszUpdateURL)))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_VERSION_DATA(void *pHost, CNetData* poNetData)
{
	DT_VERSION_DATA *pstOut = (DT_VERSION_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwVersionID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byForceUpdateFlag))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszUpdateContent, sizeof(pstOut->aszUpdateContent)))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszUpdateURL, sizeof(pstOut->aszUpdateURL)))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_VERSION_DATA(DT_VERSION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"VersionID", (double)(data.dwVersionID));
	cJSON_AddNumberToObject(root,"ForceUpdateFlag", (double)(data.byForceUpdateFlag));
	cJSON_AddStringToObject(root,"UpdateContent", data.aszUpdateContent );
	cJSON_AddStringToObject(root,"UpdateURL", data.aszUpdateURL );

	return root;
}

INT32 DT_VERSION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwVersionID);
	memcpy(pDataBuff + dwOffset, &dwVersionID, sizeof(dwVersionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byForceUpdateFlag);
	memcpy(pDataBuff + dwOffset, &byForceUpdateFlag, sizeof(byForceUpdateFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszUpdateContent) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_CONTENT_SIZE;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszUpdateContent, sizeof(aszUpdateContent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszUpdateURL) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_CONTENT_SIZE;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszUpdateURL, sizeof(aszUpdateURL));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_VERSION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwVersionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwVersionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwVersionID, 0, sizeof(dwVersionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byForceUpdateFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byForceUpdateFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byForceUpdateFlag, 0, sizeof(byForceUpdateFlag));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszUpdateContent) >= dwContextLen) && (wArrNum <= MAX_CONTENT_SIZE))
				{
					memcpy(&aszUpdateContent, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszUpdateContent, 0, sizeof(aszUpdateContent));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszUpdateURL) >= dwContextLen) && (wArrNum <= MAX_CONTENT_SIZE))
				{
					memcpy(&aszUpdateURL, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszUpdateURL, 0, sizeof(aszUpdateURL));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NOTICE_DATA(void *pHost, CNetData* poNetData)
{
	DT_NOTICE_DATA *pstIn = (DT_NOTICE_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwNoticeID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byForcePopFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUrlFlag))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszNoticeContent, sizeof(pstIn->aszNoticeContent)))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NOTICE_DATA(void *pHost, CNetData* poNetData)
{
	DT_NOTICE_DATA *pstOut = (DT_NOTICE_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwNoticeID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byForcePopFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUrlFlag))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszNoticeContent, sizeof(pstOut->aszNoticeContent)))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NOTICE_DATA(DT_NOTICE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"NoticeID", (double)(data.dwNoticeID));
	cJSON_AddNumberToObject(root,"ForcePopFlag", (double)(data.byForcePopFlag));
	cJSON_AddNumberToObject(root,"UrlFlag", (double)(data.byUrlFlag));
	cJSON_AddStringToObject(root,"NoticeContent", data.aszNoticeContent );

	return root;
}

INT32 DT_NOTICE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwNoticeID);
	memcpy(pDataBuff + dwOffset, &dwNoticeID, sizeof(dwNoticeID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byForcePopFlag);
	memcpy(pDataBuff + dwOffset, &byForcePopFlag, sizeof(byForcePopFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byUrlFlag);
	memcpy(pDataBuff + dwOffset, &byUrlFlag, sizeof(byUrlFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszNoticeContent) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_CONTENT_SIZE;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszNoticeContent, sizeof(aszNoticeContent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NOTICE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwNoticeID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwNoticeID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwNoticeID, 0, sizeof(dwNoticeID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byForcePopFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byForcePopFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byForcePopFlag, 0, sizeof(byForcePopFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byUrlFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byUrlFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUrlFlag, 0, sizeof(byUrlFlag));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszNoticeContent) >= dwContextLen) && (wArrNum <= MAX_CONTENT_SIZE))
				{
					memcpy(&aszNoticeContent, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszNoticeContent, 0, sizeof(aszNoticeContent));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NOTICE_DATA_DB(void *pHost, CNetData* poNetData)
{
	DT_NOTICE_DATA_DB *pstIn = (DT_NOTICE_DATA_DB*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwNoticeID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byForcePopFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUrlFlag))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszNoticeContent, sizeof(pstIn->aszNoticeContent)))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwExpiresTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwBeginChannelID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEndChannelID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NOTICE_DATA_DB(void *pHost, CNetData* poNetData)
{
	DT_NOTICE_DATA_DB *pstOut = (DT_NOTICE_DATA_DB*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwNoticeID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byForcePopFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUrlFlag))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszNoticeContent, sizeof(pstOut->aszNoticeContent)))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwExpiresTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwBeginChannelID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEndChannelID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NOTICE_DATA_DB(DT_NOTICE_DATA_DB &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"NoticeID", (double)(data.dwNoticeID));
	cJSON_AddNumberToObject(root,"ForcePopFlag", (double)(data.byForcePopFlag));
	cJSON_AddNumberToObject(root,"UrlFlag", (double)(data.byUrlFlag));
	cJSON_AddStringToObject(root,"NoticeContent", data.aszNoticeContent );
	cJSON_AddNumberToObject(root,"ExpiresTime", (double)(data.qwExpiresTime));
	cJSON_AddNumberToObject(root,"BeginChannelID", (double)(data.dwBeginChannelID));
	cJSON_AddNumberToObject(root,"EndChannelID", (double)(data.dwEndChannelID));

	return root;
}

INT32 DT_NOTICE_DATA_DB::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwNoticeID);
	memcpy(pDataBuff + dwOffset, &dwNoticeID, sizeof(dwNoticeID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byForcePopFlag);
	memcpy(pDataBuff + dwOffset, &byForcePopFlag, sizeof(byForcePopFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byUrlFlag);
	memcpy(pDataBuff + dwOffset, &byUrlFlag, sizeof(byUrlFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszNoticeContent) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_NOTICE_CONTENT_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszNoticeContent, sizeof(aszNoticeContent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwExpiresTime);
	memcpy(pDataBuff + dwOffset, &qwExpiresTime, sizeof(qwExpiresTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwBeginChannelID);
	memcpy(pDataBuff + dwOffset, &dwBeginChannelID, sizeof(dwBeginChannelID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwEndChannelID);
	memcpy(pDataBuff + dwOffset, &dwEndChannelID, sizeof(dwEndChannelID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NOTICE_DATA_DB::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwNoticeID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwNoticeID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwNoticeID, 0, sizeof(dwNoticeID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byForcePopFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byForcePopFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byForcePopFlag, 0, sizeof(byForcePopFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byUrlFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byUrlFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUrlFlag, 0, sizeof(byUrlFlag));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszNoticeContent) >= dwContextLen) && (wArrNum <= MAX_NOTICE_CONTENT_LEN))
				{
					memcpy(&aszNoticeContent, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszNoticeContent, 0, sizeof(aszNoticeContent));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwExpiresTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwExpiresTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwExpiresTime, 0, sizeof(qwExpiresTime));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwBeginChannelID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBeginChannelID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBeginChannelID, 0, sizeof(dwBeginChannelID));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwEndChannelID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEndChannelID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEndChannelID, 0, sizeof(dwEndChannelID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NOTICE_DATA_NEW(void *pHost, CNetData* poNetData)
{
	DT_NOTICE_DATA_NEW *pstIn = (DT_NOTICE_DATA_NEW*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwNoticeID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byForcePopFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUrlFlag))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszNoticeContent, sizeof(pstIn->aszNoticeContent)))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NOTICE_DATA_NEW(void *pHost, CNetData* poNetData)
{
	DT_NOTICE_DATA_NEW *pstOut = (DT_NOTICE_DATA_NEW*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwNoticeID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byForcePopFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUrlFlag))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszNoticeContent, sizeof(pstOut->aszNoticeContent)))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NOTICE_DATA_NEW(DT_NOTICE_DATA_NEW &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"NoticeID", (double)(data.dwNoticeID));
	cJSON_AddNumberToObject(root,"ForcePopFlag", (double)(data.byForcePopFlag));
	cJSON_AddNumberToObject(root,"UrlFlag", (double)(data.byUrlFlag));
	cJSON_AddStringToObject(root,"NoticeContent", data.aszNoticeContent );

	return root;
}

INT32 DT_NOTICE_DATA_NEW::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwNoticeID);
	memcpy(pDataBuff + dwOffset, &dwNoticeID, sizeof(dwNoticeID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byForcePopFlag);
	memcpy(pDataBuff + dwOffset, &byForcePopFlag, sizeof(byForcePopFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byUrlFlag);
	memcpy(pDataBuff + dwOffset, &byUrlFlag, sizeof(byUrlFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszNoticeContent) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_NOTICE_CONTENT_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszNoticeContent, sizeof(aszNoticeContent));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NOTICE_DATA_NEW::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwNoticeID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwNoticeID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwNoticeID, 0, sizeof(dwNoticeID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byForcePopFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byForcePopFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byForcePopFlag, 0, sizeof(byForcePopFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byUrlFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byUrlFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUrlFlag, 0, sizeof(byUrlFlag));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszNoticeContent) >= dwContextLen) && (wArrNum <= MAX_NOTICE_CONTENT_LEN))
				{
					memcpy(&aszNoticeContent, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszNoticeContent, 0, sizeof(aszNoticeContent));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EAT_BREAD_DATA(void *pHost, CNetData* poNetData)
{
	DT_EAT_BREAD_DATA *pstIn = (DT_EAT_BREAD_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwEnterTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveObtainPhyStrengthen))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHaveObtainCoin))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveLeaveFlag))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHaveUseTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveGivePhyStrengthen))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHaveGiveCoin))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNotity))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EAT_BREAD_DATA(void *pHost, CNetData* poNetData)
{
	DT_EAT_BREAD_DATA *pstOut = (DT_EAT_BREAD_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwEnterTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveObtainPhyStrengthen))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHaveObtainCoin))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveLeaveFlag))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHaveUseTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveGivePhyStrengthen))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHaveGiveCoin))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNotity))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EAT_BREAD_DATA(DT_EAT_BREAD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"EnterTime", (double)(data.qwEnterTime));
	cJSON_AddNumberToObject(root,"HaveObtainPhyStrengthen", (double)(data.byHaveObtainPhyStrengthen));
	cJSON_AddNumberToObject(root,"HaveObtainCoin", (double)(data.dwHaveObtainCoin));
	cJSON_AddNumberToObject(root,"HaveLeaveFlag", (double)(data.byHaveLeaveFlag));
	cJSON_AddNumberToObject(root,"HaveUseTime", (double)(data.wHaveUseTime));
	cJSON_AddNumberToObject(root,"HaveGivePhyStrengthen", (double)(data.byHaveGivePhyStrengthen));
	cJSON_AddNumberToObject(root,"HaveGiveCoin", (double)(data.dwHaveGiveCoin));
	cJSON_AddNumberToObject(root,"Notity", (double)(data.byNotity));

	return root;
}

INT32 DT_EAT_BREAD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwEnterTime);
	memcpy(pDataBuff + dwOffset, &qwEnterTime, sizeof(qwEnterTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byHaveObtainPhyStrengthen);
	memcpy(pDataBuff + dwOffset, &byHaveObtainPhyStrengthen, sizeof(byHaveObtainPhyStrengthen));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwHaveObtainCoin);
	memcpy(pDataBuff + dwOffset, &dwHaveObtainCoin, sizeof(dwHaveObtainCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byHaveLeaveFlag);
	memcpy(pDataBuff + dwOffset, &byHaveLeaveFlag, sizeof(byHaveLeaveFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wHaveUseTime);
	memcpy(pDataBuff + dwOffset, &wHaveUseTime, sizeof(wHaveUseTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byHaveGivePhyStrengthen);
	memcpy(pDataBuff + dwOffset, &byHaveGivePhyStrengthen, sizeof(byHaveGivePhyStrengthen));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwHaveGiveCoin);
	memcpy(pDataBuff + dwOffset, &dwHaveGiveCoin, sizeof(dwHaveGiveCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byNotity);
	memcpy(pDataBuff + dwOffset, &byNotity, sizeof(byNotity));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EAT_BREAD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwEnterTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwEnterTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwEnterTime, 0, sizeof(qwEnterTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byHaveObtainPhyStrengthen) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveObtainPhyStrengthen, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveObtainPhyStrengthen, 0, sizeof(byHaveObtainPhyStrengthen));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwHaveObtainCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHaveObtainCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHaveObtainCoin, 0, sizeof(dwHaveObtainCoin));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byHaveLeaveFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveLeaveFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveLeaveFlag, 0, sizeof(byHaveLeaveFlag));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wHaveUseTime) >= pstIndex->dwContextLen)
				{
					memcpy(&wHaveUseTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHaveUseTime, 0, sizeof(wHaveUseTime));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byHaveGivePhyStrengthen) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveGivePhyStrengthen, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveGivePhyStrengthen, 0, sizeof(byHaveGivePhyStrengthen));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwHaveGiveCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHaveGiveCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHaveGiveCoin, 0, sizeof(dwHaveGiveCoin));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byNotity) >= pstIndex->dwContextLen)
				{
					memcpy(&byNotity, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNotity, 0, sizeof(byNotity));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_YABIAO_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_BASE_DATA *pstIn = (DT_YABIAO_BASE_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastYabiaoTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAlreadyYabiaoCount))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byQuality))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBeJiebiaoCount))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBiaoRunTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBiaoFlushCount))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byYabiaoFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAlreadyJiebiaoCount))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastJiebiaoTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastEncourageCoin))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastEncourageScience))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBeJiebiaoTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastEncourageJingjie))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwJiebiaoDecCoin))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwJiebiaoDecScience))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAlreadyFlushBiaoCnt))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastFlushTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_YABIAO_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_BASE_DATA *pstOut = (DT_YABIAO_BASE_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastYabiaoTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAlreadyYabiaoCount))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byQuality))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBeJiebiaoCount))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBiaoRunTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBiaoFlushCount))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byYabiaoFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAlreadyJiebiaoCount))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastJiebiaoTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastEncourageCoin))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastEncourageScience))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBeJiebiaoTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastEncourageJingjie))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwJiebiaoDecCoin))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwJiebiaoDecScience))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAlreadyFlushBiaoCnt))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastFlushTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_YABIAO_BASE_DATA(DT_YABIAO_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastYabiaoTime", (double)(data.qwLastYabiaoTime));
	cJSON_AddNumberToObject(root,"AlreadyYabiaoCount", (double)(data.byAlreadyYabiaoCount));
	cJSON_AddNumberToObject(root,"Quality", (double)(data.byQuality));
	cJSON_AddNumberToObject(root,"BeJiebiaoCount", (double)(data.byBeJiebiaoCount));
	cJSON_AddNumberToObject(root,"BiaoRunTime", (double)(data.wBiaoRunTime));
	cJSON_AddNumberToObject(root,"BiaoFlushCount", (double)(data.wBiaoFlushCount));
	cJSON_AddNumberToObject(root,"YabiaoFlag", (double)(data.byYabiaoFlag));
	cJSON_AddNumberToObject(root,"AlreadyJiebiaoCount", (double)(data.byAlreadyJiebiaoCount));
	cJSON_AddNumberToObject(root,"LastJiebiaoTime", (double)(data.qwLastJiebiaoTime));
	cJSON_AddNumberToObject(root,"LastEncourageCoin", (double)(data.qwLastEncourageCoin));
	cJSON_AddNumberToObject(root,"LastEncourageScience", (double)(data.qwLastEncourageScience));
	cJSON_AddNumberToObject(root,"BeJiebiaoTime", (double)(data.qwBeJiebiaoTime));
	cJSON_AddNumberToObject(root,"LastEncourageJingjie", (double)(data.qwLastEncourageJingjie));
	cJSON_AddNumberToObject(root,"JiebiaoDecCoin", (double)(data.dwJiebiaoDecCoin));
	cJSON_AddNumberToObject(root,"JiebiaoDecScience", (double)(data.dwJiebiaoDecScience));
	cJSON_AddNumberToObject(root,"AlreadyFlushBiaoCnt", (double)(data.dwAlreadyFlushBiaoCnt));
	cJSON_AddNumberToObject(root,"LastFlushTime", (double)(data.qwLastFlushTime));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_YABIAO_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 18;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastYabiaoTime);
	memcpy(pDataBuff + dwOffset, &qwLastYabiaoTime, sizeof(qwLastYabiaoTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byAlreadyYabiaoCount);
	memcpy(pDataBuff + dwOffset, &byAlreadyYabiaoCount, sizeof(byAlreadyYabiaoCount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byQuality);
	memcpy(pDataBuff + dwOffset, &byQuality, sizeof(byQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byBeJiebiaoCount);
	memcpy(pDataBuff + dwOffset, &byBeJiebiaoCount, sizeof(byBeJiebiaoCount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wBiaoRunTime);
	memcpy(pDataBuff + dwOffset, &wBiaoRunTime, sizeof(wBiaoRunTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wBiaoFlushCount);
	memcpy(pDataBuff + dwOffset, &wBiaoFlushCount, sizeof(wBiaoFlushCount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byYabiaoFlag);
	memcpy(pDataBuff + dwOffset, &byYabiaoFlag, sizeof(byYabiaoFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byAlreadyJiebiaoCount);
	memcpy(pDataBuff + dwOffset, &byAlreadyJiebiaoCount, sizeof(byAlreadyJiebiaoCount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwLastJiebiaoTime);
	memcpy(pDataBuff + dwOffset, &qwLastJiebiaoTime, sizeof(qwLastJiebiaoTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(qwLastEncourageCoin);
	memcpy(pDataBuff + dwOffset, &qwLastEncourageCoin, sizeof(qwLastEncourageCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(qwLastEncourageScience);
	memcpy(pDataBuff + dwOffset, &qwLastEncourageScience, sizeof(qwLastEncourageScience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(qwBeJiebiaoTime);
	memcpy(pDataBuff + dwOffset, &qwBeJiebiaoTime, sizeof(qwBeJiebiaoTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(qwLastEncourageJingjie);
	memcpy(pDataBuff + dwOffset, &qwLastEncourageJingjie, sizeof(qwLastEncourageJingjie));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(dwJiebiaoDecCoin);
	memcpy(pDataBuff + dwOffset, &dwJiebiaoDecCoin, sizeof(dwJiebiaoDecCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(dwJiebiaoDecScience);
	memcpy(pDataBuff + dwOffset, &dwJiebiaoDecScience, sizeof(dwJiebiaoDecScience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = sizeof(dwAlreadyFlushBiaoCnt);
	memcpy(pDataBuff + dwOffset, &dwAlreadyFlushBiaoCnt, sizeof(dwAlreadyFlushBiaoCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(qwLastFlushTime);
	memcpy(pDataBuff + dwOffset, &qwLastFlushTime, sizeof(qwLastFlushTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_YABIAO_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastYabiaoTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastYabiaoTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastYabiaoTime, 0, sizeof(qwLastYabiaoTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byAlreadyYabiaoCount) >= pstIndex->dwContextLen)
				{
					memcpy(&byAlreadyYabiaoCount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAlreadyYabiaoCount, 0, sizeof(byAlreadyYabiaoCount));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&byQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byQuality, 0, sizeof(byQuality));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byBeJiebiaoCount) >= pstIndex->dwContextLen)
				{
					memcpy(&byBeJiebiaoCount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBeJiebiaoCount, 0, sizeof(byBeJiebiaoCount));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wBiaoRunTime) >= pstIndex->dwContextLen)
				{
					memcpy(&wBiaoRunTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBiaoRunTime, 0, sizeof(wBiaoRunTime));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wBiaoFlushCount) >= pstIndex->dwContextLen)
				{
					memcpy(&wBiaoFlushCount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBiaoFlushCount, 0, sizeof(wBiaoFlushCount));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byYabiaoFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byYabiaoFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byYabiaoFlag, 0, sizeof(byYabiaoFlag));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byAlreadyJiebiaoCount) >= pstIndex->dwContextLen)
				{
					memcpy(&byAlreadyJiebiaoCount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAlreadyJiebiaoCount, 0, sizeof(byAlreadyJiebiaoCount));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwLastJiebiaoTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastJiebiaoTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastJiebiaoTime, 0, sizeof(qwLastJiebiaoTime));
				}
			}
			break;
		case 10:
			{
				if(sizeof(qwLastEncourageCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastEncourageCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastEncourageCoin, 0, sizeof(qwLastEncourageCoin));
				}
			}
			break;
		case 11:
			{
				if(sizeof(qwLastEncourageScience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastEncourageScience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastEncourageScience, 0, sizeof(qwLastEncourageScience));
				}
			}
			break;
		case 12:
			{
				if(sizeof(qwBeJiebiaoTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBeJiebiaoTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBeJiebiaoTime, 0, sizeof(qwBeJiebiaoTime));
				}
			}
			break;
		case 13:
			{
				if(sizeof(qwLastEncourageJingjie) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastEncourageJingjie, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastEncourageJingjie, 0, sizeof(qwLastEncourageJingjie));
				}
			}
			break;
		case 14:
			{
				if(sizeof(dwJiebiaoDecCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&dwJiebiaoDecCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwJiebiaoDecCoin, 0, sizeof(dwJiebiaoDecCoin));
				}
			}
			break;
		case 15:
			{
				if(sizeof(dwJiebiaoDecScience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwJiebiaoDecScience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwJiebiaoDecScience, 0, sizeof(dwJiebiaoDecScience));
				}
			}
			break;
		case 16:
			{
				if(sizeof(dwAlreadyFlushBiaoCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAlreadyFlushBiaoCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAlreadyFlushBiaoCnt, 0, sizeof(dwAlreadyFlushBiaoCnt));
				}
			}
			break;
		case 17:
			{
				if(sizeof(qwLastFlushTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastFlushTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastFlushTime, 0, sizeof(qwLastFlushTime));
				}
			}
			break;
		case 18:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_YABIAO_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_BATTLELOG_DATA *pstIn = (DT_YABIAO_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBattleTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEnemyPlayerID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byResult))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCoinChange))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwScienceChange))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNewFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBattleDataIndex))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byQuality))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwJingjieChange))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_YABIAO_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_BATTLELOG_DATA *pstOut = (DT_YABIAO_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBattleTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEnemyPlayerID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byResult))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCoinChange))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwScienceChange))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNewFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBattleDataIndex))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byQuality))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwJingjieChange))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_YABIAO_BATTLELOG_DATA(DT_YABIAO_BATTLELOG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Flag", (double)(data.byFlag));
	cJSON_AddNumberToObject(root,"BattleTime", (double)(data.qwBattleTime));
	cJSON_AddNumberToObject(root,"EnemyPlayerID", (double)(data.dwEnemyPlayerID));
	cJSON_AddNumberToObject(root,"Result", (double)(data.byResult));
	cJSON_AddNumberToObject(root,"CoinChange", (double)(data.dwCoinChange));
	cJSON_AddNumberToObject(root,"ScienceChange", (double)(data.dwScienceChange));
	cJSON_AddNumberToObject(root,"NewFlag", (double)(data.byNewFlag));
	cJSON_AddNumberToObject(root,"BattleDataIndex", (double)(data.qwBattleDataIndex));
	cJSON_AddNumberToObject(root,"Quality", (double)(data.byQuality));
	cJSON_AddNumberToObject(root,"JingjieChange", (double)(data.dwJingjieChange));

	return root;
}

INT32 DT_YABIAO_BATTLELOG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFlag);
	memcpy(pDataBuff + dwOffset, &byFlag, sizeof(byFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwBattleTime);
	memcpy(pDataBuff + dwOffset, &qwBattleTime, sizeof(qwBattleTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwEnemyPlayerID);
	memcpy(pDataBuff + dwOffset, &dwEnemyPlayerID, sizeof(dwEnemyPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byResult);
	memcpy(pDataBuff + dwOffset, &byResult, sizeof(byResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwCoinChange);
	memcpy(pDataBuff + dwOffset, &dwCoinChange, sizeof(dwCoinChange));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwScienceChange);
	memcpy(pDataBuff + dwOffset, &dwScienceChange, sizeof(dwScienceChange));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byNewFlag);
	memcpy(pDataBuff + dwOffset, &byNewFlag, sizeof(byNewFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(qwBattleDataIndex);
	memcpy(pDataBuff + dwOffset, &qwBattleDataIndex, sizeof(qwBattleDataIndex));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byQuality);
	memcpy(pDataBuff + dwOffset, &byQuality, sizeof(byQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(dwJingjieChange);
	memcpy(pDataBuff + dwOffset, &dwJingjieChange, sizeof(dwJingjieChange));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_YABIAO_BATTLELOG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFlag, 0, sizeof(byFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwBattleTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBattleTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBattleTime, 0, sizeof(qwBattleTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwEnemyPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEnemyPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEnemyPlayerID, 0, sizeof(dwEnemyPlayerID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResult, 0, sizeof(byResult));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwCoinChange) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCoinChange, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCoinChange, 0, sizeof(dwCoinChange));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwScienceChange) >= pstIndex->dwContextLen)
				{
					memcpy(&dwScienceChange, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwScienceChange, 0, sizeof(dwScienceChange));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byNewFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byNewFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNewFlag, 0, sizeof(byNewFlag));
				}
			}
			break;
		case 8:
			{
				if(sizeof(qwBattleDataIndex) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBattleDataIndex, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBattleDataIndex, 0, sizeof(qwBattleDataIndex));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&byQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byQuality, 0, sizeof(byQuality));
				}
			}
			break;
		case 10:
			{
				if(sizeof(dwJingjieChange) >= pstIndex->dwContextLen)
				{
					memcpy(&dwJingjieChange, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwJingjieChange, 0, sizeof(dwJingjieChange));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_YABIAO_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_BATTLELOG_DATA_LIST *pstIn = (DT_YABIAO_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBattleLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_YABIAO_BATTLELOG_NUM; i++)
	{
		if(i >= (INT32)pstIn->byBattleLogNum)
			break;
		if(-1 == EncodeDT_YABIAO_BATTLELOG_DATA(&pstIn->astPaoshangBattleLogInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_YABIAO_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_BATTLELOG_DATA_LIST *pstOut = (DT_YABIAO_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBattleLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_YABIAO_BATTLELOG_NUM; i++)
	{
		if(i >= (INT32)pstOut->byBattleLogNum)
			break;
		if(-1 == DecodeDT_YABIAO_BATTLELOG_DATA(&pstOut->astPaoshangBattleLogInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_YABIAO_BATTLELOG_DATA_LIST(DT_YABIAO_BATTLELOG_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BattleLogNum", (double)(data.byBattleLogNum));
	cJSON *PaoshangBattleLogInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PaoshangBattleLogInfo", PaoshangBattleLogInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byBattleLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(PaoshangBattleLogInfo, " ", GetJsonDT_YABIAO_BATTLELOG_DATA(data.astPaoshangBattleLogInfo[dwIndex]));
	}

	return root;
}

INT32 DT_YABIAO_BATTLELOG_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBattleLogNum);
	memcpy(pDataBuff + dwOffset, &byBattleLogNum, sizeof(byBattleLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byBattleLogNum > MAX_YABIAO_BATTLELOG_NUM)
	{
		byBattleLogNum = MAX_YABIAO_BATTLELOG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byBattleLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byBattleLogNum; i++)
	{
		dwContextLenTmp += astPaoshangBattleLogInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_YABIAO_BATTLELOG_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBattleLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleLogNum, 0, sizeof(byBattleLogNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byBattleLogNum)
				{
					wArrNum = wArrNum <= MAX_YABIAO_BATTLELOG_NUM ? wArrNum : MAX_YABIAO_BATTLELOG_NUM;
					byBattleLogNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPaoshangBattleLogInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPaoshangBattleLogInfo, 0, sizeof(astPaoshangBattleLogInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPaoshangBattleLogInfo, 0, sizeof(astPaoshangBattleLogInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SKILL_ACTION_DATA(void *pHost, CNetData* poNetData)
{
	DT_SKILL_ACTION_DATA *pstIn = (DT_SKILL_ACTION_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SKILL_ACTION_DATA(void *pHost, CNetData* poNetData)
{
	DT_SKILL_ACTION_DATA *pstOut = (DT_SKILL_ACTION_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SKILL_ACTION_DATA(DT_SKILL_ACTION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ID", (double)(data.wID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));

	return root;
}

INT32 DT_SKILL_ACTION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wID);
	memcpy(pDataBuff + dwOffset, &wID, sizeof(wID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SKILL_ACTION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wID) >= pstIndex->dwContextLen)
				{
					memcpy(&wID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wID, 0, sizeof(wID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SKILL_ACTION_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_SKILL_ACTION_DATA_LIST *pstIn = (DT_SKILL_ACTION_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byActionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SKILL_SLOT_NUM; i++)
	{
		if(i >= (INT32)pstIn->byActionNum)
			break;
		if(-1 == EncodeDT_SKILL_ACTION_DATA(&pstIn->astActionInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SKILL_ACTION_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_SKILL_ACTION_DATA_LIST *pstOut = (DT_SKILL_ACTION_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byActionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SKILL_SLOT_NUM; i++)
	{
		if(i >= (INT32)pstOut->byActionNum)
			break;
		if(-1 == DecodeDT_SKILL_ACTION_DATA(&pstOut->astActionInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SKILL_ACTION_DATA_LIST(DT_SKILL_ACTION_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ActionNum", (double)(data.byActionNum));
	cJSON *ActionInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ActionInfo", ActionInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byActionNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ActionInfo, " ", GetJsonDT_SKILL_ACTION_DATA(data.astActionInfo[dwIndex]));
	}

	return root;
}

INT32 DT_SKILL_ACTION_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byActionNum);
	memcpy(pDataBuff + dwOffset, &byActionNum, sizeof(byActionNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byActionNum > MAX_SKILL_SLOT_NUM)
	{
		byActionNum = MAX_SKILL_SLOT_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byActionNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byActionNum; i++)
	{
		dwContextLenTmp += astActionInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SKILL_ACTION_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byActionNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byActionNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActionNum, 0, sizeof(byActionNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byActionNum)
				{
					wArrNum = wArrNum <= MAX_SKILL_SLOT_NUM ? wArrNum : MAX_SKILL_SLOT_NUM;
					byActionNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astActionInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astActionInfo, 0, sizeof(astActionInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astActionInfo, 0, sizeof(astActionInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_JINGJIE_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_JINGJIE_BASE_DATA *pstIn = (DT_JINGJIE_BASE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byCareerID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSubLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_JINGJIE_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_JINGJIE_BASE_DATA *pstOut = (DT_JINGJIE_BASE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byCareerID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSubLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_JINGJIE_BASE_DATA(DT_JINGJIE_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CareerID", (double)(data.byCareerID));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"SubLevel", (double)(data.wSubLevel));

	return root;
}

INT32 DT_JINGJIE_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byCareerID);
	memcpy(pDataBuff + dwOffset, &byCareerID, sizeof(byCareerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wSubLevel);
	memcpy(pDataBuff + dwOffset, &wSubLevel, sizeof(wSubLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_JINGJIE_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byCareerID) >= pstIndex->dwContextLen)
				{
					memcpy(&byCareerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCareerID, 0, sizeof(byCareerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wSubLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wSubLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSubLevel, 0, sizeof(wSubLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GAS_BALL_DATA(void *pHost, CNetData* poNetData)
{
	DT_GAS_BALL_DATA *pstIn = (DT_GAS_BALL_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byKind))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGasValue))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GAS_BALL_DATA(void *pHost, CNetData* poNetData)
{
	DT_GAS_BALL_DATA *pstOut = (DT_GAS_BALL_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byKind))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGasValue))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GAS_BALL_DATA(DT_GAS_BALL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Kind", (double)(data.byKind));
	cJSON_AddNumberToObject(root,"Level", (double)(data.byLevel));
	cJSON_AddNumberToObject(root,"GasValue", (double)(data.dwGasValue));

	return root;
}

INT32 DT_GAS_BALL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byKind);
	memcpy(pDataBuff + dwOffset, &byKind, sizeof(byKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byLevel);
	memcpy(pDataBuff + dwOffset, &byLevel, sizeof(byLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwGasValue);
	memcpy(pDataBuff + dwOffset, &dwGasValue, sizeof(dwGasValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GAS_BALL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKind, 0, sizeof(byKind));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLevel, 0, sizeof(byLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwGasValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGasValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGasValue, 0, sizeof(dwGasValue));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COLLECT_GAS_DATA(void *pHost, CNetData* poNetData)
{
	DT_COLLECT_GAS_DATA *pstIn = (DT_COLLECT_GAS_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byCollectState))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GAS_BALL_NUM; i++)
	{
		if(-1 == EncodeDT_GAS_BALL_DATA(&pstIn->astGasBollInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddWord(pstIn->wLastCoinGenNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastCoinGenTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastCoinRandomUpNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastCoinRandomUpTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastCoinFullNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastCoinFullTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastGoldGenNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastGoldGenTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastGoldRandomUpNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastGoldRandomUpTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastGoldFullUpNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastGoldFullUpTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COLLECT_GAS_DATA(void *pHost, CNetData* poNetData)
{
	DT_COLLECT_GAS_DATA *pstOut = (DT_COLLECT_GAS_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byCollectState))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_GAS_BALL_NUM; i++)
		{
			if(-1 == DecodeDT_GAS_BALL_DATA(&pstOut->astGasBollInfo[i], poNetData))
				return -1;
		}

	if(-1 == poNetData->DelWord(pstOut->wLastCoinGenNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastCoinGenTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastCoinRandomUpNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastCoinRandomUpTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastCoinFullNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastCoinFullTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastGoldGenNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastGoldGenTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastGoldRandomUpNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastGoldRandomUpTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastGoldFullUpNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastGoldFullUpTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COLLECT_GAS_DATA(DT_COLLECT_GAS_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CollectState", (double)(data.byCollectState));
	cJSON *GasBollInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GasBollInfo", GasBollInfo);
	for( UINT32 dwIndex=0; dwIndex<MAX_GAS_BALL_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(GasBollInfo, " ", GetJsonDT_GAS_BALL_DATA(data.astGasBollInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"LastCoinGenNum", (double)(data.wLastCoinGenNum));
	cJSON_AddNumberToObject(root,"LastCoinGenTime", (double)(data.qwLastCoinGenTime));
	cJSON_AddNumberToObject(root,"LastCoinRandomUpNum", (double)(data.wLastCoinRandomUpNum));
	cJSON_AddNumberToObject(root,"LastCoinRandomUpTime", (double)(data.qwLastCoinRandomUpTime));
	cJSON_AddNumberToObject(root,"LastCoinFullNum", (double)(data.byLastCoinFullNum));
	cJSON_AddNumberToObject(root,"LastCoinFullTime", (double)(data.qwLastCoinFullTime));
	cJSON_AddNumberToObject(root,"LastGoldGenNum", (double)(data.wLastGoldGenNum));
	cJSON_AddNumberToObject(root,"LastGoldGenTime", (double)(data.qwLastGoldGenTime));
	cJSON_AddNumberToObject(root,"LastGoldRandomUpNum", (double)(data.wLastGoldRandomUpNum));
	cJSON_AddNumberToObject(root,"LastGoldRandomUpTime", (double)(data.qwLastGoldRandomUpTime));
	cJSON_AddNumberToObject(root,"LastGoldFullUpNum", (double)(data.byLastGoldFullUpNum));
	cJSON_AddNumberToObject(root,"LastGoldFullUpTime", (double)(data.qwLastGoldFullUpTime));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_COLLECT_GAS_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 15;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byCollectState);
	memcpy(pDataBuff + dwOffset, &byCollectState, sizeof(byCollectState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_GAS_BALL_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_GAS_BALL_NUM; i++)
	{
		dwContextLenTmp += astGasBollInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wLastCoinGenNum);
	memcpy(pDataBuff + dwOffset, &wLastCoinGenNum, sizeof(wLastCoinGenNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwLastCoinGenTime);
	memcpy(pDataBuff + dwOffset, &qwLastCoinGenTime, sizeof(qwLastCoinGenTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wLastCoinRandomUpNum);
	memcpy(pDataBuff + dwOffset, &wLastCoinRandomUpNum, sizeof(wLastCoinRandomUpNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(qwLastCoinRandomUpTime);
	memcpy(pDataBuff + dwOffset, &qwLastCoinRandomUpTime, sizeof(qwLastCoinRandomUpTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byLastCoinFullNum);
	memcpy(pDataBuff + dwOffset, &byLastCoinFullNum, sizeof(byLastCoinFullNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(qwLastCoinFullTime);
	memcpy(pDataBuff + dwOffset, &qwLastCoinFullTime, sizeof(qwLastCoinFullTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wLastGoldGenNum);
	memcpy(pDataBuff + dwOffset, &wLastGoldGenNum, sizeof(wLastGoldGenNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(qwLastGoldGenTime);
	memcpy(pDataBuff + dwOffset, &qwLastGoldGenTime, sizeof(qwLastGoldGenTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(wLastGoldRandomUpNum);
	memcpy(pDataBuff + dwOffset, &wLastGoldRandomUpNum, sizeof(wLastGoldRandomUpNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(qwLastGoldRandomUpTime);
	memcpy(pDataBuff + dwOffset, &qwLastGoldRandomUpTime, sizeof(qwLastGoldRandomUpTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(byLastGoldFullUpNum);
	memcpy(pDataBuff + dwOffset, &byLastGoldFullUpNum, sizeof(byLastGoldFullUpNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(qwLastGoldFullUpTime);
	memcpy(pDataBuff + dwOffset, &qwLastGoldFullUpTime, sizeof(qwLastGoldFullUpTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COLLECT_GAS_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byCollectState) >= pstIndex->dwContextLen)
				{
					memcpy(&byCollectState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCollectState, 0, sizeof(byCollectState));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_GAS_BALL_NUM ? wArrNum : MAX_GAS_BALL_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astGasBollInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astGasBollInfo, 0, sizeof(astGasBollInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 3:
			{
				if(sizeof(wLastCoinGenNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastCoinGenNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastCoinGenNum, 0, sizeof(wLastCoinGenNum));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwLastCoinGenTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastCoinGenTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastCoinGenTime, 0, sizeof(qwLastCoinGenTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wLastCoinRandomUpNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastCoinRandomUpNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastCoinRandomUpNum, 0, sizeof(wLastCoinRandomUpNum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(qwLastCoinRandomUpTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastCoinRandomUpTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastCoinRandomUpTime, 0, sizeof(qwLastCoinRandomUpTime));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byLastCoinFullNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastCoinFullNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastCoinFullNum, 0, sizeof(byLastCoinFullNum));
				}
			}
			break;
		case 8:
			{
				if(sizeof(qwLastCoinFullTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastCoinFullTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastCoinFullTime, 0, sizeof(qwLastCoinFullTime));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wLastGoldGenNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastGoldGenNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastGoldGenNum, 0, sizeof(wLastGoldGenNum));
				}
			}
			break;
		case 10:
			{
				if(sizeof(qwLastGoldGenTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastGoldGenTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastGoldGenTime, 0, sizeof(qwLastGoldGenTime));
				}
			}
			break;
		case 11:
			{
				if(sizeof(wLastGoldRandomUpNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastGoldRandomUpNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastGoldRandomUpNum, 0, sizeof(wLastGoldRandomUpNum));
				}
			}
			break;
		case 12:
			{
				if(sizeof(qwLastGoldRandomUpTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastGoldRandomUpTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastGoldRandomUpTime, 0, sizeof(qwLastGoldRandomUpTime));
				}
			}
			break;
		case 13:
			{
				if(sizeof(byLastGoldFullUpNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastGoldFullUpNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastGoldFullUpNum, 0, sizeof(byLastGoldFullUpNum));
				}
			}
			break;
		case 14:
			{
				if(sizeof(qwLastGoldFullUpTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastGoldFullUpTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastGoldFullUpTime, 0, sizeof(qwLastGoldFullUpTime));
				}
			}
			break;
		case 15:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_JINGJIE_DATA(void *pHost, CNetData* poNetData)
{
	DT_JINGJIE_DATA *pstIn = (DT_JINGJIE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == EncodeDT_JINGJIE_BASE_DATA(&pstIn->stBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_COLLECT_GAS_DATA(&pstIn->stCollectData, poNetData))
		return -1;

	if(-1 == EncodeDT_SKILL_ACTION_DATA_LIST(&pstIn->stSkillActionData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_JINGJIE_DATA(void *pHost, CNetData* poNetData)
{
	DT_JINGJIE_DATA *pstOut = (DT_JINGJIE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == DecodeDT_JINGJIE_BASE_DATA(&pstOut->stBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_COLLECT_GAS_DATA(&pstOut->stCollectData, poNetData))
		return -1;

	if(-1 == DecodeDT_SKILL_ACTION_DATA_LIST(&pstOut->stSkillActionData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_JINGJIE_DATA(DT_JINGJIE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddItemToObject(root, "BaseData", GetJsonDT_JINGJIE_BASE_DATA(data.stBaseData));
	cJSON_AddItemToObject(root, "CollectData", GetJsonDT_COLLECT_GAS_DATA(data.stCollectData));
	cJSON_AddItemToObject(root, "SkillActionData", GetJsonDT_SKILL_ACTION_DATA_LIST(data.stSkillActionData));

	return root;
}

INT32 DT_JINGJIE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stCollectData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stSkillActionData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_JINGJIE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				stBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stCollectData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stSkillActionData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CLIMB_TOWER_DATA(void *pHost, CNetData* poNetData)
{
	DT_CLIMB_TOWER_DATA *pstIn = (DT_CLIMB_TOWER_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wResetClimbTownNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwResetClimbTownTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBuyResetClimbTownNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBuyResetClimbTownTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byClimbTownInstance))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CLIMB_TOWER_DATA(void *pHost, CNetData* poNetData)
{
	DT_CLIMB_TOWER_DATA *pstOut = (DT_CLIMB_TOWER_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wResetClimbTownNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwResetClimbTownTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBuyResetClimbTownNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBuyResetClimbTownTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byClimbTownInstance))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CLIMB_TOWER_DATA(DT_CLIMB_TOWER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ResetClimbTownNum", (double)(data.wResetClimbTownNum));
	cJSON_AddNumberToObject(root,"ResetClimbTownTime", (double)(data.qwResetClimbTownTime));
	cJSON_AddNumberToObject(root,"BuyResetClimbTownNum", (double)(data.wBuyResetClimbTownNum));
	cJSON_AddNumberToObject(root,"BuyResetClimbTownTime", (double)(data.qwBuyResetClimbTownTime));
	cJSON_AddNumberToObject(root,"ClimbTownInstance", (double)(data.byClimbTownInstance));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_CLIMB_TOWER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wResetClimbTownNum);
	memcpy(pDataBuff + dwOffset, &wResetClimbTownNum, sizeof(wResetClimbTownNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwResetClimbTownTime);
	memcpy(pDataBuff + dwOffset, &qwResetClimbTownTime, sizeof(qwResetClimbTownTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wBuyResetClimbTownNum);
	memcpy(pDataBuff + dwOffset, &wBuyResetClimbTownNum, sizeof(wBuyResetClimbTownNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwBuyResetClimbTownTime);
	memcpy(pDataBuff + dwOffset, &qwBuyResetClimbTownTime, sizeof(qwBuyResetClimbTownTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byClimbTownInstance);
	memcpy(pDataBuff + dwOffset, &byClimbTownInstance, sizeof(byClimbTownInstance));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CLIMB_TOWER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wResetClimbTownNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wResetClimbTownNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wResetClimbTownNum, 0, sizeof(wResetClimbTownNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwResetClimbTownTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwResetClimbTownTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwResetClimbTownTime, 0, sizeof(qwResetClimbTownTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wBuyResetClimbTownNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wBuyResetClimbTownNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBuyResetClimbTownNum, 0, sizeof(wBuyResetClimbTownNum));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwBuyResetClimbTownTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBuyResetClimbTownTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBuyResetClimbTownTime, 0, sizeof(qwBuyResetClimbTownTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byClimbTownInstance) >= pstIndex->dwContextLen)
				{
					memcpy(&byClimbTownInstance, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byClimbTownInstance, 0, sizeof(byClimbTownInstance));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ELITE_INSTANCE_RESET_DATA(void *pHost, CNetData* poNetData)
{
	DT_ELITE_INSTANCE_RESET_DATA *pstIn = (DT_ELITE_INSTANCE_RESET_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wResetEliteInstanceNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastResetEliteInstanceTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ELITE_INSTANCE_RESET_DATA(void *pHost, CNetData* poNetData)
{
	DT_ELITE_INSTANCE_RESET_DATA *pstOut = (DT_ELITE_INSTANCE_RESET_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wResetEliteInstanceNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastResetEliteInstanceTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ELITE_INSTANCE_RESET_DATA(DT_ELITE_INSTANCE_RESET_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ResetEliteInstanceNum", (double)(data.wResetEliteInstanceNum));
	cJSON_AddNumberToObject(root,"LastResetEliteInstanceTime", (double)(data.qwLastResetEliteInstanceTime));

	return root;
}

INT32 DT_ELITE_INSTANCE_RESET_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wResetEliteInstanceNum);
	memcpy(pDataBuff + dwOffset, &wResetEliteInstanceNum, sizeof(wResetEliteInstanceNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastResetEliteInstanceTime);
	memcpy(pDataBuff + dwOffset, &qwLastResetEliteInstanceTime, sizeof(qwLastResetEliteInstanceTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ELITE_INSTANCE_RESET_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wResetEliteInstanceNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wResetEliteInstanceNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wResetEliteInstanceNum, 0, sizeof(wResetEliteInstanceNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLastResetEliteInstanceTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastResetEliteInstanceTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastResetEliteInstanceTime, 0, sizeof(qwLastResetEliteInstanceTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_VIP_GET_NUM_EACH_DATA(void *pHost, CNetData* poNetData)
{
	DT_VIP_GET_NUM_EACH_DATA *pstIn = (DT_VIP_GET_NUM_EACH_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wVipHaveNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wVipGetNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_VIP_GET_NUM_EACH_DATA(void *pHost, CNetData* poNetData)
{
	DT_VIP_GET_NUM_EACH_DATA *pstOut = (DT_VIP_GET_NUM_EACH_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wVipHaveNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wVipGetNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_VIP_GET_NUM_EACH_DATA(DT_VIP_GET_NUM_EACH_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"VipHaveNum", (double)(data.wVipHaveNum));
	cJSON_AddNumberToObject(root,"VipGetNum", (double)(data.wVipGetNum));

	return root;
}

INT32 DT_VIP_GET_NUM_EACH_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wVipHaveNum);
	memcpy(pDataBuff + dwOffset, &wVipHaveNum, sizeof(wVipHaveNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wVipGetNum);
	memcpy(pDataBuff + dwOffset, &wVipGetNum, sizeof(wVipGetNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_VIP_GET_NUM_EACH_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wVipHaveNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wVipHaveNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wVipHaveNum, 0, sizeof(wVipHaveNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wVipGetNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wVipGetNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wVipGetNum, 0, sizeof(wVipGetNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_VIP_GET_NUM_LEVEL_DATA(void *pHost, CNetData* poNetData)
{
	DT_VIP_GET_NUM_LEVEL_DATA *pstIn = (DT_VIP_GET_NUM_LEVEL_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wMaxVipGift))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_VIP_GIFT; i++)
	{
		if(i >= (INT32)pstIn->wMaxVipGift)
			break;
		if(-1 == EncodeDT_VIP_GET_NUM_EACH_DATA(&pstIn->astVipGetNum[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_VIP_GET_NUM_LEVEL_DATA(void *pHost, CNetData* poNetData)
{
	DT_VIP_GET_NUM_LEVEL_DATA *pstOut = (DT_VIP_GET_NUM_LEVEL_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wMaxVipGift))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_VIP_GIFT; i++)
	{
		if(i >= (INT32)pstOut->wMaxVipGift)
			break;
		if(-1 == DecodeDT_VIP_GET_NUM_EACH_DATA(&pstOut->astVipGetNum[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_VIP_GET_NUM_LEVEL_DATA(DT_VIP_GET_NUM_LEVEL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MaxVipGift", (double)(data.wMaxVipGift));
	cJSON *VipGetNum = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "VipGetNum", VipGetNum);
	for( UINT32 dwIndex=0; dwIndex<data.wMaxVipGift; ++dwIndex)
	{
		cJSON_AddItemToObject(VipGetNum, " ", GetJsonDT_VIP_GET_NUM_EACH_DATA(data.astVipGetNum[dwIndex]));
	}

	return root;
}

INT32 DT_VIP_GET_NUM_LEVEL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wMaxVipGift);
	memcpy(pDataBuff + dwOffset, &wMaxVipGift, sizeof(wMaxVipGift));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wMaxVipGift > MAX_VIP_GIFT)
	{
		wMaxVipGift = MAX_VIP_GIFT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wMaxVipGift;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wMaxVipGift; i++)
	{
		dwContextLenTmp += astVipGetNum[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_VIP_GET_NUM_LEVEL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wMaxVipGift) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaxVipGift, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaxVipGift, 0, sizeof(wMaxVipGift));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wMaxVipGift)
				{
					wArrNum = wArrNum <= MAX_VIP_GIFT ? wArrNum : MAX_VIP_GIFT;
					wMaxVipGift = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astVipGetNum[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astVipGetNum, 0, sizeof(astVipGetNum));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astVipGetNum, 0, sizeof(astVipGetNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_VIP_EXT_DATA(void *pHost, CNetData* poNetData)
{
	DT_VIP_EXT_DATA *pstIn = (DT_VIP_EXT_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEatGoldExperienceCnt))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastEatTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wEliteInstanceTownNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ELITE_INSTANCE_TOWN_NUM; i++)
	{
		if(i >= (INT32)pstIn->wEliteInstanceTownNum)
			break;
		if(-1 == EncodeDT_ELITE_INSTANCE_RESET_DATA(&pstIn->astEliteInstanceData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddUint64(pstIn->qwLastGetTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byVipMaxLevel))
		return -1;

	for(i = 0; i < MAX_VIP_LEVEL; i++)
	{
		if(i >= (INT32)pstIn->byVipMaxLevel)
			break;
		if(-1 == EncodeDT_VIP_GET_NUM_LEVEL_DATA(&pstIn->astVipGiftNumByLevel[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_VIP_EXT_DATA(void *pHost, CNetData* poNetData)
{
	DT_VIP_EXT_DATA *pstOut = (DT_VIP_EXT_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEatGoldExperienceCnt))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastEatTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wEliteInstanceTownNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ELITE_INSTANCE_TOWN_NUM; i++)
	{
		if(i >= (INT32)pstOut->wEliteInstanceTownNum)
			break;
		if(-1 == DecodeDT_ELITE_INSTANCE_RESET_DATA(&pstOut->astEliteInstanceData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelUint64(pstOut->qwLastGetTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byVipMaxLevel))
		return -1;

	for(i = 0; i < MAX_VIP_LEVEL; i++)
	{
		if(i >= (INT32)pstOut->byVipMaxLevel)
			break;
		if(-1 == DecodeDT_VIP_GET_NUM_LEVEL_DATA(&pstOut->astVipGiftNumByLevel[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_VIP_EXT_DATA(DT_VIP_EXT_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EatGoldExperienceCnt", (double)(data.wEatGoldExperienceCnt));
	cJSON_AddNumberToObject(root,"LastEatTime", (double)(data.qwLastEatTime));
	cJSON_AddNumberToObject(root,"EliteInstanceTownNum", (double)(data.wEliteInstanceTownNum));
	cJSON *EliteInstanceData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EliteInstanceData", EliteInstanceData);
	for( UINT32 dwIndex=0; dwIndex<data.wEliteInstanceTownNum; ++dwIndex)
	{
		cJSON_AddItemToObject(EliteInstanceData, " ", GetJsonDT_ELITE_INSTANCE_RESET_DATA(data.astEliteInstanceData[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"LastGetTime", (double)(data.qwLastGetTime));
	cJSON_AddNumberToObject(root,"VipMaxLevel", (double)(data.byVipMaxLevel));
	cJSON *VipGiftNumByLevel = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "VipGiftNumByLevel", VipGiftNumByLevel);
	for( UINT32 dwIndex=0; dwIndex<data.byVipMaxLevel; ++dwIndex)
	{
		cJSON_AddItemToObject(VipGiftNumByLevel, " ", GetJsonDT_VIP_GET_NUM_LEVEL_DATA(data.astVipGiftNumByLevel[dwIndex]));
	}

	return root;
}

INT32 DT_VIP_EXT_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEatGoldExperienceCnt);
	memcpy(pDataBuff + dwOffset, &wEatGoldExperienceCnt, sizeof(wEatGoldExperienceCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastEatTime);
	memcpy(pDataBuff + dwOffset, &qwLastEatTime, sizeof(qwLastEatTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wEliteInstanceTownNum);
	memcpy(pDataBuff + dwOffset, &wEliteInstanceTownNum, sizeof(wEliteInstanceTownNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(wEliteInstanceTownNum > MAX_ELITE_INSTANCE_TOWN_NUM)
	{
		wEliteInstanceTownNum = MAX_ELITE_INSTANCE_TOWN_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wEliteInstanceTownNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wEliteInstanceTownNum; i++)
	{
		dwContextLenTmp += astEliteInstanceData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwLastGetTime);
	memcpy(pDataBuff + dwOffset, &qwLastGetTime, sizeof(qwLastGetTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byVipMaxLevel);
	memcpy(pDataBuff + dwOffset, &byVipMaxLevel, sizeof(byVipMaxLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	dwContextLenTmp = 0;
	if(byVipMaxLevel > MAX_VIP_LEVEL)
	{
		byVipMaxLevel = MAX_VIP_LEVEL;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byVipMaxLevel;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byVipMaxLevel; i++)
	{
		dwContextLenTmp += astVipGiftNumByLevel[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_VIP_EXT_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEatGoldExperienceCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wEatGoldExperienceCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEatGoldExperienceCnt, 0, sizeof(wEatGoldExperienceCnt));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLastEatTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastEatTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastEatTime, 0, sizeof(qwLastEatTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wEliteInstanceTownNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wEliteInstanceTownNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEliteInstanceTownNum, 0, sizeof(wEliteInstanceTownNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wEliteInstanceTownNum)
				{
					wArrNum = wArrNum <= MAX_ELITE_INSTANCE_TOWN_NUM ? wArrNum : MAX_ELITE_INSTANCE_TOWN_NUM;
					wEliteInstanceTownNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astEliteInstanceData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astEliteInstanceData, 0, sizeof(astEliteInstanceData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astEliteInstanceData, 0, sizeof(astEliteInstanceData));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwLastGetTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastGetTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastGetTime, 0, sizeof(qwLastGetTime));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byVipMaxLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byVipMaxLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byVipMaxLevel, 0, sizeof(byVipMaxLevel));
				}
			}
			break;
		case 11:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byVipMaxLevel)
				{
					wArrNum = wArrNum <= MAX_VIP_LEVEL ? wArrNum : MAX_VIP_LEVEL;
					byVipMaxLevel = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astVipGiftNumByLevel[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astVipGiftNumByLevel, 0, sizeof(astVipGiftNumByLevel));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astVipGiftNumByLevel, 0, sizeof(astVipGiftNumByLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LUAACTIVITY_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_LUAACTIVITY_RECORD_DATA *pstIn = (DT_LUAACTIVITY_RECORD_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wFinishNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwFinishTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LUAACTIVITY_RECORD_DATA(void *pHost, CNetData* poNetData)
{
	DT_LUAACTIVITY_RECORD_DATA *pstOut = (DT_LUAACTIVITY_RECORD_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wFinishNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwFinishTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LUAACTIVITY_RECORD_DATA(DT_LUAACTIVITY_RECORD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ID", (double)(data.dwID));
	cJSON_AddNumberToObject(root,"FinishNum", (double)(data.wFinishNum));
	cJSON_AddNumberToObject(root,"FinishTime", (double)(data.qwFinishTime));

	return root;
}

INT32 DT_LUAACTIVITY_RECORD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwID);
	memcpy(pDataBuff + dwOffset, &dwID, sizeof(dwID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wFinishNum);
	memcpy(pDataBuff + dwOffset, &wFinishNum, sizeof(wFinishNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwFinishTime);
	memcpy(pDataBuff + dwOffset, &qwFinishTime, sizeof(qwFinishTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LUAACTIVITY_RECORD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwID, 0, sizeof(dwID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wFinishNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wFinishNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFinishNum, 0, sizeof(wFinishNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwFinishTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwFinishTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwFinishTime, 0, sizeof(qwFinishTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LUAACTIVITY_RECORD_LIST_DATA(void *pHost, CNetData* poNetData)
{
	DT_LUAACTIVITY_RECORD_LIST_DATA *pstIn = (DT_LUAACTIVITY_RECORD_LIST_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byRecordNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_LUAACTIVITY_RECORD_NUM; i++)
	{
		if(i >= (INT32)pstIn->byRecordNum)
			break;
		if(-1 == EncodeDT_LUAACTIVITY_RECORD_DATA(&pstIn->astHaveFinishActivityInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LUAACTIVITY_RECORD_LIST_DATA(void *pHost, CNetData* poNetData)
{
	DT_LUAACTIVITY_RECORD_LIST_DATA *pstOut = (DT_LUAACTIVITY_RECORD_LIST_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byRecordNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_LUAACTIVITY_RECORD_NUM; i++)
	{
		if(i >= (INT32)pstOut->byRecordNum)
			break;
		if(-1 == DecodeDT_LUAACTIVITY_RECORD_DATA(&pstOut->astHaveFinishActivityInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LUAACTIVITY_RECORD_LIST_DATA(DT_LUAACTIVITY_RECORD_LIST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RecordNum", (double)(data.byRecordNum));
	cJSON *HaveFinishActivityInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HaveFinishActivityInfo", HaveFinishActivityInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byRecordNum; ++dwIndex)
	{
		cJSON_AddItemToObject(HaveFinishActivityInfo, " ", GetJsonDT_LUAACTIVITY_RECORD_DATA(data.astHaveFinishActivityInfo[dwIndex]));
	}

	return root;
}

INT32 DT_LUAACTIVITY_RECORD_LIST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byRecordNum);
	memcpy(pDataBuff + dwOffset, &byRecordNum, sizeof(byRecordNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byRecordNum > MAX_LUAACTIVITY_RECORD_NUM)
	{
		byRecordNum = MAX_LUAACTIVITY_RECORD_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byRecordNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byRecordNum; i++)
	{
		dwContextLenTmp += astHaveFinishActivityInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LUAACTIVITY_RECORD_LIST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byRecordNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byRecordNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRecordNum, 0, sizeof(byRecordNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byRecordNum)
				{
					wArrNum = wArrNum <= MAX_LUAACTIVITY_RECORD_NUM ? wArrNum : MAX_LUAACTIVITY_RECORD_NUM;
					byRecordNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astHaveFinishActivityInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astHaveFinishActivityInfo, 0, sizeof(astHaveFinishActivityInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astHaveFinishActivityInfo, 0, sizeof(astHaveFinishActivityInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSSB_HURT_RATE(void *pHost, CNetData* poNetData)
{
	DT_BOSSB_HURT_RATE *pstIn = (DT_BOSSB_HURT_RATE*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszDispName, sizeof(pstIn->aszDispName)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHurtValue))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHurtRate))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHurtRank))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSSB_HURT_RATE(void *pHost, CNetData* poNetData)
{
	DT_BOSSB_HURT_RATE *pstOut = (DT_BOSSB_HURT_RATE*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszDispName, sizeof(pstOut->aszDispName)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHurtValue))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHurtRate))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHurtRank))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSSB_HURT_RATE(DT_BOSSB_HURT_RATE &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddStringToObject(root,"DispName", data.aszDispName );
	cJSON_AddNumberToObject(root,"HurtValue", (double)(data.dwHurtValue));
	cJSON_AddNumberToObject(root,"HurtRate", (double)(data.dwHurtRate));
	cJSON_AddNumberToObject(root,"HurtRank", (double)(data.dwHurtRank));

	return root;
}

INT32 DT_BOSSB_HURT_RATE::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(aszDispName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispName, sizeof(aszDispName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwHurtValue);
	memcpy(pDataBuff + dwOffset, &dwHurtValue, sizeof(dwHurtValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwHurtRate);
	memcpy(pDataBuff + dwOffset, &dwHurtRate, sizeof(dwHurtRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwHurtRank);
	memcpy(pDataBuff + dwOffset, &dwHurtRank, sizeof(dwHurtRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSSB_HURT_RATE::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispName, 0, sizeof(aszDispName));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwHurtValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHurtValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHurtValue, 0, sizeof(dwHurtValue));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwHurtRate) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHurtRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHurtRate, 0, sizeof(dwHurtRate));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwHurtRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHurtRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHurtRank, 0, sizeof(dwHurtRank));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSS_BATTLE_ENC_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_ENC_DATA *pstIn = (DT_BOSS_BATTLE_ENC_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszDispName, sizeof(pstIn->aszDispName)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCoin))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwJingJie))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSS_BATTLE_ENC_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_ENC_DATA *pstOut = (DT_BOSS_BATTLE_ENC_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszDispName, sizeof(pstOut->aszDispName)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCoin))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwJingJie))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSS_BATTLE_ENC_DATA(DT_BOSS_BATTLE_ENC_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddStringToObject(root,"DispName", data.aszDispName );
	cJSON_AddNumberToObject(root,"Coin", (double)(data.dwCoin));
	cJSON_AddNumberToObject(root,"JingJie", (double)(data.dwJingJie));

	return root;
}

INT32 DT_BOSS_BATTLE_ENC_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(aszDispName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispName, sizeof(aszDispName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwCoin);
	memcpy(pDataBuff + dwOffset, &dwCoin, sizeof(dwCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwJingJie);
	memcpy(pDataBuff + dwOffset, &dwJingJie, sizeof(dwJingJie));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSS_BATTLE_ENC_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispName, 0, sizeof(aszDispName));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCoin, 0, sizeof(dwCoin));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwJingJie) >= pstIndex->dwContextLen)
				{
					memcpy(&dwJingJie, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwJingJie, 0, sizeof(dwJingJie));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSS_BATTLE_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_DATA *pstIn = (DT_BOSS_BATTLE_PLAYER_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastEnterActivityTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastLeaveActivityTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wIncPowerRate))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTotalHurtValue))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHurtRank))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEncCoin))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEncJingJie))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPosX))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPosY))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSyncStartIdx))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastReliveType))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastReliveTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastDeadTime))
		return -1;

	if(-1 == EncodeDT_BOSSB_HURT_RATE(&pstIn->stMyHurtInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BOSS_BATTLE_ENC_DATA(&pstIn->stHurtEncInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BOSS_BATTLE_ENC_DATA(&pstIn->stHeroEncInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUnreadBattleLogNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNotity))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastKillBossTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBossHurtTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSS_BATTLE_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_DATA *pstOut = (DT_BOSS_BATTLE_PLAYER_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastEnterActivityTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastLeaveActivityTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wIncPowerRate))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTotalHurtValue))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHurtRank))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEncCoin))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEncJingJie))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPosX))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPosY))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSyncStartIdx))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastReliveType))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastReliveTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastDeadTime))
		return -1;

	if(-1 == DecodeDT_BOSSB_HURT_RATE(&pstOut->stMyHurtInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BOSS_BATTLE_ENC_DATA(&pstOut->stHurtEncInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BOSS_BATTLE_ENC_DATA(&pstOut->stHeroEncInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUnreadBattleLogNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNotity))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastKillBossTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBossHurtTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSS_BATTLE_PLAYER_DATA(DT_BOSS_BATTLE_PLAYER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastEnterActivityTime", (double)(data.qwLastEnterActivityTime));
	cJSON_AddNumberToObject(root,"LastLeaveActivityTime", (double)(data.qwLastLeaveActivityTime));
	cJSON_AddNumberToObject(root,"IncPowerRate", (double)(data.wIncPowerRate));
	cJSON_AddNumberToObject(root,"TotalHurtValue", (double)(data.dwTotalHurtValue));
	cJSON_AddNumberToObject(root,"HurtRank", (double)(data.dwHurtRank));
	cJSON_AddNumberToObject(root,"EncCoin", (double)(data.dwEncCoin));
	cJSON_AddNumberToObject(root,"EncJingJie", (double)(data.dwEncJingJie));
	cJSON_AddNumberToObject(root,"PosX", (double)(data.wPosX));
	cJSON_AddNumberToObject(root,"PosY", (double)(data.wPosY));
	cJSON_AddNumberToObject(root,"SyncStartIdx", (double)(data.dwSyncStartIdx));
	cJSON_AddNumberToObject(root,"LastReliveType", (double)(data.byLastReliveType));
	cJSON_AddNumberToObject(root,"LastReliveTime", (double)(data.qwLastReliveTime));
	cJSON_AddNumberToObject(root,"LastDeadTime", (double)(data.qwLastDeadTime));
	cJSON_AddItemToObject(root, "MyHurtInfo", GetJsonDT_BOSSB_HURT_RATE(data.stMyHurtInfo));
	cJSON_AddItemToObject(root, "HurtEncInfo", GetJsonDT_BOSS_BATTLE_ENC_DATA(data.stHurtEncInfo));
	cJSON_AddItemToObject(root, "HeroEncInfo", GetJsonDT_BOSS_BATTLE_ENC_DATA(data.stHeroEncInfo));
	cJSON_AddNumberToObject(root,"UnreadBattleLogNum", (double)(data.byUnreadBattleLogNum));
	cJSON_AddNumberToObject(root,"Notity", (double)(data.byNotity));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"LastKillBossTime", (double)(data.qwLastKillBossTime));
	cJSON_AddNumberToObject(root,"BossHurtTime", (double)(data.qwBossHurtTime));

	return root;
}

INT32 DT_BOSS_BATTLE_PLAYER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 21;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastEnterActivityTime);
	memcpy(pDataBuff + dwOffset, &qwLastEnterActivityTime, sizeof(qwLastEnterActivityTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastLeaveActivityTime);
	memcpy(pDataBuff + dwOffset, &qwLastLeaveActivityTime, sizeof(qwLastLeaveActivityTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wIncPowerRate);
	memcpy(pDataBuff + dwOffset, &wIncPowerRate, sizeof(wIncPowerRate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwTotalHurtValue);
	memcpy(pDataBuff + dwOffset, &dwTotalHurtValue, sizeof(dwTotalHurtValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwHurtRank);
	memcpy(pDataBuff + dwOffset, &dwHurtRank, sizeof(dwHurtRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwEncCoin);
	memcpy(pDataBuff + dwOffset, &dwEncCoin, sizeof(dwEncCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwEncJingJie);
	memcpy(pDataBuff + dwOffset, &dwEncJingJie, sizeof(dwEncJingJie));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wPosX);
	memcpy(pDataBuff + dwOffset, &wPosX, sizeof(wPosX));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wPosY);
	memcpy(pDataBuff + dwOffset, &wPosY, sizeof(wPosY));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(dwSyncStartIdx);
	memcpy(pDataBuff + dwOffset, &dwSyncStartIdx, sizeof(dwSyncStartIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byLastReliveType);
	memcpy(pDataBuff + dwOffset, &byLastReliveType, sizeof(byLastReliveType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(qwLastReliveTime);
	memcpy(pDataBuff + dwOffset, &qwLastReliveTime, sizeof(qwLastReliveTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(qwLastDeadTime);
	memcpy(pDataBuff + dwOffset, &qwLastDeadTime, sizeof(qwLastDeadTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = stMyHurtInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = stHurtEncInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = stHeroEncInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(byUnreadBattleLogNum);
	memcpy(pDataBuff + dwOffset, &byUnreadBattleLogNum, sizeof(byUnreadBattleLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(byNotity);
	memcpy(pDataBuff + dwOffset, &byNotity, sizeof(byNotity));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 19;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 20;
	pstIndex->dwContextLen = sizeof(qwLastKillBossTime);
	memcpy(pDataBuff + dwOffset, &qwLastKillBossTime, sizeof(qwLastKillBossTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 21;
	pstIndex->dwContextLen = sizeof(qwBossHurtTime);
	memcpy(pDataBuff + dwOffset, &qwBossHurtTime, sizeof(qwBossHurtTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSS_BATTLE_PLAYER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastEnterActivityTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastEnterActivityTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastEnterActivityTime, 0, sizeof(qwLastEnterActivityTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLastLeaveActivityTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastLeaveActivityTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastLeaveActivityTime, 0, sizeof(qwLastLeaveActivityTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wIncPowerRate) >= pstIndex->dwContextLen)
				{
					memcpy(&wIncPowerRate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wIncPowerRate, 0, sizeof(wIncPowerRate));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwTotalHurtValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTotalHurtValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTotalHurtValue, 0, sizeof(dwTotalHurtValue));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwHurtRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHurtRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHurtRank, 0, sizeof(dwHurtRank));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwEncCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEncCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEncCoin, 0, sizeof(dwEncCoin));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwEncJingJie) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEncJingJie, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEncJingJie, 0, sizeof(dwEncJingJie));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wPosX) >= pstIndex->dwContextLen)
				{
					memcpy(&wPosX, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPosX, 0, sizeof(wPosX));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wPosY) >= pstIndex->dwContextLen)
				{
					memcpy(&wPosY, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPosY, 0, sizeof(wPosY));
				}
			}
			break;
		case 10:
			{
				if(sizeof(dwSyncStartIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSyncStartIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSyncStartIdx, 0, sizeof(dwSyncStartIdx));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byLastReliveType) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastReliveType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastReliveType, 0, sizeof(byLastReliveType));
				}
			}
			break;
		case 12:
			{
				if(sizeof(qwLastReliveTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastReliveTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastReliveTime, 0, sizeof(qwLastReliveTime));
				}
			}
			break;
		case 13:
			{
				if(sizeof(qwLastDeadTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastDeadTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastDeadTime, 0, sizeof(qwLastDeadTime));
				}
			}
			break;
		case 14:
			{
				stMyHurtInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 15:
			{
				stHurtEncInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 16:
			{
				stHeroEncInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 17:
			{
				if(sizeof(byUnreadBattleLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byUnreadBattleLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUnreadBattleLogNum, 0, sizeof(byUnreadBattleLogNum));
				}
			}
			break;
		case 18:
			{
				if(sizeof(byNotity) >= pstIndex->dwContextLen)
				{
					memcpy(&byNotity, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNotity, 0, sizeof(byNotity));
				}
			}
			break;
		case 19:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 20:
			{
				if(sizeof(qwLastKillBossTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastKillBossTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastKillBossTime, 0, sizeof(qwLastKillBossTime));
				}
			}
			break;
		case 21:
			{
				if(sizeof(qwBossHurtTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBossHurtTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBossHurtTime, 0, sizeof(qwBossHurtTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSS_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_DATA *pstIn = (DT_BOSS_BATTLE_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwOverTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStartTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSaveTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivityID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wBossID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNeedUpgrade))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTotalHP))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCurHP))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BOSS_ENC_TOP_NUM; i++)
	{
		if(-1 == EncodeDT_BOSSB_HURT_RATE(&pstIn->astTopHurtInfo[i], poNetData))
			return -1;
	}

	for(i = 0; i < MAX_BOSS_ENC_TOP_NUM; i++)
	{
		if(-1 == EncodeDT_BOSS_BATTLE_ENC_DATA(&pstIn->astBossBTopEncInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_BOSS_BATTLE_ENC_DATA(&pstIn->stBossBKillEncInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwTotalHP))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwCurHP))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSS_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_DATA *pstOut = (DT_BOSS_BATTLE_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwOverTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStartTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSaveTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivityID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wBossID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNeedUpgrade))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTotalHP))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCurHP))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_BOSS_ENC_TOP_NUM; i++)
		{
			if(-1 == DecodeDT_BOSSB_HURT_RATE(&pstOut->astTopHurtInfo[i], poNetData))
				return -1;
		}

		for(i = 0; i < MAX_BOSS_ENC_TOP_NUM; i++)
		{
			if(-1 == DecodeDT_BOSS_BATTLE_ENC_DATA(&pstOut->astBossBTopEncInfo[i], poNetData))
				return -1;
		}

	if(-1 == DecodeDT_BOSS_BATTLE_ENC_DATA(&pstOut->stBossBKillEncInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwTotalHP))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwCurHP))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSS_BATTLE_DATA(DT_BOSS_BATTLE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"OverTime", (double)(data.qwOverTime));
	cJSON_AddNumberToObject(root,"StartTime", (double)(data.qwStartTime));
	cJSON_AddNumberToObject(root,"SaveTime", (double)(data.qwSaveTime));
	cJSON_AddNumberToObject(root,"ActivityID", (double)(data.byActivityID));
	cJSON_AddNumberToObject(root,"BossID", (double)(data.wBossID));
	cJSON_AddNumberToObject(root,"LastLevel", (double)(data.wLastLevel));
	cJSON_AddNumberToObject(root,"NeedUpgrade", (double)(data.byNeedUpgrade));
	cJSON_AddNumberToObject(root,"TotalHP", (double)(data.dwTotalHP));
	cJSON_AddNumberToObject(root,"CurHP", (double)(data.dwCurHP));
	cJSON *TopHurtInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "TopHurtInfo", TopHurtInfo);
	for( UINT32 dwIndex=0; dwIndex<MAX_BOSS_ENC_TOP_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(TopHurtInfo, " ", GetJsonDT_BOSSB_HURT_RATE(data.astTopHurtInfo[dwIndex]));
	}
	cJSON *BossBTopEncInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BossBTopEncInfo", BossBTopEncInfo);
	for( UINT32 dwIndex=0; dwIndex<MAX_BOSS_ENC_TOP_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(BossBTopEncInfo, " ", GetJsonDT_BOSS_BATTLE_ENC_DATA(data.astBossBTopEncInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "BossBKillEncInfo", GetJsonDT_BOSS_BATTLE_ENC_DATA(data.stBossBKillEncInfo));
	cJSON_AddNumberToObject(root,"TotalHP", (double)(data.qwTotalHP));
	cJSON_AddNumberToObject(root,"CurHP", (double)(data.qwCurHP));

	return root;
}

INT32 DT_BOSS_BATTLE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 14;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwOverTime);
	memcpy(pDataBuff + dwOffset, &qwOverTime, sizeof(qwOverTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwStartTime);
	memcpy(pDataBuff + dwOffset, &qwStartTime, sizeof(qwStartTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwSaveTime);
	memcpy(pDataBuff + dwOffset, &qwSaveTime, sizeof(qwSaveTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byActivityID);
	memcpy(pDataBuff + dwOffset, &byActivityID, sizeof(byActivityID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wBossID);
	memcpy(pDataBuff + dwOffset, &wBossID, sizeof(wBossID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wLastLevel);
	memcpy(pDataBuff + dwOffset, &wLastLevel, sizeof(wLastLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byNeedUpgrade);
	memcpy(pDataBuff + dwOffset, &byNeedUpgrade, sizeof(byNeedUpgrade));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwTotalHP);
	memcpy(pDataBuff + dwOffset, &dwTotalHP, sizeof(dwTotalHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwCurHP);
	memcpy(pDataBuff + dwOffset, &dwCurHP, sizeof(dwCurHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_BOSS_ENC_TOP_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_BOSS_ENC_TOP_NUM; i++)
	{
		dwContextLenTmp += astTopHurtInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_BOSS_ENC_TOP_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_BOSS_ENC_TOP_NUM; i++)
	{
		dwContextLenTmp += astBossBTopEncInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = stBossBKillEncInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(qwTotalHP);
	memcpy(pDataBuff + dwOffset, &qwTotalHP, sizeof(qwTotalHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(qwCurHP);
	memcpy(pDataBuff + dwOffset, &qwCurHP, sizeof(qwCurHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSS_BATTLE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwOverTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwOverTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwOverTime, 0, sizeof(qwOverTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwStartTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStartTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStartTime, 0, sizeof(qwStartTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwSaveTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSaveTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSaveTime, 0, sizeof(qwSaveTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byActivityID) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivityID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivityID, 0, sizeof(byActivityID));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wBossID) >= pstIndex->dwContextLen)
				{
					memcpy(&wBossID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wBossID, 0, sizeof(wBossID));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wLastLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastLevel, 0, sizeof(wLastLevel));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byNeedUpgrade) >= pstIndex->dwContextLen)
				{
					memcpy(&byNeedUpgrade, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNeedUpgrade, 0, sizeof(byNeedUpgrade));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwTotalHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTotalHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTotalHP, 0, sizeof(dwTotalHP));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwCurHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCurHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCurHP, 0, sizeof(dwCurHP));
				}
			}
			break;
		case 10:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_BOSS_ENC_TOP_NUM ? wArrNum : MAX_BOSS_ENC_TOP_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astTopHurtInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astTopHurtInfo, 0, sizeof(astTopHurtInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 11:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_BOSS_ENC_TOP_NUM ? wArrNum : MAX_BOSS_ENC_TOP_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astBossBTopEncInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astBossBTopEncInfo, 0, sizeof(astBossBTopEncInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 12:
			{
				stBossBKillEncInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 13:
			{
				if(sizeof(qwTotalHP) >= pstIndex->dwContextLen)
				{
					memcpy(&qwTotalHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwTotalHP, 0, sizeof(qwTotalHP));
				}
			}
			break;
		case 14:
			{
				if(sizeof(qwCurHP) >= pstIndex->dwContextLen)
				{
					memcpy(&qwCurHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwCurHP, 0, sizeof(qwCurHP));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA *pstIn = (DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwOverTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivityID))
		return -1;

	if(-1 == EncodeDT_BOSSB_HURT_RATE(&pstIn->stMyHurtInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BOSS_BATTLE_ENC_DATA(&pstIn->stHurtEncInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_BOSS_BATTLE_ENC_DATA(&pstIn->stHeroEncInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA *pstOut = (DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwOverTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivityID))
		return -1;

	if(-1 == DecodeDT_BOSSB_HURT_RATE(&pstOut->stMyHurtInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BOSS_BATTLE_ENC_DATA(&pstOut->stHurtEncInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_BOSS_BATTLE_ENC_DATA(&pstOut->stHeroEncInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA(DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"OverTime", (double)(data.qwOverTime));
	cJSON_AddNumberToObject(root,"ActivityID", (double)(data.byActivityID));
	cJSON_AddItemToObject(root, "MyHurtInfo", GetJsonDT_BOSSB_HURT_RATE(data.stMyHurtInfo));
	cJSON_AddItemToObject(root, "HurtEncInfo", GetJsonDT_BOSS_BATTLE_ENC_DATA(data.stHurtEncInfo));
	cJSON_AddItemToObject(root, "HeroEncInfo", GetJsonDT_BOSS_BATTLE_ENC_DATA(data.stHeroEncInfo));

	return root;
}

INT32 DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwOverTime);
	memcpy(pDataBuff + dwOffset, &qwOverTime, sizeof(qwOverTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byActivityID);
	memcpy(pDataBuff + dwOffset, &byActivityID, sizeof(byActivityID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stMyHurtInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stHurtEncInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stHeroEncInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwOverTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwOverTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwOverTime, 0, sizeof(qwOverTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byActivityID) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivityID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivityID, 0, sizeof(byActivityID));
				}
			}
			break;
		case 3:
			{
				stMyHurtInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stHurtEncInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stHeroEncInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST *pstIn = (DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BOSSB_BATTLE_LOG_NUM; i++)
	{
		if(i >= (INT32)pstIn->byNum)
			break;
		if(-1 == EncodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA(&pstIn->astBossBattleBL[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST *pstOut = (DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BOSSB_BATTLE_LOG_NUM; i++)
	{
		if(i >= (INT32)pstOut->byNum)
			break;
		if(-1 == DecodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA(&pstOut->astBossBattleBL[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST(DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.byNum));
	cJSON *BossBattleBL = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BossBattleBL", BossBattleBL);
	for( UINT32 dwIndex=0; dwIndex<data.byNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BossBattleBL, " ", GetJsonDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA(data.astBossBattleBL[dwIndex]));
	}

	return root;
}

INT32 DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byNum);
	memcpy(pDataBuff + dwOffset, &byNum, sizeof(byNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byNum > MAX_BOSSB_BATTLE_LOG_NUM)
	{
		byNum = MAX_BOSSB_BATTLE_LOG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byNum; i++)
	{
		dwContextLenTmp += astBossBattleBL[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNum, 0, sizeof(byNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byNum)
				{
					wArrNum = wArrNum <= MAX_BOSSB_BATTLE_LOG_NUM ? wArrNum : MAX_BOSSB_BATTLE_LOG_NUM;
					byNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBossBattleBL[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBossBattleBL, 0, sizeof(astBossBattleBL));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBossBattleBL, 0, sizeof(astBossBattleBL));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSS_BATTLE_MODULE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_MODULE_DATA *pstIn = (DT_BOSS_BATTLE_MODULE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BOSSB_NUM_PER_DAY; i++)
	{
		if(i >= (INT32)pstIn->byNum)
			break;
		if(-1 == EncodeDT_BOSS_BATTLE_DATA(&pstIn->astBossBattleInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSS_BATTLE_MODULE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_MODULE_DATA *pstOut = (DT_BOSS_BATTLE_MODULE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BOSSB_NUM_PER_DAY; i++)
	{
		if(i >= (INT32)pstOut->byNum)
			break;
		if(-1 == DecodeDT_BOSS_BATTLE_DATA(&pstOut->astBossBattleInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSS_BATTLE_MODULE_DATA(DT_BOSS_BATTLE_MODULE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.byNum));
	cJSON *BossBattleInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BossBattleInfo", BossBattleInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BossBattleInfo, " ", GetJsonDT_BOSS_BATTLE_DATA(data.astBossBattleInfo[dwIndex]));
	}

	return root;
}

INT32 DT_BOSS_BATTLE_MODULE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byNum);
	memcpy(pDataBuff + dwOffset, &byNum, sizeof(byNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byNum > MAX_BOSSB_NUM_PER_DAY)
	{
		byNum = MAX_BOSSB_NUM_PER_DAY;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byNum; i++)
	{
		dwContextLenTmp += astBossBattleInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSS_BATTLE_MODULE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNum, 0, sizeof(byNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byNum)
				{
					wArrNum = wArrNum <= MAX_BOSSB_NUM_PER_DAY ? wArrNum : MAX_BOSSB_NUM_PER_DAY;
					byNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBossBattleInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBossBattleInfo, 0, sizeof(astBossBattleInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBossBattleInfo, 0, sizeof(astBossBattleInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ACTIVITY_ENCOURAGE_INFO(void *pHost, CNetData* poNetData)
{
	DT_ACTIVITY_ENCOURAGE_INFO *pstIn = (DT_ACTIVITY_ENCOURAGE_INFO*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwActivityID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwActivityTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivityTimes))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ACTIVITY_ENCOURAGE_INFO(void *pHost, CNetData* poNetData)
{
	DT_ACTIVITY_ENCOURAGE_INFO *pstOut = (DT_ACTIVITY_ENCOURAGE_INFO*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwActivityID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwActivityTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivityTimes))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ACTIVITY_ENCOURAGE_INFO(DT_ACTIVITY_ENCOURAGE_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ActivityID", (double)(data.dwActivityID));
	cJSON_AddNumberToObject(root,"ActivityTime", (double)(data.qwActivityTime));
	cJSON_AddNumberToObject(root,"ActivityTimes", (double)(data.byActivityTimes));

	return root;
}

INT32 DT_ACTIVITY_ENCOURAGE_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwActivityID);
	memcpy(pDataBuff + dwOffset, &dwActivityID, sizeof(dwActivityID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwActivityTime);
	memcpy(pDataBuff + dwOffset, &qwActivityTime, sizeof(qwActivityTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byActivityTimes);
	memcpy(pDataBuff + dwOffset, &byActivityTimes, sizeof(byActivityTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ACTIVITY_ENCOURAGE_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwActivityID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwActivityID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwActivityID, 0, sizeof(dwActivityID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwActivityTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwActivityTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwActivityTime, 0, sizeof(qwActivityTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byActivityTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivityTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivityTimes, 0, sizeof(byActivityTimes));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ACTIVITY_ENCOURAGE_INFO2(void *pHost, CNetData* poNetData)
{
	DT_ACTIVITY_ENCOURAGE_INFO2 *pstIn = (DT_ACTIVITY_ENCOURAGE_INFO2*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwActivityID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwActivityTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivityTimes))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ACTIVITY_ENCOURAGE_INFO2(void *pHost, CNetData* poNetData)
{
	DT_ACTIVITY_ENCOURAGE_INFO2 *pstOut = (DT_ACTIVITY_ENCOURAGE_INFO2*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwActivityID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwActivityTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivityTimes))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ACTIVITY_ENCOURAGE_INFO2(DT_ACTIVITY_ENCOURAGE_INFO2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ActivityID", (double)(data.qwActivityID));
	cJSON_AddNumberToObject(root,"ActivityTime", (double)(data.qwActivityTime));
	cJSON_AddNumberToObject(root,"ActivityTimes", (double)(data.byActivityTimes));

	return root;
}

INT32 DT_ACTIVITY_ENCOURAGE_INFO2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwActivityID);
	memcpy(pDataBuff + dwOffset, &qwActivityID, sizeof(qwActivityID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwActivityTime);
	memcpy(pDataBuff + dwOffset, &qwActivityTime, sizeof(qwActivityTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byActivityTimes);
	memcpy(pDataBuff + dwOffset, &byActivityTimes, sizeof(byActivityTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ACTIVITY_ENCOURAGE_INFO2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwActivityID) >= pstIndex->dwContextLen)
				{
					memcpy(&qwActivityID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwActivityID, 0, sizeof(qwActivityID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwActivityTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwActivityTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwActivityTime, 0, sizeof(qwActivityTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byActivityTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivityTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivityTimes, 0, sizeof(byActivityTimes));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ACTIVITY_ENCOURAGE_DATA(void *pHost, CNetData* poNetData)
{
	DT_ACTIVITY_ENCOURAGE_DATA *pstIn = (DT_ACTIVITY_ENCOURAGE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byRechargeFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwRechargeRecvTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScoreFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwScoreRecvTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wInfoNumOld))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ACTIVITY_ENCOURAGE_INFO_NUM; i++)
	{
		if(i >= (INT32)pstIn->wInfoNumOld)
			break;
		if(-1 == EncodeDT_ACTIVITY_ENCOURAGE_INFO(&pstIn->astActivityInfoOld[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddWord(pstIn->wInfoNum))
		return -1;

	for(i = 0; i < MAX_ACTIVITY_ENCOURAGE_INFO_NUM; i++)
	{
		if(i >= (INT32)pstIn->wInfoNum)
			break;
		if(-1 == EncodeDT_ACTIVITY_ENCOURAGE_INFO2(&pstIn->astActivityInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ACTIVITY_ENCOURAGE_DATA(void *pHost, CNetData* poNetData)
{
	DT_ACTIVITY_ENCOURAGE_DATA *pstOut = (DT_ACTIVITY_ENCOURAGE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byRechargeFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwRechargeRecvTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScoreFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwScoreRecvTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wInfoNumOld))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_ACTIVITY_ENCOURAGE_INFO_NUM; i++)
	{
		if(i >= (INT32)pstOut->wInfoNumOld)
			break;
		if(-1 == DecodeDT_ACTIVITY_ENCOURAGE_INFO(&pstOut->astActivityInfoOld[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelWord(pstOut->wInfoNum))
		return -1;

	for(i = 0; i < MAX_ACTIVITY_ENCOURAGE_INFO_NUM; i++)
	{
		if(i >= (INT32)pstOut->wInfoNum)
			break;
		if(-1 == DecodeDT_ACTIVITY_ENCOURAGE_INFO2(&pstOut->astActivityInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ACTIVITY_ENCOURAGE_DATA(DT_ACTIVITY_ENCOURAGE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RechargeFlag", (double)(data.byRechargeFlag));
	cJSON_AddNumberToObject(root,"RechargeRecvTime", (double)(data.qwRechargeRecvTime));
	cJSON_AddNumberToObject(root,"ScoreFlag", (double)(data.byScoreFlag));
	cJSON_AddNumberToObject(root,"ScoreRecvTime", (double)(data.qwScoreRecvTime));
	cJSON_AddNumberToObject(root,"InfoNumOld", (double)(data.wInfoNumOld));
	cJSON *ActivityInfoOld = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ActivityInfoOld", ActivityInfoOld);
	for( UINT32 dwIndex=0; dwIndex<data.wInfoNumOld; ++dwIndex)
	{
		cJSON_AddItemToObject(ActivityInfoOld, " ", GetJsonDT_ACTIVITY_ENCOURAGE_INFO(data.astActivityInfoOld[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"InfoNum", (double)(data.wInfoNum));
	cJSON *ActivityInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ActivityInfo", ActivityInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wInfoNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ActivityInfo, " ", GetJsonDT_ACTIVITY_ENCOURAGE_INFO2(data.astActivityInfo[dwIndex]));
	}

	return root;
}

INT32 DT_ACTIVITY_ENCOURAGE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byRechargeFlag);
	memcpy(pDataBuff + dwOffset, &byRechargeFlag, sizeof(byRechargeFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwRechargeRecvTime);
	memcpy(pDataBuff + dwOffset, &qwRechargeRecvTime, sizeof(qwRechargeRecvTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byScoreFlag);
	memcpy(pDataBuff + dwOffset, &byScoreFlag, sizeof(byScoreFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwScoreRecvTime);
	memcpy(pDataBuff + dwOffset, &qwScoreRecvTime, sizeof(qwScoreRecvTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wInfoNumOld);
	memcpy(pDataBuff + dwOffset, &wInfoNumOld, sizeof(wInfoNumOld));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(wInfoNumOld > MAX_ACTIVITY_ENCOURAGE_INFO_NUM)
	{
		wInfoNumOld = MAX_ACTIVITY_ENCOURAGE_INFO_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wInfoNumOld;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wInfoNumOld; i++)
	{
		dwContextLenTmp += astActivityInfoOld[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wInfoNum);
	memcpy(pDataBuff + dwOffset, &wInfoNum, sizeof(wInfoNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	dwContextLenTmp = 0;
	if(wInfoNum > MAX_ACTIVITY_ENCOURAGE_INFO_NUM)
	{
		wInfoNum = MAX_ACTIVITY_ENCOURAGE_INFO_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wInfoNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wInfoNum; i++)
	{
		dwContextLenTmp += astActivityInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ACTIVITY_ENCOURAGE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byRechargeFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byRechargeFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRechargeFlag, 0, sizeof(byRechargeFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwRechargeRecvTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwRechargeRecvTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwRechargeRecvTime, 0, sizeof(qwRechargeRecvTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byScoreFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byScoreFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScoreFlag, 0, sizeof(byScoreFlag));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwScoreRecvTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwScoreRecvTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwScoreRecvTime, 0, sizeof(qwScoreRecvTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wInfoNumOld) >= pstIndex->dwContextLen)
				{
					memcpy(&wInfoNumOld, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wInfoNumOld, 0, sizeof(wInfoNumOld));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wInfoNumOld)
				{
					wArrNum = wArrNum <= MAX_ACTIVITY_ENCOURAGE_INFO_NUM ? wArrNum : MAX_ACTIVITY_ENCOURAGE_INFO_NUM;
					wInfoNumOld = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astActivityInfoOld[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astActivityInfoOld, 0, sizeof(astActivityInfoOld));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astActivityInfoOld, 0, sizeof(astActivityInfoOld));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wInfoNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wInfoNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wInfoNum, 0, sizeof(wInfoNum));
				}
			}
			break;
		case 8:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wInfoNum)
				{
					wArrNum = wArrNum <= MAX_ACTIVITY_ENCOURAGE_INFO_NUM ? wArrNum : MAX_ACTIVITY_ENCOURAGE_INFO_NUM;
					wInfoNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astActivityInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astActivityInfo, 0, sizeof(astActivityInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astActivityInfo, 0, sizeof(astActivityInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RDC_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_RDC_PLAYER_DATA *pstIn = (DT_RDC_PLAYER_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszDispName, sizeof(pstIn->aszDispName)))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMainHeroKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byRobotFunc))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPower))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveChallengeFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RDC_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_RDC_PLAYER_DATA *pstOut = (DT_RDC_PLAYER_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszDispName, sizeof(pstOut->aszDispName)))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMainHeroKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byRobotFunc))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPower))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveChallengeFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RDC_PLAYER_DATA(DT_RDC_PLAYER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddStringToObject(root,"DispName", data.aszDispName );
	cJSON_AddNumberToObject(root,"MainHeroKindID", (double)(data.wMainHeroKindID));
	cJSON_AddNumberToObject(root,"RobotFunc", (double)(data.byRobotFunc));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"Power", (double)(data.dwPower));
	cJSON_AddNumberToObject(root,"HaveChallengeFlag", (double)(data.byHaveChallengeFlag));

	return root;
}

INT32 DT_RDC_PLAYER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(aszDispName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispName, sizeof(aszDispName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wMainHeroKindID);
	memcpy(pDataBuff + dwOffset, &wMainHeroKindID, sizeof(wMainHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byRobotFunc);
	memcpy(pDataBuff + dwOffset, &byRobotFunc, sizeof(byRobotFunc));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwPower);
	memcpy(pDataBuff + dwOffset, &dwPower, sizeof(dwPower));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byHaveChallengeFlag);
	memcpy(pDataBuff + dwOffset, &byHaveChallengeFlag, sizeof(byHaveChallengeFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RDC_PLAYER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispName, 0, sizeof(aszDispName));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wMainHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wMainHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMainHeroKindID, 0, sizeof(wMainHeroKindID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byRobotFunc) >= pstIndex->dwContextLen)
				{
					memcpy(&byRobotFunc, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRobotFunc, 0, sizeof(byRobotFunc));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwPower) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPower, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPower, 0, sizeof(dwPower));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byHaveChallengeFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveChallengeFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveChallengeFlag, 0, sizeof(byHaveChallengeFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RANDOM_CHALLENGE_DATA(void *pHost, CNetData* poNetData)
{
	DT_RANDOM_CHALLENGE_DATA *pstIn = (DT_RANDOM_CHALLENGE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wCurChallengePoint))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastRCPoinRefreshTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastBuyRCPoinTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastBuyRCPoinNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastRCTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLastRCRet))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byClrCDFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPlayerNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GET_RDC_NUM; i++)
	{
		if(i >= (INT32)pstIn->byPlayerNum)
			break;
		if(-1 == EncodeDT_RDC_PLAYER_DATA(&pstIn->astPlayerInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RANDOM_CHALLENGE_DATA(void *pHost, CNetData* poNetData)
{
	DT_RANDOM_CHALLENGE_DATA *pstOut = (DT_RANDOM_CHALLENGE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wCurChallengePoint))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastRCPoinRefreshTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastBuyRCPoinTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastBuyRCPoinNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastRCTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLastRCRet))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byClrCDFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPlayerNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GET_RDC_NUM; i++)
	{
		if(i >= (INT32)pstOut->byPlayerNum)
			break;
		if(-1 == DecodeDT_RDC_PLAYER_DATA(&pstOut->astPlayerInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RANDOM_CHALLENGE_DATA(DT_RANDOM_CHALLENGE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CurChallengePoint", (double)(data.wCurChallengePoint));
	cJSON_AddNumberToObject(root,"LastRCPoinRefreshTime", (double)(data.qwLastRCPoinRefreshTime));
	cJSON_AddNumberToObject(root,"LastBuyRCPoinTime", (double)(data.qwLastBuyRCPoinTime));
	cJSON_AddNumberToObject(root,"LastBuyRCPoinNum", (double)(data.wLastBuyRCPoinNum));
	cJSON_AddNumberToObject(root,"LastRCTime", (double)(data.qwLastRCTime));
	cJSON_AddNumberToObject(root,"LastRCRet", (double)(data.byLastRCRet));
	cJSON_AddNumberToObject(root,"ClrCDFlag", (double)(data.byClrCDFlag));
	cJSON_AddNumberToObject(root,"PlayerNum", (double)(data.byPlayerNum));
	cJSON *PlayerInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PlayerInfo", PlayerInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byPlayerNum; ++dwIndex)
	{
		cJSON_AddItemToObject(PlayerInfo, " ", GetJsonDT_RDC_PLAYER_DATA(data.astPlayerInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_RANDOM_CHALLENGE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wCurChallengePoint);
	memcpy(pDataBuff + dwOffset, &wCurChallengePoint, sizeof(wCurChallengePoint));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastRCPoinRefreshTime);
	memcpy(pDataBuff + dwOffset, &qwLastRCPoinRefreshTime, sizeof(qwLastRCPoinRefreshTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastBuyRCPoinTime);
	memcpy(pDataBuff + dwOffset, &qwLastBuyRCPoinTime, sizeof(qwLastBuyRCPoinTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wLastBuyRCPoinNum);
	memcpy(pDataBuff + dwOffset, &wLastBuyRCPoinNum, sizeof(wLastBuyRCPoinNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwLastRCTime);
	memcpy(pDataBuff + dwOffset, &qwLastRCTime, sizeof(qwLastRCTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byLastRCRet);
	memcpy(pDataBuff + dwOffset, &byLastRCRet, sizeof(byLastRCRet));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byClrCDFlag);
	memcpy(pDataBuff + dwOffset, &byClrCDFlag, sizeof(byClrCDFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byPlayerNum);
	memcpy(pDataBuff + dwOffset, &byPlayerNum, sizeof(byPlayerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	dwContextLenTmp = 0;
	if(byPlayerNum > MAX_GET_RDC_NUM)
	{
		byPlayerNum = MAX_GET_RDC_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byPlayerNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byPlayerNum; i++)
	{
		dwContextLenTmp += astPlayerInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RANDOM_CHALLENGE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wCurChallengePoint) >= pstIndex->dwContextLen)
				{
					memcpy(&wCurChallengePoint, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCurChallengePoint, 0, sizeof(wCurChallengePoint));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLastRCPoinRefreshTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastRCPoinRefreshTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastRCPoinRefreshTime, 0, sizeof(qwLastRCPoinRefreshTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastBuyRCPoinTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastBuyRCPoinTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastBuyRCPoinTime, 0, sizeof(qwLastBuyRCPoinTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wLastBuyRCPoinNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastBuyRCPoinNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastBuyRCPoinNum, 0, sizeof(wLastBuyRCPoinNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwLastRCTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastRCTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastRCTime, 0, sizeof(qwLastRCTime));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byLastRCRet) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastRCRet, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastRCRet, 0, sizeof(byLastRCRet));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byClrCDFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byClrCDFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byClrCDFlag, 0, sizeof(byClrCDFlag));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byPlayerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerNum, 0, sizeof(byPlayerNum));
				}
			}
			break;
		case 9:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byPlayerNum)
				{
					wArrNum = wArrNum <= MAX_GET_RDC_NUM ? wArrNum : MAX_GET_RDC_NUM;
					byPlayerNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPlayerInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPlayerInfo, 0, sizeof(astPlayerInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPlayerInfo, 0, sizeof(astPlayerInfo));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_WORSHIP_DATA(void *pHost, CNetData* poNetData)
{
	DT_WORSHIP_DATA *pstIn = (DT_WORSHIP_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byWorshipType))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byWorshipTypeLevel))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastWorshipTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_WORSHIP_DATA(void *pHost, CNetData* poNetData)
{
	DT_WORSHIP_DATA *pstOut = (DT_WORSHIP_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byWorshipType))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byWorshipTypeLevel))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastWorshipTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_WORSHIP_DATA(DT_WORSHIP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"WorshipType", (double)(data.byWorshipType));
	cJSON_AddNumberToObject(root,"WorshipTypeLevel", (double)(data.byWorshipTypeLevel));
	cJSON_AddNumberToObject(root,"LastWorshipTime", (double)(data.qwLastWorshipTime));

	return root;
}

INT32 DT_WORSHIP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byWorshipType);
	memcpy(pDataBuff + dwOffset, &byWorshipType, sizeof(byWorshipType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byWorshipTypeLevel);
	memcpy(pDataBuff + dwOffset, &byWorshipTypeLevel, sizeof(byWorshipTypeLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastWorshipTime);
	memcpy(pDataBuff + dwOffset, &qwLastWorshipTime, sizeof(qwLastWorshipTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_WORSHIP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byWorshipType) >= pstIndex->dwContextLen)
				{
					memcpy(&byWorshipType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWorshipType, 0, sizeof(byWorshipType));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byWorshipTypeLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byWorshipTypeLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWorshipTypeLevel, 0, sizeof(byWorshipTypeLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastWorshipTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastWorshipTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastWorshipTime, 0, sizeof(qwLastWorshipTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_WORSHIP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_WORSHIP_DATA_LST *pstIn = (DT_WORSHIP_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_WORSHIP_NUM; i++)
	{
		if(i >= (INT32)pstIn->wNum)
			break;
		if(-1 == EncodeDT_WORSHIP_DATA(&pstIn->astWorshipInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_WORSHIP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_WORSHIP_DATA_LST *pstOut = (DT_WORSHIP_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_WORSHIP_NUM; i++)
	{
		if(i >= (INT32)pstOut->wNum)
			break;
		if(-1 == DecodeDT_WORSHIP_DATA(&pstOut->astWorshipInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_WORSHIP_DATA_LST(DT_WORSHIP_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.wNum));
	cJSON *WorshipInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "WorshipInfo", WorshipInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wNum; ++dwIndex)
	{
		cJSON_AddItemToObject(WorshipInfo, " ", GetJsonDT_WORSHIP_DATA(data.astWorshipInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_WORSHIP_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNum);
	memcpy(pDataBuff + dwOffset, &wNum, sizeof(wNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wNum > MAX_WORSHIP_NUM)
	{
		wNum = MAX_WORSHIP_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wNum; i++)
	{
		dwContextLenTmp += astWorshipInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_WORSHIP_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNum, 0, sizeof(wNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wNum)
				{
					wArrNum = wArrNum <= MAX_WORSHIP_NUM ? wArrNum : MAX_WORSHIP_NUM;
					wNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astWorshipInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astWorshipInfo, 0, sizeof(astWorshipInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astWorshipInfo, 0, sizeof(astWorshipInfo));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CHAPTER_SCORE_DATA(void *pHost, CNetData* poNetData)
{
	DT_CHAPTER_SCORE_DATA *pstIn = (DT_CHAPTER_SCORE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSceneidx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wChapterIdx))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwtime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CHAPTER_SCORE_DATA(void *pHost, CNetData* poNetData)
{
	DT_CHAPTER_SCORE_DATA *pstOut = (DT_CHAPTER_SCORE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSceneidx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wChapterIdx))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwtime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CHAPTER_SCORE_DATA(DT_CHAPTER_SCORE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Sceneidx", (double)(data.wSceneidx));
	cJSON_AddNumberToObject(root,"ChapterIdx", (double)(data.wChapterIdx));
	cJSON_AddNumberToObject(root,"time", (double)(data.qwtime));

	return root;
}

INT32 DT_CHAPTER_SCORE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSceneidx);
	memcpy(pDataBuff + dwOffset, &wSceneidx, sizeof(wSceneidx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wChapterIdx);
	memcpy(pDataBuff + dwOffset, &wChapterIdx, sizeof(wChapterIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwtime);
	memcpy(pDataBuff + dwOffset, &qwtime, sizeof(qwtime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CHAPTER_SCORE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSceneidx) >= pstIndex->dwContextLen)
				{
					memcpy(&wSceneidx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSceneidx, 0, sizeof(wSceneidx));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wChapterIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wChapterIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wChapterIdx, 0, sizeof(wChapterIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwtime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwtime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwtime, 0, sizeof(qwtime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ACCUMULATED_SCORE_DATA(void *pHost, CNetData* poNetData)
{
	DT_ACCUMULATED_SCORE_DATA *pstIn = (DT_ACCUMULATED_SCORE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wgrade))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwtime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ACCUMULATED_SCORE_DATA(void *pHost, CNetData* poNetData)
{
	DT_ACCUMULATED_SCORE_DATA *pstOut = (DT_ACCUMULATED_SCORE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wgrade))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwtime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ACCUMULATED_SCORE_DATA(DT_ACCUMULATED_SCORE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"grade", (double)(data.wgrade));
	cJSON_AddNumberToObject(root,"time", (double)(data.qwtime));

	return root;
}

INT32 DT_ACCUMULATED_SCORE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wgrade);
	memcpy(pDataBuff + dwOffset, &wgrade, sizeof(wgrade));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwtime);
	memcpy(pDataBuff + dwOffset, &qwtime, sizeof(qwtime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ACCUMULATED_SCORE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wgrade) >= pstIndex->dwContextLen)
				{
					memcpy(&wgrade, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wgrade, 0, sizeof(wgrade));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwtime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwtime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwtime, 0, sizeof(qwtime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SCORE_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_SCORE_DATA_LST *pstIn = (DT_SCORE_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byChapterNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_TOWN_PER_SCENE_NUM; i++)
	{
		if(i >= (INT32)pstIn->byChapterNum)
			break;
		if(-1 == EncodeDT_CHAPTER_SCORE_DATA(&pstIn->astChapterData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byAccumulatedNum))
		return -1;

	for(i = 0; i < MAX_TOWN_PER_SCENE_NUM; i++)
	{
		if(i >= (INT32)pstIn->byAccumulatedNum)
			break;
		if(-1 == EncodeDT_ACCUMULATED_SCORE_DATA(&pstIn->astAccumulatedData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SCORE_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_SCORE_DATA_LST *pstOut = (DT_SCORE_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byChapterNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_TOWN_PER_SCENE_NUM; i++)
	{
		if(i >= (INT32)pstOut->byChapterNum)
			break;
		if(-1 == DecodeDT_CHAPTER_SCORE_DATA(&pstOut->astChapterData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byAccumulatedNum))
		return -1;

	for(i = 0; i < MAX_TOWN_PER_SCENE_NUM; i++)
	{
		if(i >= (INT32)pstOut->byAccumulatedNum)
			break;
		if(-1 == DecodeDT_ACCUMULATED_SCORE_DATA(&pstOut->astAccumulatedData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SCORE_DATA_LST(DT_SCORE_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ChapterNum", (double)(data.byChapterNum));
	cJSON *ChapterData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ChapterData", ChapterData);
	for( UINT32 dwIndex=0; dwIndex<data.byChapterNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ChapterData, " ", GetJsonDT_CHAPTER_SCORE_DATA(data.astChapterData[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"AccumulatedNum", (double)(data.byAccumulatedNum));
	cJSON *AccumulatedData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "AccumulatedData", AccumulatedData);
	for( UINT32 dwIndex=0; dwIndex<data.byAccumulatedNum; ++dwIndex)
	{
		cJSON_AddItemToObject(AccumulatedData, " ", GetJsonDT_ACCUMULATED_SCORE_DATA(data.astAccumulatedData[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_SCORE_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byChapterNum);
	memcpy(pDataBuff + dwOffset, &byChapterNum, sizeof(byChapterNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byChapterNum > MAX_TOWN_PER_SCENE_NUM)
	{
		byChapterNum = MAX_TOWN_PER_SCENE_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byChapterNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byChapterNum; i++)
	{
		dwContextLenTmp += astChapterData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byAccumulatedNum);
	memcpy(pDataBuff + dwOffset, &byAccumulatedNum, sizeof(byAccumulatedNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(byAccumulatedNum > MAX_TOWN_PER_SCENE_NUM)
	{
		byAccumulatedNum = MAX_TOWN_PER_SCENE_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byAccumulatedNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byAccumulatedNum; i++)
	{
		dwContextLenTmp += astAccumulatedData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SCORE_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byChapterNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byChapterNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChapterNum, 0, sizeof(byChapterNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byChapterNum)
				{
					wArrNum = wArrNum <= MAX_TOWN_PER_SCENE_NUM ? wArrNum : MAX_TOWN_PER_SCENE_NUM;
					byChapterNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astChapterData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astChapterData, 0, sizeof(astChapterData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astChapterData, 0, sizeof(astChapterData));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byAccumulatedNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byAccumulatedNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAccumulatedNum, 0, sizeof(byAccumulatedNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byAccumulatedNum)
				{
					wArrNum = wArrNum <= MAX_TOWN_PER_SCENE_NUM ? wArrNum : MAX_TOWN_PER_SCENE_NUM;
					byAccumulatedNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astAccumulatedData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astAccumulatedData, 0, sizeof(astAccumulatedData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astAccumulatedData, 0, sizeof(astAccumulatedData));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EQUIP_LEVEL_COMPOSE_DATA(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_LEVEL_COMPOSE_DATA *pstIn = (DT_EQUIP_LEVEL_COMPOSE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wEquipLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurLowColor))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHitKindID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EQUIP_LEVEL_COMPOSE_DATA(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_LEVEL_COMPOSE_DATA *pstOut = (DT_EQUIP_LEVEL_COMPOSE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wEquipLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurLowColor))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHitKindID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EQUIP_LEVEL_COMPOSE_DATA(DT_EQUIP_LEVEL_COMPOSE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipLevel", (double)(data.wEquipLevel));
	cJSON_AddNumberToObject(root,"CurLowColor", (double)(data.byCurLowColor));
	cJSON_AddNumberToObject(root,"HitKindID", (double)(data.wHitKindID));

	return root;
}

INT32 DT_EQUIP_LEVEL_COMPOSE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wEquipLevel);
	memcpy(pDataBuff + dwOffset, &wEquipLevel, sizeof(wEquipLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCurLowColor);
	memcpy(pDataBuff + dwOffset, &byCurLowColor, sizeof(byCurLowColor));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wHitKindID);
	memcpy(pDataBuff + dwOffset, &wHitKindID, sizeof(wHitKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EQUIP_LEVEL_COMPOSE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wEquipLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wEquipLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wEquipLevel, 0, sizeof(wEquipLevel));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCurLowColor) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurLowColor, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurLowColor, 0, sizeof(byCurLowColor));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wHitKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHitKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHitKindID, 0, sizeof(wHitKindID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EQUIP_COMPOSE_DATA(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_COMPOSE_DATA *pstIn = (DT_EQUIP_COMPOSE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byEquipLevelNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_EQUIPLEVEL_NUM; i++)
	{
		if(i >= (INT32)pstIn->byEquipLevelNum)
			break;
		if(-1 == EncodeDT_EQUIP_LEVEL_COMPOSE_DATA(&pstIn->astEquipLevelInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddUint64(pstIn->qwLastComposeTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLastComposeEquipLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EQUIP_COMPOSE_DATA(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_COMPOSE_DATA *pstOut = (DT_EQUIP_COMPOSE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byEquipLevelNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_EQUIPLEVEL_NUM; i++)
	{
		if(i >= (INT32)pstOut->byEquipLevelNum)
			break;
		if(-1 == DecodeDT_EQUIP_LEVEL_COMPOSE_DATA(&pstOut->astEquipLevelInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelUint64(pstOut->qwLastComposeTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLastComposeEquipLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EQUIP_COMPOSE_DATA(DT_EQUIP_COMPOSE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EquipLevelNum", (double)(data.byEquipLevelNum));
	cJSON *EquipLevelInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EquipLevelInfo", EquipLevelInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byEquipLevelNum; ++dwIndex)
	{
		cJSON_AddItemToObject(EquipLevelInfo, " ", GetJsonDT_EQUIP_LEVEL_COMPOSE_DATA(data.astEquipLevelInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"LastComposeTime", (double)(data.qwLastComposeTime));
	cJSON_AddNumberToObject(root,"LastComposeEquipLevel", (double)(data.wLastComposeEquipLevel));

	return root;
}

INT32 DT_EQUIP_COMPOSE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byEquipLevelNum);
	memcpy(pDataBuff + dwOffset, &byEquipLevelNum, sizeof(byEquipLevelNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byEquipLevelNum > MAX_EQUIPLEVEL_NUM)
	{
		byEquipLevelNum = MAX_EQUIPLEVEL_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byEquipLevelNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byEquipLevelNum; i++)
	{
		dwContextLenTmp += astEquipLevelInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastComposeTime);
	memcpy(pDataBuff + dwOffset, &qwLastComposeTime, sizeof(qwLastComposeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wLastComposeEquipLevel);
	memcpy(pDataBuff + dwOffset, &wLastComposeEquipLevel, sizeof(wLastComposeEquipLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EQUIP_COMPOSE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byEquipLevelNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byEquipLevelNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEquipLevelNum, 0, sizeof(byEquipLevelNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byEquipLevelNum)
				{
					wArrNum = wArrNum <= MAX_EQUIPLEVEL_NUM ? wArrNum : MAX_EQUIPLEVEL_NUM;
					byEquipLevelNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astEquipLevelInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astEquipLevelInfo, 0, sizeof(astEquipLevelInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astEquipLevelInfo, 0, sizeof(astEquipLevelInfo));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastComposeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastComposeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastComposeTime, 0, sizeof(qwLastComposeTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wLastComposeEquipLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLastComposeEquipLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLastComposeEquipLevel, 0, sizeof(wLastComposeEquipLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GATHER_SCIENCE_DATA(void *pHost, CNetData* poNetData)
{
	DT_GATHER_SCIENCE_DATA *pstIn = (DT_GATHER_SCIENCE_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wCoinNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwCoinLastTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wGoldNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwGoldLastTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIncrease))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GATHER_SCIENCE_DATA(void *pHost, CNetData* poNetData)
{
	DT_GATHER_SCIENCE_DATA *pstOut = (DT_GATHER_SCIENCE_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wCoinNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwCoinLastTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wGoldNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwGoldLastTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIncrease))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GATHER_SCIENCE_DATA(DT_GATHER_SCIENCE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CoinNum", (double)(data.wCoinNum));
	cJSON_AddNumberToObject(root,"CoinLastTime", (double)(data.qwCoinLastTime));
	cJSON_AddNumberToObject(root,"GoldNum", (double)(data.wGoldNum));
	cJSON_AddNumberToObject(root,"GoldLastTime", (double)(data.qwGoldLastTime));
	cJSON_AddNumberToObject(root,"Increase", (double)(data.byIncrease));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_GATHER_SCIENCE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wCoinNum);
	memcpy(pDataBuff + dwOffset, &wCoinNum, sizeof(wCoinNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwCoinLastTime);
	memcpy(pDataBuff + dwOffset, &qwCoinLastTime, sizeof(qwCoinLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wGoldNum);
	memcpy(pDataBuff + dwOffset, &wGoldNum, sizeof(wGoldNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwGoldLastTime);
	memcpy(pDataBuff + dwOffset, &qwGoldLastTime, sizeof(qwGoldLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byIncrease);
	memcpy(pDataBuff + dwOffset, &byIncrease, sizeof(byIncrease));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GATHER_SCIENCE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wCoinNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wCoinNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCoinNum, 0, sizeof(wCoinNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwCoinLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwCoinLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwCoinLastTime, 0, sizeof(qwCoinLastTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wGoldNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wGoldNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wGoldNum, 0, sizeof(wGoldNum));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwGoldLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwGoldLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwGoldLastTime, 0, sizeof(qwGoldLastTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byIncrease) >= pstIndex->dwContextLen)
				{
					memcpy(&byIncrease, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIncrease, 0, sizeof(byIncrease));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BEGBLUE_RES(void *pHost, CNetData* poNetData)
{
	DT_BEGBLUE_RES *pstIn = (DT_BEGBLUE_RES*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSmileNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwBlueUnit))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwStoryUnit))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wXnMultiple))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszLuckPrompt, sizeof(pstIn->aszLuckPrompt)))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwCreateTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwUpdateTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BEGBLUE_RES(void *pHost, CNetData* poNetData)
{
	DT_BEGBLUE_RES *pstOut = (DT_BEGBLUE_RES*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSmileNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwBlueUnit))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwStoryUnit))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wXnMultiple))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszLuckPrompt, sizeof(pstOut->aszLuckPrompt)))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwCreateTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwUpdateTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BEGBLUE_RES(DT_BEGBLUE_RES &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SmileNum", (double)(data.wSmileNum));
	cJSON_AddNumberToObject(root,"BlueUnit", (double)(data.dwBlueUnit));
	cJSON_AddNumberToObject(root,"StoryUnit", (double)(data.dwStoryUnit));
	cJSON_AddNumberToObject(root,"XnMultiple", (double)(data.wXnMultiple));
	cJSON_AddStringToObject(root,"LuckPrompt", data.aszLuckPrompt );
	cJSON_AddNumberToObject(root,"CreateTime", (double)(data.qwCreateTime));
	cJSON_AddNumberToObject(root,"UpdateTime", (double)(data.qwUpdateTime));

	return root;
}

INT32 DT_BEGBLUE_RES::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSmileNum);
	memcpy(pDataBuff + dwOffset, &wSmileNum, sizeof(wSmileNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwBlueUnit);
	memcpy(pDataBuff + dwOffset, &dwBlueUnit, sizeof(dwBlueUnit));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwStoryUnit);
	memcpy(pDataBuff + dwOffset, &dwStoryUnit, sizeof(dwStoryUnit));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wXnMultiple);
	memcpy(pDataBuff + dwOffset, &wXnMultiple, sizeof(wXnMultiple));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(aszLuckPrompt) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = BEGBLUE_LUCK_PROMPT;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszLuckPrompt, sizeof(aszLuckPrompt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(qwCreateTime);
	memcpy(pDataBuff + dwOffset, &qwCreateTime, sizeof(qwCreateTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwUpdateTime);
	memcpy(pDataBuff + dwOffset, &qwUpdateTime, sizeof(qwUpdateTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BEGBLUE_RES::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSmileNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wSmileNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSmileNum, 0, sizeof(wSmileNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwBlueUnit) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBlueUnit, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBlueUnit, 0, sizeof(dwBlueUnit));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwStoryUnit) >= pstIndex->dwContextLen)
				{
					memcpy(&dwStoryUnit, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwStoryUnit, 0, sizeof(dwStoryUnit));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wXnMultiple) >= pstIndex->dwContextLen)
				{
					memcpy(&wXnMultiple, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wXnMultiple, 0, sizeof(wXnMultiple));
				}
			}
			break;
		case 5:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszLuckPrompt) >= dwContextLen) && (wArrNum <= BEGBLUE_LUCK_PROMPT))
				{
					memcpy(&aszLuckPrompt, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszLuckPrompt, 0, sizeof(aszLuckPrompt));
				}
			}
			break;
		case 6:
			{
				if(sizeof(qwCreateTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwCreateTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwCreateTime, 0, sizeof(qwCreateTime));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwUpdateTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwUpdateTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwUpdateTime, 0, sizeof(qwUpdateTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CONSUME_BEGBLUE_SMILE_LST(void *pHost, CNetData* poNetData)
{
	DT_CONSUME_BEGBLUE_SMILE_LST *pstIn = (DT_CONSUME_BEGBLUE_SMILE_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wConsumeTimes))
		return -1;

	INT32 i;
	for(i = 0; i < BEGBLUE_CONSUME_TIMES; i++)
	{
		if(i >= (INT32)pstIn->wConsumeTimes)
			break;
		if(-1 == poNetData->AddWord(pstIn->awConsumeSmileNum[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CONSUME_BEGBLUE_SMILE_LST(void *pHost, CNetData* poNetData)
{
	DT_CONSUME_BEGBLUE_SMILE_LST *pstOut = (DT_CONSUME_BEGBLUE_SMILE_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wConsumeTimes))
		return -1;

	INT32 i;
	for(i = 0; i < BEGBLUE_CONSUME_TIMES; i++)
	{
		if(i >= (INT32)pstOut->wConsumeTimes)
			break;
		if(-1 == poNetData->DelWord(pstOut->awConsumeSmileNum[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CONSUME_BEGBLUE_SMILE_LST(DT_CONSUME_BEGBLUE_SMILE_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ConsumeTimes", (double)(data.wConsumeTimes));
	cJSON *ConsumeSmileNum = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ConsumeSmileNum", ConsumeSmileNum);
	for( UINT32 dwIndex=0; dwIndex<data.wConsumeTimes; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"ConsumeSmileNum", (double)(data.awConsumeSmileNum[dwIndex]));
	}

	return root;
}

INT32 DT_CONSUME_BEGBLUE_SMILE_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wConsumeTimes);
	memcpy(pDataBuff + dwOffset, &wConsumeTimes, sizeof(wConsumeTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(wConsumeTimes > BEGBLUE_CONSUME_TIMES)
	{
		wConsumeTimes = BEGBLUE_CONSUME_TIMES;
	}
	pstIndex->dwContextLen = wConsumeTimes * sizeof(UINT16) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = wConsumeTimes;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awConsumeSmileNum, wConsumeTimes * sizeof(UINT16));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CONSUME_BEGBLUE_SMILE_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wConsumeTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&wConsumeTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wConsumeTimes, 0, sizeof(wConsumeTimes));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awConsumeSmileNum) >= dwContextLen) && (wArrNum == wConsumeTimes) && (wArrNum <= BEGBLUE_CONSUME_TIMES))
				{
					memcpy(&awConsumeSmileNum, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awConsumeSmileNum, 0, sizeof(awConsumeSmileNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BEGBLUE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BEGBLUE_DATA *pstIn = (DT_BEGBLUE_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwBegBlueLastTime))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszClimbTowerPrompt, sizeof(pstIn->aszClimbTowerPrompt)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwMaxBegTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwUsedBegTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFreeImproveLuckMaxTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwUsedFreeImproveLuckTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGoldImproveLuckIdx))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwNextImproveLuckGold))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsHaveToComfirmBegBlueInfo))
		return -1;

	if(-1 == EncodeDT_BEGBLUE_RES(&pstIn->stBegBlueRes, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsIgnoreXnMultiple))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSmileNum))
		return -1;

	if(-1 == EncodeDT_CONSUME_BEGBLUE_SMILE_LST(&pstIn->stDtConsumeSmile, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BEGBLUE_DATA(void *pHost, CNetData* poNetData)
{
	DT_BEGBLUE_DATA *pstOut = (DT_BEGBLUE_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwBegBlueLastTime))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszClimbTowerPrompt, sizeof(pstOut->aszClimbTowerPrompt)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwMaxBegTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwUsedBegTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFreeImproveLuckMaxTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwUsedFreeImproveLuckTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGoldImproveLuckIdx))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwNextImproveLuckGold))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsHaveToComfirmBegBlueInfo))
		return -1;

	if(-1 == DecodeDT_BEGBLUE_RES(&pstOut->stBegBlueRes, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsIgnoreXnMultiple))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSmileNum))
		return -1;

	if(-1 == DecodeDT_CONSUME_BEGBLUE_SMILE_LST(&pstOut->stDtConsumeSmile, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BEGBLUE_DATA(DT_BEGBLUE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BegBlueLastTime", (double)(data.qwBegBlueLastTime));
	cJSON_AddStringToObject(root,"ClimbTowerPrompt", data.aszClimbTowerPrompt );
	cJSON_AddNumberToObject(root,"MaxBegTimes", (double)(data.dwMaxBegTimes));
	cJSON_AddNumberToObject(root,"UsedBegTimes", (double)(data.dwUsedBegTimes));
	cJSON_AddNumberToObject(root,"FreeImproveLuckMaxTimes", (double)(data.dwFreeImproveLuckMaxTimes));
	cJSON_AddNumberToObject(root,"UsedFreeImproveLuckTimes", (double)(data.dwUsedFreeImproveLuckTimes));
	cJSON_AddNumberToObject(root,"GoldImproveLuckIdx", (double)(data.dwGoldImproveLuckIdx));
	cJSON_AddNumberToObject(root,"NextImproveLuckGold", (double)(data.dwNextImproveLuckGold));
	cJSON_AddNumberToObject(root,"IsHaveToComfirmBegBlueInfo", (double)(data.byIsHaveToComfirmBegBlueInfo));
	cJSON_AddItemToObject(root, "BegBlueRes", GetJsonDT_BEGBLUE_RES(data.stBegBlueRes));
	cJSON_AddNumberToObject(root,"IsIgnoreXnMultiple", (double)(data.byIsIgnoreXnMultiple));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"SmileNum", (double)(data.wSmileNum));
	cJSON_AddItemToObject(root, "DtConsumeSmile", GetJsonDT_CONSUME_BEGBLUE_SMILE_LST(data.stDtConsumeSmile));

	return root;
}

INT32 DT_BEGBLUE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 14;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwBegBlueLastTime);
	memcpy(pDataBuff + dwOffset, &qwBegBlueLastTime, sizeof(qwBegBlueLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(aszClimbTowerPrompt) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = BEGBLUE_CLIMB_TOWER_PROMPT;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszClimbTowerPrompt, sizeof(aszClimbTowerPrompt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwMaxBegTimes);
	memcpy(pDataBuff + dwOffset, &dwMaxBegTimes, sizeof(dwMaxBegTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwUsedBegTimes);
	memcpy(pDataBuff + dwOffset, &dwUsedBegTimes, sizeof(dwUsedBegTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwFreeImproveLuckMaxTimes);
	memcpy(pDataBuff + dwOffset, &dwFreeImproveLuckMaxTimes, sizeof(dwFreeImproveLuckMaxTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwUsedFreeImproveLuckTimes);
	memcpy(pDataBuff + dwOffset, &dwUsedFreeImproveLuckTimes, sizeof(dwUsedFreeImproveLuckTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwGoldImproveLuckIdx);
	memcpy(pDataBuff + dwOffset, &dwGoldImproveLuckIdx, sizeof(dwGoldImproveLuckIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwNextImproveLuckGold);
	memcpy(pDataBuff + dwOffset, &dwNextImproveLuckGold, sizeof(dwNextImproveLuckGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byIsHaveToComfirmBegBlueInfo);
	memcpy(pDataBuff + dwOffset, &byIsHaveToComfirmBegBlueInfo, sizeof(byIsHaveToComfirmBegBlueInfo));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = stBegBlueRes.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byIsIgnoreXnMultiple);
	memcpy(pDataBuff + dwOffset, &byIsIgnoreXnMultiple, sizeof(byIsIgnoreXnMultiple));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(wSmileNum);
	memcpy(pDataBuff + dwOffset, &wSmileNum, sizeof(wSmileNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = stDtConsumeSmile.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BEGBLUE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwBegBlueLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBegBlueLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBegBlueLastTime, 0, sizeof(qwBegBlueLastTime));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszClimbTowerPrompt) >= dwContextLen) && (wArrNum <= BEGBLUE_CLIMB_TOWER_PROMPT))
				{
					memcpy(&aszClimbTowerPrompt, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszClimbTowerPrompt, 0, sizeof(aszClimbTowerPrompt));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwMaxBegTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwMaxBegTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwMaxBegTimes, 0, sizeof(dwMaxBegTimes));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwUsedBegTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwUsedBegTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwUsedBegTimes, 0, sizeof(dwUsedBegTimes));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwFreeImproveLuckMaxTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFreeImproveLuckMaxTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFreeImproveLuckMaxTimes, 0, sizeof(dwFreeImproveLuckMaxTimes));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwUsedFreeImproveLuckTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwUsedFreeImproveLuckTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwUsedFreeImproveLuckTimes, 0, sizeof(dwUsedFreeImproveLuckTimes));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwGoldImproveLuckIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGoldImproveLuckIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGoldImproveLuckIdx, 0, sizeof(dwGoldImproveLuckIdx));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwNextImproveLuckGold) >= pstIndex->dwContextLen)
				{
					memcpy(&dwNextImproveLuckGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwNextImproveLuckGold, 0, sizeof(dwNextImproveLuckGold));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byIsHaveToComfirmBegBlueInfo) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsHaveToComfirmBegBlueInfo, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsHaveToComfirmBegBlueInfo, 0, sizeof(byIsHaveToComfirmBegBlueInfo));
				}
			}
			break;
		case 10:
			{
				stBegBlueRes.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 11:
			{
				if(sizeof(byIsIgnoreXnMultiple) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsIgnoreXnMultiple, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsIgnoreXnMultiple, 0, sizeof(byIsIgnoreXnMultiple));
				}
			}
			break;
		case 12:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 13:
			{
				if(sizeof(wSmileNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wSmileNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSmileNum, 0, sizeof(wSmileNum));
				}
			}
			break;
		case 14:
			{
				stDtConsumeSmile.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SEND_FLOWER_DATA(void *pHost, CNetData* poNetData)
{
	DT_SEND_FLOWER_DATA *pstIn = (DT_SEND_FLOWER_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwSendFlowerNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byUsedSendTimes))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byExt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SEND_FLOWER_DATA(void *pHost, CNetData* poNetData)
{
	DT_SEND_FLOWER_DATA *pstOut = (DT_SEND_FLOWER_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwSendFlowerNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byUsedSendTimes))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byExt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SEND_FLOWER_DATA(DT_SEND_FLOWER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SendFlowerNum", (double)(data.dwSendFlowerNum));
	cJSON_AddNumberToObject(root,"UsedSendTimes", (double)(data.byUsedSendTimes));
	cJSON_AddNumberToObject(root,"Ext", (double)(data.byExt));

	return root;
}

INT32 DT_SEND_FLOWER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwSendFlowerNum);
	memcpy(pDataBuff + dwOffset, &dwSendFlowerNum, sizeof(dwSendFlowerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byUsedSendTimes);
	memcpy(pDataBuff + dwOffset, &byUsedSendTimes, sizeof(byUsedSendTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byExt);
	memcpy(pDataBuff + dwOffset, &byExt, sizeof(byExt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SEND_FLOWER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwSendFlowerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSendFlowerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSendFlowerNum, 0, sizeof(dwSendFlowerNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byUsedSendTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byUsedSendTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byUsedSendTimes, 0, sizeof(byUsedSendTimes));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byExt) >= pstIndex->dwContextLen)
				{
					memcpy(&byExt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byExt, 0, sizeof(byExt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FINALLY_CONTACT_DATA(void *pHost, CNetData* poNetData)
{
	DT_FINALLY_CONTACT_DATA *pstIn = (DT_FINALLY_CONTACT_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastContactTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FINALLY_CONTACT_DATA(void *pHost, CNetData* poNetData)
{
	DT_FINALLY_CONTACT_DATA *pstOut = (DT_FINALLY_CONTACT_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastContactTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FINALLY_CONTACT_DATA(DT_FINALLY_CONTACT_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddNumberToObject(root,"LastContactTime", (double)(data.qwLastContactTime));

	return root;
}

INT32 DT_FINALLY_CONTACT_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastContactTime);
	memcpy(pDataBuff + dwOffset, &qwLastContactTime, sizeof(qwLastContactTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FINALLY_CONTACT_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLastContactTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastContactTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastContactTime, 0, sizeof(qwLastContactTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FINALLY_CONTACT_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_FINALLY_CONTACT_DATA_LST *pstIn = (DT_FINALLY_CONTACT_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFinallyContactNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FINALLY_CONTACT_DATA_NUM; i++)
	{
		if(i >= (INT32)pstIn->byFinallyContactNum)
			break;
		if(-1 == EncodeDT_FINALLY_CONTACT_DATA(&pstIn->astFinallyContactData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FINALLY_CONTACT_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_FINALLY_CONTACT_DATA_LST *pstOut = (DT_FINALLY_CONTACT_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFinallyContactNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FINALLY_CONTACT_DATA_NUM; i++)
	{
		if(i >= (INT32)pstOut->byFinallyContactNum)
			break;
		if(-1 == DecodeDT_FINALLY_CONTACT_DATA(&pstOut->astFinallyContactData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FINALLY_CONTACT_DATA_LST(DT_FINALLY_CONTACT_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FinallyContactNum", (double)(data.byFinallyContactNum));
	cJSON *FinallyContactData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FinallyContactData", FinallyContactData);
	for( UINT32 dwIndex=0; dwIndex<data.byFinallyContactNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FinallyContactData, " ", GetJsonDT_FINALLY_CONTACT_DATA(data.astFinallyContactData[dwIndex]));
	}

	return root;
}

INT32 DT_FINALLY_CONTACT_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFinallyContactNum);
	memcpy(pDataBuff + dwOffset, &byFinallyContactNum, sizeof(byFinallyContactNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byFinallyContactNum > MAX_FINALLY_CONTACT_DATA_NUM)
	{
		byFinallyContactNum = MAX_FINALLY_CONTACT_DATA_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFinallyContactNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFinallyContactNum; i++)
	{
		dwContextLenTmp += astFinallyContactData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FINALLY_CONTACT_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFinallyContactNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byFinallyContactNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFinallyContactNum, 0, sizeof(byFinallyContactNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFinallyContactNum)
				{
					wArrNum = wArrNum <= MAX_FINALLY_CONTACT_DATA_NUM ? wArrNum : MAX_FINALLY_CONTACT_DATA_NUM;
					byFinallyContactNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFinallyContactData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFinallyContactData, 0, sizeof(astFinallyContactData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFinallyContactData, 0, sizeof(astFinallyContactData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RECV_FLOWER_DATA_EX_LOG(void *pHost, CNetData* poNetData)
{
	DT_RECV_FLOWER_DATA_EX_LOG *pstIn = (DT_RECV_FLOWER_DATA_EX_LOG*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwSendPlayerID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwKindID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSendTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFlag))
		return -1;

	if(-1 == EncodeDT_RES_NUM_ITEM_DATA(&pstIn->stResNumItemData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RECV_FLOWER_DATA_EX_LOG(void *pHost, CNetData* poNetData)
{
	DT_RECV_FLOWER_DATA_EX_LOG *pstOut = (DT_RECV_FLOWER_DATA_EX_LOG*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwSendPlayerID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwKindID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSendTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFlag))
		return -1;

	if(-1 == DecodeDT_RES_NUM_ITEM_DATA(&pstOut->stResNumItemData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RECV_FLOWER_DATA_EX_LOG(DT_RECV_FLOWER_DATA_EX_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SendPlayerID", (double)(data.dwSendPlayerID));
	cJSON_AddNumberToObject(root,"KindID", (double)(data.dwKindID));
	cJSON_AddNumberToObject(root,"SendTime", (double)(data.qwSendTime));
	cJSON_AddNumberToObject(root,"Flag", (double)(data.byFlag));
	cJSON_AddItemToObject(root, "ResNumItemData", GetJsonDT_RES_NUM_ITEM_DATA(data.stResNumItemData));

	return root;
}

INT32 DT_RECV_FLOWER_DATA_EX_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwSendPlayerID);
	memcpy(pDataBuff + dwOffset, &dwSendPlayerID, sizeof(dwSendPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwKindID);
	memcpy(pDataBuff + dwOffset, &dwKindID, sizeof(dwKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwSendTime);
	memcpy(pDataBuff + dwOffset, &qwSendTime, sizeof(qwSendTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byFlag);
	memcpy(pDataBuff + dwOffset, &byFlag, sizeof(byFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stResNumItemData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RECV_FLOWER_DATA_EX_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwSendPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSendPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSendPlayerID, 0, sizeof(dwSendPlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwKindID, 0, sizeof(dwKindID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwSendTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSendTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSendTime, 0, sizeof(qwSendTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFlag, 0, sizeof(byFlag));
				}
			}
			break;
		case 5:
			{
				stResNumItemData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FRIENDS_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_FRIENDS_BASE_DATA *pstIn = (DT_FRIENDS_BASE_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastSendFlowerTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byElemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SEND_FLOWER_DATA_NUM; i++)
	{
		if(i >= (INT32)pstIn->byElemNum)
			break;
		if(-1 == EncodeDT_SEND_FLOWER_DATA(&pstIn->astListData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == EncodeDT_FINALLY_CONTACT_DATA_LST(&pstIn->stFinallyContactDataList, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastRecvFlowerTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRecvFlowerTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSendFlowerTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwLogNum))
		return -1;

	for(i = 0; i < MAX_RECV_FLOWER_LOG_LIST_ELEM_EX_NUM; i++)
	{
		if(i >= (INT32)pstIn->dwLogNum)
			break;
		if(-1 == EncodeDT_RECV_FLOWER_DATA_EX_LOG(&pstIn->astLogData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FRIENDS_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_FRIENDS_BASE_DATA *pstOut = (DT_FRIENDS_BASE_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastSendFlowerTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byElemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SEND_FLOWER_DATA_NUM; i++)
	{
		if(i >= (INT32)pstOut->byElemNum)
			break;
		if(-1 == DecodeDT_SEND_FLOWER_DATA(&pstOut->astListData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == DecodeDT_FINALLY_CONTACT_DATA_LST(&pstOut->stFinallyContactDataList, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastRecvFlowerTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRecvFlowerTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSendFlowerTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwLogNum))
		return -1;

	for(i = 0; i < MAX_RECV_FLOWER_LOG_LIST_ELEM_EX_NUM; i++)
	{
		if(i >= (INT32)pstOut->dwLogNum)
			break;
		if(-1 == DecodeDT_RECV_FLOWER_DATA_EX_LOG(&pstOut->astLogData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FRIENDS_BASE_DATA(DT_FRIENDS_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastSendFlowerTime", (double)(data.qwLastSendFlowerTime));
	cJSON_AddNumberToObject(root,"ElemNum", (double)(data.byElemNum));
	cJSON *ListData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ListData", ListData);
	for( UINT32 dwIndex=0; dwIndex<data.byElemNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ListData, " ", GetJsonDT_SEND_FLOWER_DATA(data.astListData[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddItemToObject(root, "FinallyContactDataList", GetJsonDT_FINALLY_CONTACT_DATA_LST(data.stFinallyContactDataList));
	cJSON_AddNumberToObject(root,"LastRecvFlowerTime", (double)(data.qwLastRecvFlowerTime));
	cJSON_AddNumberToObject(root,"RecvFlowerTimes", (double)(data.dwRecvFlowerTimes));
	cJSON_AddNumberToObject(root,"SendFlowerTimes", (double)(data.dwSendFlowerTimes));
	cJSON_AddNumberToObject(root,"LogNum", (double)(data.dwLogNum));
	cJSON *LogData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "LogData", LogData);
	for( UINT32 dwIndex=0; dwIndex<data.dwLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(LogData, " ", GetJsonDT_RECV_FLOWER_DATA_EX_LOG(data.astLogData[dwIndex]));
	}

	return root;
}

INT32 DT_FRIENDS_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastSendFlowerTime);
	memcpy(pDataBuff + dwOffset, &qwLastSendFlowerTime, sizeof(qwLastSendFlowerTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byElemNum);
	memcpy(pDataBuff + dwOffset, &byElemNum, sizeof(byElemNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(byElemNum > MAX_SEND_FLOWER_DATA_NUM)
	{
		byElemNum = MAX_SEND_FLOWER_DATA_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byElemNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byElemNum; i++)
	{
		dwContextLenTmp += astListData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stFinallyContactDataList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(qwLastRecvFlowerTime);
	memcpy(pDataBuff + dwOffset, &qwLastRecvFlowerTime, sizeof(qwLastRecvFlowerTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwRecvFlowerTimes);
	memcpy(pDataBuff + dwOffset, &dwRecvFlowerTimes, sizeof(dwRecvFlowerTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwSendFlowerTimes);
	memcpy(pDataBuff + dwOffset, &dwSendFlowerTimes, sizeof(dwSendFlowerTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwLogNum);
	memcpy(pDataBuff + dwOffset, &dwLogNum, sizeof(dwLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	dwContextLenTmp = 0;
	if(dwLogNum > MAX_RECV_FLOWER_LOG_LIST_ELEM_EX_NUM)
	{
		dwLogNum = MAX_RECV_FLOWER_LOG_LIST_ELEM_EX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = dwLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < dwLogNum; i++)
	{
		dwContextLenTmp += astLogData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FRIENDS_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastSendFlowerTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastSendFlowerTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastSendFlowerTime, 0, sizeof(qwLastSendFlowerTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byElemNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byElemNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byElemNum, 0, sizeof(byElemNum));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byElemNum)
				{
					wArrNum = wArrNum <= MAX_SEND_FLOWER_DATA_NUM ? wArrNum : MAX_SEND_FLOWER_DATA_NUM;
					byElemNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astListData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astListData, 0, sizeof(astListData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astListData, 0, sizeof(astListData));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 5:
			{
				stFinallyContactDataList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				if(sizeof(qwLastRecvFlowerTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastRecvFlowerTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastRecvFlowerTime, 0, sizeof(qwLastRecvFlowerTime));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwRecvFlowerTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRecvFlowerTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRecvFlowerTimes, 0, sizeof(dwRecvFlowerTimes));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwSendFlowerTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSendFlowerTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSendFlowerTimes, 0, sizeof(dwSendFlowerTimes));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwLogNum, 0, sizeof(dwLogNum));
				}
			}
			break;
		case 10:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == dwLogNum)
				{
					wArrNum = wArrNum <= MAX_RECV_FLOWER_LOG_LIST_ELEM_EX_NUM ? wArrNum : MAX_RECV_FLOWER_LOG_LIST_ELEM_EX_NUM;
					dwLogNum = (UINT32)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astLogData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astLogData, 0, sizeof(astLogData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astLogData, 0, sizeof(astLogData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RAREITEM_GOODS_INFO(void *pHost, CNetData* poNetData)
{
	DT_RAREITEM_GOODS_INFO *pstIn = (DT_RAREITEM_GOODS_INFO*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wRareItemID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRareItemHaveExchangeNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastResetTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RAREITEM_GOODS_INFO(void *pHost, CNetData* poNetData)
{
	DT_RAREITEM_GOODS_INFO *pstOut = (DT_RAREITEM_GOODS_INFO*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wRareItemID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRareItemHaveExchangeNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastResetTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RAREITEM_GOODS_INFO(DT_RAREITEM_GOODS_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RareItemID", (double)(data.wRareItemID));
	cJSON_AddNumberToObject(root,"RareItemHaveExchangeNum", (double)(data.dwRareItemHaveExchangeNum));
	cJSON_AddNumberToObject(root,"LastResetTime", (double)(data.qwLastResetTime));

	return root;
}

INT32 DT_RAREITEM_GOODS_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wRareItemID);
	memcpy(pDataBuff + dwOffset, &wRareItemID, sizeof(wRareItemID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwRareItemHaveExchangeNum);
	memcpy(pDataBuff + dwOffset, &dwRareItemHaveExchangeNum, sizeof(dwRareItemHaveExchangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastResetTime);
	memcpy(pDataBuff + dwOffset, &qwLastResetTime, sizeof(qwLastResetTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RAREITEM_GOODS_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wRareItemID) >= pstIndex->dwContextLen)
				{
					memcpy(&wRareItemID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRareItemID, 0, sizeof(wRareItemID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwRareItemHaveExchangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRareItemHaveExchangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRareItemHaveExchangeNum, 0, sizeof(dwRareItemHaveExchangeNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastResetTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastResetTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastResetTime, 0, sizeof(qwLastResetTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RAREITEM_GOODS_DATA(void *pHost, CNetData* poNetData)
{
	DT_RAREITEM_GOODS_DATA *pstIn = (DT_RAREITEM_GOODS_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byRareItemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RAREITEM_RES_NUM; i++)
	{
		if(i >= (INT32)pstIn->byRareItemNum)
			break;
		if(-1 == EncodeDT_RAREITEM_GOODS_INFO(&pstIn->astRareItemGoodInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddUint64(pstIn->qwLastUpdataTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RAREITEM_GOODS_DATA(void *pHost, CNetData* poNetData)
{
	DT_RAREITEM_GOODS_DATA *pstOut = (DT_RAREITEM_GOODS_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byRareItemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RAREITEM_RES_NUM; i++)
	{
		if(i >= (INT32)pstOut->byRareItemNum)
			break;
		if(-1 == DecodeDT_RAREITEM_GOODS_INFO(&pstOut->astRareItemGoodInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelUint64(pstOut->qwLastUpdataTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RAREITEM_GOODS_DATA(DT_RAREITEM_GOODS_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RareItemNum", (double)(data.byRareItemNum));
	cJSON *RareItemGoodInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "RareItemGoodInfo", RareItemGoodInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byRareItemNum; ++dwIndex)
	{
		cJSON_AddItemToObject(RareItemGoodInfo, " ", GetJsonDT_RAREITEM_GOODS_INFO(data.astRareItemGoodInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"LastUpdataTime", (double)(data.qwLastUpdataTime));

	return root;
}

INT32 DT_RAREITEM_GOODS_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byRareItemNum);
	memcpy(pDataBuff + dwOffset, &byRareItemNum, sizeof(byRareItemNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byRareItemNum > MAX_RAREITEM_RES_NUM)
	{
		byRareItemNum = MAX_RAREITEM_RES_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byRareItemNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byRareItemNum; i++)
	{
		dwContextLenTmp += astRareItemGoodInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastUpdataTime);
	memcpy(pDataBuff + dwOffset, &qwLastUpdataTime, sizeof(qwLastUpdataTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RAREITEM_GOODS_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byRareItemNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byRareItemNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRareItemNum, 0, sizeof(byRareItemNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byRareItemNum)
				{
					wArrNum = wArrNum <= MAX_RAREITEM_RES_NUM ? wArrNum : MAX_RAREITEM_RES_NUM;
					byRareItemNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astRareItemGoodInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astRareItemGoodInfo, 0, sizeof(astRareItemGoodInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astRareItemGoodInfo, 0, sizeof(astRareItemGoodInfo));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwLastUpdataTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastUpdataTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastUpdataTime, 0, sizeof(qwLastUpdataTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GYMNASIUM_SKILL_INFO(void *pHost, CNetData* poNetData)
{
	DT_GYMNASIUM_SKILL_INFO *pstIn = (DT_GYMNASIUM_SKILL_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->bySkillID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurSkillLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GYMNASIUM_SKILL_INFO(void *pHost, CNetData* poNetData)
{
	DT_GYMNASIUM_SKILL_INFO *pstOut = (DT_GYMNASIUM_SKILL_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->bySkillID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurSkillLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GYMNASIUM_SKILL_INFO(DT_GYMNASIUM_SKILL_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SkillID", (double)(data.bySkillID));
	cJSON_AddNumberToObject(root,"CurSkillLevel", (double)(data.byCurSkillLevel));

	return root;
}

INT32 DT_GYMNASIUM_SKILL_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(bySkillID);
	memcpy(pDataBuff + dwOffset, &bySkillID, sizeof(bySkillID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCurSkillLevel);
	memcpy(pDataBuff + dwOffset, &byCurSkillLevel, sizeof(byCurSkillLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GYMNASIUM_SKILL_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(bySkillID) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkillID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkillID, 0, sizeof(bySkillID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCurSkillLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurSkillLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurSkillLevel, 0, sizeof(byCurSkillLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GYMNASIUM_DATA(void *pHost, CNetData* poNetData)
{
	DT_GYMNASIUM_DATA *pstIn = (DT_GYMNASIUM_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->bySkillNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GYMNASIUM_SKILL_NUM; i++)
	{
		if(i >= (INT32)pstIn->bySkillNum)
			break;
		if(-1 == EncodeDT_GYMNASIUM_SKILL_INFO(&pstIn->astGymnasiumSkillInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GYMNASIUM_DATA(void *pHost, CNetData* poNetData)
{
	DT_GYMNASIUM_DATA *pstOut = (DT_GYMNASIUM_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->bySkillNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GYMNASIUM_SKILL_NUM; i++)
	{
		if(i >= (INT32)pstOut->bySkillNum)
			break;
		if(-1 == DecodeDT_GYMNASIUM_SKILL_INFO(&pstOut->astGymnasiumSkillInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GYMNASIUM_DATA(DT_GYMNASIUM_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SkillNum", (double)(data.bySkillNum));
	cJSON *GymnasiumSkillInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GymnasiumSkillInfo", GymnasiumSkillInfo);
	for( UINT32 dwIndex=0; dwIndex<data.bySkillNum; ++dwIndex)
	{
		cJSON_AddItemToObject(GymnasiumSkillInfo, " ", GetJsonDT_GYMNASIUM_SKILL_INFO(data.astGymnasiumSkillInfo[dwIndex]));
	}

	return root;
}

INT32 DT_GYMNASIUM_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(bySkillNum);
	memcpy(pDataBuff + dwOffset, &bySkillNum, sizeof(bySkillNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(bySkillNum > MAX_GYMNASIUM_SKILL_NUM)
	{
		bySkillNum = MAX_GYMNASIUM_SKILL_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = bySkillNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < bySkillNum; i++)
	{
		dwContextLenTmp += astGymnasiumSkillInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GYMNASIUM_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(bySkillNum) >= pstIndex->dwContextLen)
				{
					memcpy(&bySkillNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySkillNum, 0, sizeof(bySkillNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == bySkillNum)
				{
					wArrNum = wArrNum <= MAX_GYMNASIUM_SKILL_NUM ? wArrNum : MAX_GYMNASIUM_SKILL_NUM;
					bySkillNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astGymnasiumSkillInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astGymnasiumSkillInfo, 0, sizeof(astGymnasiumSkillInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astGymnasiumSkillInfo, 0, sizeof(astGymnasiumSkillInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HUNTING_INFO(void *pHost, CNetData* poNetData)
{
	DT_HUNTING_INFO *pstIn = (DT_HUNTING_INFO*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwHuntionNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHuntingChangeNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAbandomMonster))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurMonsterType))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGoldModeFlag))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwGoldModeTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastSyncIntegral))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsIgnorePrompt))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byMonsterNum))
		return -1;

	INT32 i;
	for(i = 0; i < MONSTER_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstIn->byMonsterNum)
			break;
		if(-1 == poNetData->AddWord(pstIn->awMonsterGroup[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HUNTING_INFO(void *pHost, CNetData* poNetData)
{
	DT_HUNTING_INFO *pstOut = (DT_HUNTING_INFO*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwHuntionNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHuntingChangeNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAbandomMonster))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurMonsterType))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGoldModeFlag))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwGoldModeTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastSyncIntegral))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsIgnorePrompt))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byMonsterNum))
		return -1;

	INT32 i;
	for(i = 0; i < MONSTER_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstOut->byMonsterNum)
			break;
		if(-1 == poNetData->DelWord(pstOut->awMonsterGroup[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HUNTING_INFO(DT_HUNTING_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HuntionNum", (double)(data.dwHuntionNum));
	cJSON_AddNumberToObject(root,"HuntingChangeNum", (double)(data.byHuntingChangeNum));
	cJSON_AddNumberToObject(root,"AbandomMonster", (double)(data.byAbandomMonster));
	cJSON_AddNumberToObject(root,"CurMonsterType", (double)(data.byCurMonsterType));
	cJSON_AddNumberToObject(root,"GoldModeFlag", (double)(data.byGoldModeFlag));
	cJSON_AddNumberToObject(root,"GoldModeTime", (double)(data.qwGoldModeTime));
	cJSON_AddNumberToObject(root,"LastSyncIntegral", (double)(data.qwLastSyncIntegral));
	cJSON_AddNumberToObject(root,"IsIgnorePrompt", (double)(data.byIsIgnorePrompt));
	cJSON_AddNumberToObject(root,"MonsterNum", (double)(data.byMonsterNum));
	cJSON *MonsterGroup = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "MonsterGroup", MonsterGroup);
	for( UINT32 dwIndex=0; dwIndex<data.byMonsterNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"MonsterGroup", (double)(data.awMonsterGroup[dwIndex]));
	}

	return root;
}

INT32 DT_HUNTING_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwHuntionNum);
	memcpy(pDataBuff + dwOffset, &dwHuntionNum, sizeof(dwHuntionNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byHuntingChangeNum);
	memcpy(pDataBuff + dwOffset, &byHuntingChangeNum, sizeof(byHuntingChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byAbandomMonster);
	memcpy(pDataBuff + dwOffset, &byAbandomMonster, sizeof(byAbandomMonster));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byCurMonsterType);
	memcpy(pDataBuff + dwOffset, &byCurMonsterType, sizeof(byCurMonsterType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byGoldModeFlag);
	memcpy(pDataBuff + dwOffset, &byGoldModeFlag, sizeof(byGoldModeFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(qwGoldModeTime);
	memcpy(pDataBuff + dwOffset, &qwGoldModeTime, sizeof(qwGoldModeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwLastSyncIntegral);
	memcpy(pDataBuff + dwOffset, &qwLastSyncIntegral, sizeof(qwLastSyncIntegral));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byIsIgnorePrompt);
	memcpy(pDataBuff + dwOffset, &byIsIgnorePrompt, sizeof(byIsIgnorePrompt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byMonsterNum);
	memcpy(pDataBuff + dwOffset, &byMonsterNum, sizeof(byMonsterNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	if(byMonsterNum > MONSTER_GROUP_NUM)
	{
		byMonsterNum = MONSTER_GROUP_NUM;
	}
	pstIndex->dwContextLen = byMonsterNum * sizeof(UINT16) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byMonsterNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awMonsterGroup, byMonsterNum * sizeof(UINT16));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HUNTING_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwHuntionNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHuntionNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHuntionNum, 0, sizeof(dwHuntionNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byHuntingChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHuntingChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHuntingChangeNum, 0, sizeof(byHuntingChangeNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byAbandomMonster) >= pstIndex->dwContextLen)
				{
					memcpy(&byAbandomMonster, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAbandomMonster, 0, sizeof(byAbandomMonster));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byCurMonsterType) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurMonsterType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurMonsterType, 0, sizeof(byCurMonsterType));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byGoldModeFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byGoldModeFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGoldModeFlag, 0, sizeof(byGoldModeFlag));
				}
			}
			break;
		case 6:
			{
				if(sizeof(qwGoldModeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwGoldModeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwGoldModeTime, 0, sizeof(qwGoldModeTime));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwLastSyncIntegral) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastSyncIntegral, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastSyncIntegral, 0, sizeof(qwLastSyncIntegral));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byIsIgnorePrompt) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsIgnorePrompt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsIgnorePrompt, 0, sizeof(byIsIgnorePrompt));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byMonsterNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byMonsterNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMonsterNum, 0, sizeof(byMonsterNum));
				}
			}
			break;
		case 10:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awMonsterGroup) >= dwContextLen) && (wArrNum == byMonsterNum) && (wArrNum <= MONSTER_GROUP_NUM))
				{
					memcpy(&awMonsterGroup, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awMonsterGroup, 0, sizeof(awMonsterGroup));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SHADE_DATA(void *pHost, CNetData* poNetData)
{
	DT_SHADE_DATA *pstIn = (DT_SHADE_DATA*)pHost;

	if(-1 == EncodeDT_HUNTING_INFO(&pstIn->stHuntingInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastUpdataTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SHADE_DATA(void *pHost, CNetData* poNetData)
{
	DT_SHADE_DATA *pstOut = (DT_SHADE_DATA*)pHost;

	if(-1 == DecodeDT_HUNTING_INFO(&pstOut->stHuntingInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastUpdataTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SHADE_DATA(DT_SHADE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "HuntingInfo", GetJsonDT_HUNTING_INFO(data.stHuntingInfo));
	cJSON_AddNumberToObject(root,"LastUpdataTime", (double)(data.qwLastUpdataTime));

	return root;
}

INT32 DT_SHADE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stHuntingInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLastUpdataTime);
	memcpy(pDataBuff + dwOffset, &qwLastUpdataTime, sizeof(qwLastUpdataTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SHADE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stHuntingInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				if(sizeof(qwLastUpdataTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastUpdataTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastUpdataTime, 0, sizeof(qwLastUpdataTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_HUNTING_SCHEDULE_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_HUNTING_SCHEDULE_DATA *pstIn = (DT_FACTION_HUNTING_SCHEDULE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byTaskID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byOpenHuntingFlag))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwMaxHuntingNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCollectiveTaskSchedule))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurCollectiveTaskSchedule))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCurIntegral))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwMaxIntegral))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastUpdateTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastChangeScheduleTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_HUNTING_SCHEDULE_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_HUNTING_SCHEDULE_DATA *pstOut = (DT_FACTION_HUNTING_SCHEDULE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byTaskID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byOpenHuntingFlag))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwMaxHuntingNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCollectiveTaskSchedule))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurCollectiveTaskSchedule))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCurIntegral))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwMaxIntegral))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastUpdateTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastChangeScheduleTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_HUNTING_SCHEDULE_DATA(DT_FACTION_HUNTING_SCHEDULE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"TaskID", (double)(data.byTaskID));
	cJSON_AddNumberToObject(root,"OpenHuntingFlag", (double)(data.byOpenHuntingFlag));
	cJSON_AddNumberToObject(root,"MaxHuntingNum", (double)(data.dwMaxHuntingNum));
	cJSON_AddNumberToObject(root,"CollectiveTaskSchedule", (double)(data.byCollectiveTaskSchedule));
	cJSON_AddNumberToObject(root,"CurCollectiveTaskSchedule", (double)(data.byCurCollectiveTaskSchedule));
	cJSON_AddNumberToObject(root,"CurIntegral", (double)(data.dwCurIntegral));
	cJSON_AddNumberToObject(root,"MaxIntegral", (double)(data.dwMaxIntegral));
	cJSON_AddNumberToObject(root,"LastUpdateTime", (double)(data.qwLastUpdateTime));
	cJSON_AddNumberToObject(root,"LastChangeScheduleTime", (double)(data.qwLastChangeScheduleTime));

	return root;
}

INT32 DT_FACTION_HUNTING_SCHEDULE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byTaskID);
	memcpy(pDataBuff + dwOffset, &byTaskID, sizeof(byTaskID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byOpenHuntingFlag);
	memcpy(pDataBuff + dwOffset, &byOpenHuntingFlag, sizeof(byOpenHuntingFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwMaxHuntingNum);
	memcpy(pDataBuff + dwOffset, &dwMaxHuntingNum, sizeof(dwMaxHuntingNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byCollectiveTaskSchedule);
	memcpy(pDataBuff + dwOffset, &byCollectiveTaskSchedule, sizeof(byCollectiveTaskSchedule));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byCurCollectiveTaskSchedule);
	memcpy(pDataBuff + dwOffset, &byCurCollectiveTaskSchedule, sizeof(byCurCollectiveTaskSchedule));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwCurIntegral);
	memcpy(pDataBuff + dwOffset, &dwCurIntegral, sizeof(dwCurIntegral));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwMaxIntegral);
	memcpy(pDataBuff + dwOffset, &dwMaxIntegral, sizeof(dwMaxIntegral));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(qwLastUpdateTime);
	memcpy(pDataBuff + dwOffset, &qwLastUpdateTime, sizeof(qwLastUpdateTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwLastChangeScheduleTime);
	memcpy(pDataBuff + dwOffset, &qwLastChangeScheduleTime, sizeof(qwLastChangeScheduleTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_HUNTING_SCHEDULE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byTaskID) >= pstIndex->dwContextLen)
				{
					memcpy(&byTaskID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTaskID, 0, sizeof(byTaskID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byOpenHuntingFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byOpenHuntingFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byOpenHuntingFlag, 0, sizeof(byOpenHuntingFlag));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwMaxHuntingNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwMaxHuntingNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwMaxHuntingNum, 0, sizeof(dwMaxHuntingNum));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byCollectiveTaskSchedule) >= pstIndex->dwContextLen)
				{
					memcpy(&byCollectiveTaskSchedule, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCollectiveTaskSchedule, 0, sizeof(byCollectiveTaskSchedule));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byCurCollectiveTaskSchedule) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurCollectiveTaskSchedule, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurCollectiveTaskSchedule, 0, sizeof(byCurCollectiveTaskSchedule));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwCurIntegral) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCurIntegral, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCurIntegral, 0, sizeof(dwCurIntegral));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwMaxIntegral) >= pstIndex->dwContextLen)
				{
					memcpy(&dwMaxIntegral, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwMaxIntegral, 0, sizeof(dwMaxIntegral));
				}
			}
			break;
		case 8:
			{
				if(sizeof(qwLastUpdateTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastUpdateTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastUpdateTime, 0, sizeof(qwLastUpdateTime));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwLastChangeScheduleTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastChangeScheduleTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastChangeScheduleTime, 0, sizeof(qwLastChangeScheduleTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HOT_SPRING_TIME_DATA(void *pHost, CNetData* poNetData)
{
	DT_HOT_SPRING_TIME_DATA *pstIn = (DT_HOT_SPRING_TIME_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byGiveWineOpenState))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwGiveWineOpenTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTodayOpenNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HOT_SPRING_TIME_DATA(void *pHost, CNetData* poNetData)
{
	DT_HOT_SPRING_TIME_DATA *pstOut = (DT_HOT_SPRING_TIME_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byGiveWineOpenState))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwGiveWineOpenTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTodayOpenNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HOT_SPRING_TIME_DATA(DT_HOT_SPRING_TIME_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GiveWineOpenState", (double)(data.byGiveWineOpenState));
	cJSON_AddNumberToObject(root,"GiveWineOpenTime", (double)(data.qwGiveWineOpenTime));
	cJSON_AddNumberToObject(root,"TodayOpenNum", (double)(data.byTodayOpenNum));

	return root;
}

INT32 DT_HOT_SPRING_TIME_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byGiveWineOpenState);
	memcpy(pDataBuff + dwOffset, &byGiveWineOpenState, sizeof(byGiveWineOpenState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwGiveWineOpenTime);
	memcpy(pDataBuff + dwOffset, &qwGiveWineOpenTime, sizeof(qwGiveWineOpenTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byTodayOpenNum);
	memcpy(pDataBuff + dwOffset, &byTodayOpenNum, sizeof(byTodayOpenNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HOT_SPRING_TIME_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byGiveWineOpenState) >= pstIndex->dwContextLen)
				{
					memcpy(&byGiveWineOpenState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGiveWineOpenState, 0, sizeof(byGiveWineOpenState));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwGiveWineOpenTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwGiveWineOpenTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwGiveWineOpenTime, 0, sizeof(qwGiveWineOpenTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byTodayOpenNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byTodayOpenNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTodayOpenNum, 0, sizeof(byTodayOpenNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SHADE_TASK_OPEN_MARK(void *pHost, CNetData* poNetData)
{
	DT_SHADE_TASK_OPEN_MARK *pstIn = (DT_SHADE_TASK_OPEN_MARK*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHuntingUnlockMark))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SHADE_TASK_OPEN_MARK(void *pHost, CNetData* poNetData)
{
	DT_SHADE_TASK_OPEN_MARK *pstOut = (DT_SHADE_TASK_OPEN_MARK*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHuntingUnlockMark))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SHADE_TASK_OPEN_MARK(DT_SHADE_TASK_OPEN_MARK &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HuntingUnlockMark", (double)(data.byHuntingUnlockMark));

	return root;
}

INT32 DT_SHADE_TASK_OPEN_MARK::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHuntingUnlockMark);
	memcpy(pDataBuff + dwOffset, &byHuntingUnlockMark, sizeof(byHuntingUnlockMark));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SHADE_TASK_OPEN_MARK::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHuntingUnlockMark) >= pstIndex->dwContextLen)
				{
					memcpy(&byHuntingUnlockMark, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHuntingUnlockMark, 0, sizeof(byHuntingUnlockMark));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_ICON_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_ICON_DATA *pstIn = (DT_FACTION_ICON_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byIcon))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byChangeNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwlastChangeTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_ICON_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_ICON_DATA *pstOut = (DT_FACTION_ICON_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byIcon))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byChangeNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwlastChangeTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_ICON_DATA(DT_FACTION_ICON_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Icon", (double)(data.byIcon));
	cJSON_AddNumberToObject(root,"ChangeNum", (double)(data.byChangeNum));
	cJSON_AddNumberToObject(root,"lastChangeTime", (double)(data.qwlastChangeTime));

	return root;
}

INT32 DT_FACTION_ICON_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byIcon);
	memcpy(pDataBuff + dwOffset, &byIcon, sizeof(byIcon));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byChangeNum);
	memcpy(pDataBuff + dwOffset, &byChangeNum, sizeof(byChangeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwlastChangeTime);
	memcpy(pDataBuff + dwOffset, &qwlastChangeTime, sizeof(qwlastChangeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_ICON_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byIcon) >= pstIndex->dwContextLen)
				{
					memcpy(&byIcon, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIcon, 0, sizeof(byIcon));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byChangeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byChangeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChangeNum, 0, sizeof(byChangeNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwlastChangeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwlastChangeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwlastChangeTime, 0, sizeof(qwlastChangeTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_COMMON_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_COMMON_DATA *pstIn = (DT_FACTION_COMMON_DATA*)pHost;

	if(-1 == EncodeDT_FACTION_HUNTING_SCHEDULE_DATA(&pstIn->stHuntingTaskSchedule, poNetData))
		return -1;

	if(-1 == EncodeDT_HOT_SPRING_TIME_DATA(&pstIn->stHotSpringData, poNetData))
		return -1;

	if(-1 == EncodeDT_FACTION_ICON_DATA(&pstIn->stIconData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_COMMON_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_COMMON_DATA *pstOut = (DT_FACTION_COMMON_DATA*)pHost;

	if(-1 == DecodeDT_FACTION_HUNTING_SCHEDULE_DATA(&pstOut->stHuntingTaskSchedule, poNetData))
		return -1;

	if(-1 == DecodeDT_HOT_SPRING_TIME_DATA(&pstOut->stHotSpringData, poNetData))
		return -1;

	if(-1 == DecodeDT_FACTION_ICON_DATA(&pstOut->stIconData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_COMMON_DATA(DT_FACTION_COMMON_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "HuntingTaskSchedule", GetJsonDT_FACTION_HUNTING_SCHEDULE_DATA(data.stHuntingTaskSchedule));
	cJSON_AddItemToObject(root, "HotSpringData", GetJsonDT_HOT_SPRING_TIME_DATA(data.stHotSpringData));
	cJSON_AddItemToObject(root, "IconData", GetJsonDT_FACTION_ICON_DATA(data.stIconData));

	return root;
}

INT32 DT_FACTION_COMMON_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stHuntingTaskSchedule.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stHotSpringData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stIconData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_COMMON_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stHuntingTaskSchedule.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stHotSpringData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stIconData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_WINE_DATA_CLI(void *pHost, CNetData* poNetData)
{
	DT_WINE_DATA_CLI *pstIn = (DT_WINE_DATA_CLI*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwWineID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCostType))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCostValue))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDrinkWineCD))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLeftDrinkNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byRewardID1))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRewardValue1))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byRewardID2))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRewardValue2))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNeedVIPLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEachRewardValue1))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEachRewardValue2))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwCountDown))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDrinkMaxTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_WINE_DATA_CLI(void *pHost, CNetData* poNetData)
{
	DT_WINE_DATA_CLI *pstOut = (DT_WINE_DATA_CLI*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwWineID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCostType))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCostValue))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDrinkWineCD))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLeftDrinkNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byRewardID1))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRewardValue1))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byRewardID2))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRewardValue2))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNeedVIPLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEachRewardValue1))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEachRewardValue2))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwCountDown))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDrinkMaxTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_WINE_DATA_CLI(DT_WINE_DATA_CLI &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"WineID", (double)(data.dwWineID));
	cJSON_AddNumberToObject(root,"CostType", (double)(data.byCostType));
	cJSON_AddNumberToObject(root,"CostValue", (double)(data.dwCostValue));
	cJSON_AddNumberToObject(root,"DrinkWineCD", (double)(data.dwDrinkWineCD));
	cJSON_AddNumberToObject(root,"LeftDrinkNum", (double)(data.byLeftDrinkNum));
	cJSON_AddNumberToObject(root,"RewardID1", (double)(data.byRewardID1));
	cJSON_AddNumberToObject(root,"RewardValue1", (double)(data.dwRewardValue1));
	cJSON_AddNumberToObject(root,"RewardID2", (double)(data.byRewardID2));
	cJSON_AddNumberToObject(root,"RewardValue2", (double)(data.dwRewardValue2));
	cJSON_AddNumberToObject(root,"NeedVIPLevel", (double)(data.byNeedVIPLevel));
	cJSON_AddNumberToObject(root,"EachRewardValue1", (double)(data.dwEachRewardValue1));
	cJSON_AddNumberToObject(root,"EachRewardValue2", (double)(data.dwEachRewardValue2));
	cJSON_AddNumberToObject(root,"CountDown", (double)(data.dwCountDown));
	cJSON_AddNumberToObject(root,"DrinkMaxTime", (double)(data.dwDrinkMaxTime));

	return root;
}

INT32 DT_WINE_DATA_CLI::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 14;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwWineID);
	memcpy(pDataBuff + dwOffset, &dwWineID, sizeof(dwWineID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCostType);
	memcpy(pDataBuff + dwOffset, &byCostType, sizeof(byCostType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwCostValue);
	memcpy(pDataBuff + dwOffset, &dwCostValue, sizeof(dwCostValue));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwDrinkWineCD);
	memcpy(pDataBuff + dwOffset, &dwDrinkWineCD, sizeof(dwDrinkWineCD));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byLeftDrinkNum);
	memcpy(pDataBuff + dwOffset, &byLeftDrinkNum, sizeof(byLeftDrinkNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byRewardID1);
	memcpy(pDataBuff + dwOffset, &byRewardID1, sizeof(byRewardID1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwRewardValue1);
	memcpy(pDataBuff + dwOffset, &dwRewardValue1, sizeof(dwRewardValue1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byRewardID2);
	memcpy(pDataBuff + dwOffset, &byRewardID2, sizeof(byRewardID2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwRewardValue2);
	memcpy(pDataBuff + dwOffset, &dwRewardValue2, sizeof(dwRewardValue2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byNeedVIPLevel);
	memcpy(pDataBuff + dwOffset, &byNeedVIPLevel, sizeof(byNeedVIPLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(dwEachRewardValue1);
	memcpy(pDataBuff + dwOffset, &dwEachRewardValue1, sizeof(dwEachRewardValue1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(dwEachRewardValue2);
	memcpy(pDataBuff + dwOffset, &dwEachRewardValue2, sizeof(dwEachRewardValue2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(dwCountDown);
	memcpy(pDataBuff + dwOffset, &dwCountDown, sizeof(dwCountDown));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(dwDrinkMaxTime);
	memcpy(pDataBuff + dwOffset, &dwDrinkMaxTime, sizeof(dwDrinkMaxTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_WINE_DATA_CLI::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwWineID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWineID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWineID, 0, sizeof(dwWineID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCostType) >= pstIndex->dwContextLen)
				{
					memcpy(&byCostType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCostType, 0, sizeof(byCostType));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwCostValue) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCostValue, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCostValue, 0, sizeof(dwCostValue));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwDrinkWineCD) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDrinkWineCD, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDrinkWineCD, 0, sizeof(dwDrinkWineCD));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byLeftDrinkNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byLeftDrinkNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLeftDrinkNum, 0, sizeof(byLeftDrinkNum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byRewardID1) >= pstIndex->dwContextLen)
				{
					memcpy(&byRewardID1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRewardID1, 0, sizeof(byRewardID1));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwRewardValue1) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRewardValue1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRewardValue1, 0, sizeof(dwRewardValue1));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byRewardID2) >= pstIndex->dwContextLen)
				{
					memcpy(&byRewardID2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRewardID2, 0, sizeof(byRewardID2));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwRewardValue2) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRewardValue2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRewardValue2, 0, sizeof(dwRewardValue2));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byNeedVIPLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byNeedVIPLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNeedVIPLevel, 0, sizeof(byNeedVIPLevel));
				}
			}
			break;
		case 11:
			{
				if(sizeof(dwEachRewardValue1) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEachRewardValue1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEachRewardValue1, 0, sizeof(dwEachRewardValue1));
				}
			}
			break;
		case 12:
			{
				if(sizeof(dwEachRewardValue2) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEachRewardValue2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEachRewardValue2, 0, sizeof(dwEachRewardValue2));
				}
			}
			break;
		case 13:
			{
				if(sizeof(dwCountDown) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCountDown, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCountDown, 0, sizeof(dwCountDown));
				}
			}
			break;
		case 14:
			{
				if(sizeof(dwDrinkMaxTime) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDrinkMaxTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDrinkMaxTime, 0, sizeof(dwDrinkMaxTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_POS_INFO(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_POS_INFO *pstIn = (DT_PLAYER_POS_INFO*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPosX))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPosY))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byMoveState))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSyncTimeLast))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_POS_INFO(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_POS_INFO *pstOut = (DT_PLAYER_POS_INFO*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPosX))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPosY))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byMoveState))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSyncTimeLast))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_POS_INFO(DT_PLAYER_POS_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PosX", (double)(data.wPosX));
	cJSON_AddNumberToObject(root,"PosY", (double)(data.wPosY));
	cJSON_AddNumberToObject(root,"MoveState", (double)(data.byMoveState));
	cJSON_AddNumberToObject(root,"SyncTimeLast", (double)(data.qwSyncTimeLast));

	return root;
}

INT32 DT_PLAYER_POS_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPosX);
	memcpy(pDataBuff + dwOffset, &wPosX, sizeof(wPosX));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wPosY);
	memcpy(pDataBuff + dwOffset, &wPosY, sizeof(wPosY));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byMoveState);
	memcpy(pDataBuff + dwOffset, &byMoveState, sizeof(byMoveState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwSyncTimeLast);
	memcpy(pDataBuff + dwOffset, &qwSyncTimeLast, sizeof(qwSyncTimeLast));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_POS_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPosX) >= pstIndex->dwContextLen)
				{
					memcpy(&wPosX, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPosX, 0, sizeof(wPosX));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wPosY) >= pstIndex->dwContextLen)
				{
					memcpy(&wPosY, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPosY, 0, sizeof(wPosY));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byMoveState) >= pstIndex->dwContextLen)
				{
					memcpy(&byMoveState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMoveState, 0, sizeof(byMoveState));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwSyncTimeLast) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSyncTimeLast, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSyncTimeLast, 0, sizeof(qwSyncTimeLast));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_OVER_GIVE_WINE_REWARD(void *pHost, CNetData* poNetData)
{
	DT_OVER_GIVE_WINE_REWARD *pstIn = (DT_OVER_GIVE_WINE_REWARD*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byRewardID1))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRewardValue1))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byRewardID2))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRewardValue2))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_OVER_GIVE_WINE_REWARD(void *pHost, CNetData* poNetData)
{
	DT_OVER_GIVE_WINE_REWARD *pstOut = (DT_OVER_GIVE_WINE_REWARD*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byRewardID1))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRewardValue1))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byRewardID2))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRewardValue2))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_OVER_GIVE_WINE_REWARD(DT_OVER_GIVE_WINE_REWARD &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RewardID1", (double)(data.byRewardID1));
	cJSON_AddNumberToObject(root,"RewardValue1", (double)(data.dwRewardValue1));
	cJSON_AddNumberToObject(root,"RewardID2", (double)(data.byRewardID2));
	cJSON_AddNumberToObject(root,"RewardValue2", (double)(data.dwRewardValue2));

	return root;
}

INT32 DT_OVER_GIVE_WINE_REWARD::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byRewardID1);
	memcpy(pDataBuff + dwOffset, &byRewardID1, sizeof(byRewardID1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwRewardValue1);
	memcpy(pDataBuff + dwOffset, &dwRewardValue1, sizeof(dwRewardValue1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byRewardID2);
	memcpy(pDataBuff + dwOffset, &byRewardID2, sizeof(byRewardID2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwRewardValue2);
	memcpy(pDataBuff + dwOffset, &dwRewardValue2, sizeof(dwRewardValue2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_OVER_GIVE_WINE_REWARD::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byRewardID1) >= pstIndex->dwContextLen)
				{
					memcpy(&byRewardID1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRewardID1, 0, sizeof(byRewardID1));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwRewardValue1) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRewardValue1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRewardValue1, 0, sizeof(dwRewardValue1));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byRewardID2) >= pstIndex->dwContextLen)
				{
					memcpy(&byRewardID2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRewardID2, 0, sizeof(byRewardID2));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwRewardValue2) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRewardValue2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRewardValue2, 0, sizeof(dwRewardValue2));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HOT_SPRING_DATA(void *pHost, CNetData* poNetData)
{
	DT_HOT_SPRING_DATA *pstIn = (DT_HOT_SPRING_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLastDrinkWineState))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDrinkWineState))
		return -1;

	if(-1 == EncodeDT_WINE_DATA_CLI(&pstIn->stWineInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_POS_INFO(&pstIn->stPlayerPosInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwFirstDrinkTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDrinkKeepTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsJoinCurActivity))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTodayBackTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwUpgradeTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivityStat))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveOverReward))
		return -1;

	if(-1 == EncodeDT_OVER_GIVE_WINE_REWARD(&pstIn->stOverReward, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsIgnorePrompt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HOT_SPRING_DATA(void *pHost, CNetData* poNetData)
{
	DT_HOT_SPRING_DATA *pstOut = (DT_HOT_SPRING_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLastDrinkWineState))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDrinkWineState))
		return -1;

	if(-1 == DecodeDT_WINE_DATA_CLI(&pstOut->stWineInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_POS_INFO(&pstOut->stPlayerPosInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwFirstDrinkTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDrinkKeepTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsJoinCurActivity))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTodayBackTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwUpgradeTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivityStat))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveOverReward))
		return -1;

	if(-1 == DecodeDT_OVER_GIVE_WINE_REWARD(&pstOut->stOverReward, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsIgnorePrompt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HOT_SPRING_DATA(DT_HOT_SPRING_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastDrinkWineState", (double)(data.byLastDrinkWineState));
	cJSON_AddNumberToObject(root,"DrinkWineState", (double)(data.byDrinkWineState));
	cJSON_AddItemToObject(root, "WineInfo", GetJsonDT_WINE_DATA_CLI(data.stWineInfo));
	cJSON_AddItemToObject(root, "PlayerPosInfo", GetJsonDT_PLAYER_POS_INFO(data.stPlayerPosInfo));
	cJSON_AddNumberToObject(root,"FirstDrinkTime", (double)(data.qwFirstDrinkTime));
	cJSON_AddNumberToObject(root,"DrinkKeepTime", (double)(data.dwDrinkKeepTime));
	cJSON_AddNumberToObject(root,"IsJoinCurActivity", (double)(data.byIsJoinCurActivity));
	cJSON_AddNumberToObject(root,"TodayBackTime", (double)(data.byTodayBackTime));
	cJSON_AddNumberToObject(root,"UpgradeTime", (double)(data.qwUpgradeTime));
	cJSON_AddNumberToObject(root,"ActivityStat", (double)(data.byActivityStat));
	cJSON_AddNumberToObject(root,"HaveOverReward", (double)(data.byHaveOverReward));
	cJSON_AddItemToObject(root, "OverReward", GetJsonDT_OVER_GIVE_WINE_REWARD(data.stOverReward));
	cJSON_AddNumberToObject(root,"IsIgnorePrompt", (double)(data.byIsIgnorePrompt));

	return root;
}

INT32 DT_HOT_SPRING_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 13;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLastDrinkWineState);
	memcpy(pDataBuff + dwOffset, &byLastDrinkWineState, sizeof(byLastDrinkWineState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byDrinkWineState);
	memcpy(pDataBuff + dwOffset, &byDrinkWineState, sizeof(byDrinkWineState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stWineInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stPlayerPosInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwFirstDrinkTime);
	memcpy(pDataBuff + dwOffset, &qwFirstDrinkTime, sizeof(qwFirstDrinkTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwDrinkKeepTime);
	memcpy(pDataBuff + dwOffset, &dwDrinkKeepTime, sizeof(dwDrinkKeepTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byIsJoinCurActivity);
	memcpy(pDataBuff + dwOffset, &byIsJoinCurActivity, sizeof(byIsJoinCurActivity));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byTodayBackTime);
	memcpy(pDataBuff + dwOffset, &byTodayBackTime, sizeof(byTodayBackTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwUpgradeTime);
	memcpy(pDataBuff + dwOffset, &qwUpgradeTime, sizeof(qwUpgradeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byActivityStat);
	memcpy(pDataBuff + dwOffset, &byActivityStat, sizeof(byActivityStat));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byHaveOverReward);
	memcpy(pDataBuff + dwOffset, &byHaveOverReward, sizeof(byHaveOverReward));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = stOverReward.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(byIsIgnorePrompt);
	memcpy(pDataBuff + dwOffset, &byIsIgnorePrompt, sizeof(byIsIgnorePrompt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HOT_SPRING_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLastDrinkWineState) >= pstIndex->dwContextLen)
				{
					memcpy(&byLastDrinkWineState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLastDrinkWineState, 0, sizeof(byLastDrinkWineState));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byDrinkWineState) >= pstIndex->dwContextLen)
				{
					memcpy(&byDrinkWineState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDrinkWineState, 0, sizeof(byDrinkWineState));
				}
			}
			break;
		case 3:
			{
				stWineInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stPlayerPosInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				if(sizeof(qwFirstDrinkTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwFirstDrinkTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwFirstDrinkTime, 0, sizeof(qwFirstDrinkTime));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwDrinkKeepTime) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDrinkKeepTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDrinkKeepTime, 0, sizeof(dwDrinkKeepTime));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byIsJoinCurActivity) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsJoinCurActivity, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsJoinCurActivity, 0, sizeof(byIsJoinCurActivity));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byTodayBackTime) >= pstIndex->dwContextLen)
				{
					memcpy(&byTodayBackTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTodayBackTime, 0, sizeof(byTodayBackTime));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwUpgradeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwUpgradeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwUpgradeTime, 0, sizeof(qwUpgradeTime));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byActivityStat) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivityStat, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivityStat, 0, sizeof(byActivityStat));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byHaveOverReward) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveOverReward, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveOverReward, 0, sizeof(byHaveOverReward));
				}
			}
			break;
		case 12:
			{
				stOverReward.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 13:
			{
				if(sizeof(byIsIgnorePrompt) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsIgnorePrompt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsIgnorePrompt, 0, sizeof(byIsIgnorePrompt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LEAVE_FACTION_MARK(void *pHost, CNetData* poNetData)
{
	DT_LEAVE_FACTION_MARK *pstIn = (DT_LEAVE_FACTION_MARK*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLeaveMark))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLeaveTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LEAVE_FACTION_MARK(void *pHost, CNetData* poNetData)
{
	DT_LEAVE_FACTION_MARK *pstOut = (DT_LEAVE_FACTION_MARK*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLeaveMark))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLeaveTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LEAVE_FACTION_MARK(DT_LEAVE_FACTION_MARK &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LeaveMark", (double)(data.byLeaveMark));
	cJSON_AddNumberToObject(root,"LeaveTime", (double)(data.qwLeaveTime));

	return root;
}

INT32 DT_LEAVE_FACTION_MARK::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLeaveMark);
	memcpy(pDataBuff + dwOffset, &byLeaveMark, sizeof(byLeaveMark));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLeaveTime);
	memcpy(pDataBuff + dwOffset, &qwLeaveTime, sizeof(qwLeaveTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LEAVE_FACTION_MARK::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLeaveMark) >= pstIndex->dwContextLen)
				{
					memcpy(&byLeaveMark, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLeaveMark, 0, sizeof(byLeaveMark));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLeaveTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLeaveTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLeaveTime, 0, sizeof(qwLeaveTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_DONATE_INFO(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_DONATE_INFO *pstIn = (DT_PLAYER_DONATE_INFO*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastCoinDoorsTributeTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wTodaysCoinDoorsTributeTimes))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTodaysCoinDoorsTributeEncourage))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastGoldDoorsTributeTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wTodaysGoldDoorsTributeTimes))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_DONATE_INFO(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_DONATE_INFO *pstOut = (DT_PLAYER_DONATE_INFO*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastCoinDoorsTributeTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wTodaysCoinDoorsTributeTimes))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTodaysCoinDoorsTributeEncourage))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastGoldDoorsTributeTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wTodaysGoldDoorsTributeTimes))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_DONATE_INFO(DT_PLAYER_DONATE_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastCoinDoorsTributeTime", (double)(data.qwLastCoinDoorsTributeTime));
	cJSON_AddNumberToObject(root,"TodaysCoinDoorsTributeTimes", (double)(data.wTodaysCoinDoorsTributeTimes));
	cJSON_AddNumberToObject(root,"TodaysCoinDoorsTributeEncourage", (double)(data.byTodaysCoinDoorsTributeEncourage));
	cJSON_AddNumberToObject(root,"LastGoldDoorsTributeTime", (double)(data.qwLastGoldDoorsTributeTime));
	cJSON_AddNumberToObject(root,"TodaysGoldDoorsTributeTimes", (double)(data.wTodaysGoldDoorsTributeTimes));

	return root;
}

INT32 DT_PLAYER_DONATE_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastCoinDoorsTributeTime);
	memcpy(pDataBuff + dwOffset, &qwLastCoinDoorsTributeTime, sizeof(qwLastCoinDoorsTributeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wTodaysCoinDoorsTributeTimes);
	memcpy(pDataBuff + dwOffset, &wTodaysCoinDoorsTributeTimes, sizeof(wTodaysCoinDoorsTributeTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byTodaysCoinDoorsTributeEncourage);
	memcpy(pDataBuff + dwOffset, &byTodaysCoinDoorsTributeEncourage, sizeof(byTodaysCoinDoorsTributeEncourage));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwLastGoldDoorsTributeTime);
	memcpy(pDataBuff + dwOffset, &qwLastGoldDoorsTributeTime, sizeof(qwLastGoldDoorsTributeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wTodaysGoldDoorsTributeTimes);
	memcpy(pDataBuff + dwOffset, &wTodaysGoldDoorsTributeTimes, sizeof(wTodaysGoldDoorsTributeTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_DONATE_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastCoinDoorsTributeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastCoinDoorsTributeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastCoinDoorsTributeTime, 0, sizeof(qwLastCoinDoorsTributeTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wTodaysCoinDoorsTributeTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&wTodaysCoinDoorsTributeTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wTodaysCoinDoorsTributeTimes, 0, sizeof(wTodaysCoinDoorsTributeTimes));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byTodaysCoinDoorsTributeEncourage) >= pstIndex->dwContextLen)
				{
					memcpy(&byTodaysCoinDoorsTributeEncourage, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTodaysCoinDoorsTributeEncourage, 0, sizeof(byTodaysCoinDoorsTributeEncourage));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwLastGoldDoorsTributeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastGoldDoorsTributeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastGoldDoorsTributeTime, 0, sizeof(qwLastGoldDoorsTributeTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wTodaysGoldDoorsTributeTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&wTodaysGoldDoorsTributeTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wTodaysGoldDoorsTributeTimes, 0, sizeof(wTodaysGoldDoorsTributeTimes));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_MARK_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_MARK_DATA *pstIn = (DT_PLAYER_MARK_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFactionPlayerMark))
		return -1;

	if(-1 == EncodeDT_LEAVE_FACTION_MARK(&pstIn->stLeaveFactionMark, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_MARK_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_MARK_DATA *pstOut = (DT_PLAYER_MARK_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFactionPlayerMark))
		return -1;

	if(-1 == DecodeDT_LEAVE_FACTION_MARK(&pstOut->stLeaveFactionMark, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_MARK_DATA(DT_PLAYER_MARK_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionPlayerMark", (double)(data.byFactionPlayerMark));
	cJSON_AddItemToObject(root, "LeaveFactionMark", GetJsonDT_LEAVE_FACTION_MARK(data.stLeaveFactionMark));

	return root;
}

INT32 DT_PLAYER_MARK_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFactionPlayerMark);
	memcpy(pDataBuff + dwOffset, &byFactionPlayerMark, sizeof(byFactionPlayerMark));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stLeaveFactionMark.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_MARK_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFactionPlayerMark) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionPlayerMark, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionPlayerMark, 0, sizeof(byFactionPlayerMark));
				}
			}
			break;
		case 2:
			{
				stLeaveFactionMark.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_FACTION_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_FACTION_BATTLELOG_DATA *pstIn = (DT_PLAYER_FACTION_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFactionLogType))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLogTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNewFlag))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszDescMsg, sizeof(pstIn->aszDescMsg)))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byParamNum))
		return -1;

	INT32 i;
	for(i = 0; i < FACTION_LOG_LIST_MAX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byParamNum)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyparamList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_FACTION_BATTLELOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_FACTION_BATTLELOG_DATA *pstOut = (DT_PLAYER_FACTION_BATTLELOG_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFactionLogType))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLogTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNewFlag))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszDescMsg, sizeof(pstOut->aszDescMsg)))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byParamNum))
		return -1;

	INT32 i;
	for(i = 0; i < FACTION_LOG_LIST_MAX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byParamNum)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyparamList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_FACTION_BATTLELOG_DATA(DT_PLAYER_FACTION_BATTLELOG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionLogType", (double)(data.byFactionLogType));
	cJSON_AddNumberToObject(root,"LogTime", (double)(data.qwLogTime));
	cJSON_AddNumberToObject(root,"NewFlag", (double)(data.byNewFlag));
	cJSON_AddStringToObject(root,"DescMsg", data.aszDescMsg );
	cJSON_AddNumberToObject(root,"ParamNum", (double)(data.byParamNum));
	cJSON *paramList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "paramList", paramList);
	for( UINT32 dwIndex=0; dwIndex<data.byParamNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"paramList", (double)(data.abyparamList[dwIndex]));
	}

	return root;
}

INT32 DT_PLAYER_FACTION_BATTLELOG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFactionLogType);
	memcpy(pDataBuff + dwOffset, &byFactionLogType, sizeof(byFactionLogType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLogTime);
	memcpy(pDataBuff + dwOffset, &qwLogTime, sizeof(qwLogTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byNewFlag);
	memcpy(pDataBuff + dwOffset, &byNewFlag, sizeof(byNewFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszDescMsg) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = NORMAL_MSG_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDescMsg, sizeof(aszDescMsg));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byParamNum);
	memcpy(pDataBuff + dwOffset, &byParamNum, sizeof(byParamNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	if(byParamNum > FACTION_LOG_LIST_MAX_NUM)
	{
		byParamNum = FACTION_LOG_LIST_MAX_NUM;
	}
	pstIndex->dwContextLen = byParamNum * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byParamNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyparamList, byParamNum * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_FACTION_BATTLELOG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFactionLogType) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionLogType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionLogType, 0, sizeof(byFactionLogType));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLogTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLogTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLogTime, 0, sizeof(qwLogTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byNewFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byNewFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNewFlag, 0, sizeof(byNewFlag));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDescMsg) >= dwContextLen) && (wArrNum <= NORMAL_MSG_LEN))
				{
					memcpy(&aszDescMsg, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDescMsg, 0, sizeof(aszDescMsg));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byParamNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byParamNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byParamNum, 0, sizeof(byParamNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyparamList) >= dwContextLen) && (wArrNum == byParamNum) && (wArrNum <= FACTION_LOG_LIST_MAX_NUM))
				{
					memcpy(&abyparamList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyparamList, 0, sizeof(abyparamList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_FACTION_BATTLELOG_DATA_LIST *pstIn = (DT_PLAYER_FACTION_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_BATTLE_LOG_NUM; i++)
	{
		if(i >= (INT32)pstIn->byLogNum)
			break;
		if(-1 == EncodeDT_PLAYER_FACTION_BATTLELOG_DATA(&pstIn->astPlayerFactionLog[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_FACTION_BATTLELOG_DATA_LIST *pstOut = (DT_PLAYER_FACTION_BATTLELOG_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_BATTLE_LOG_NUM; i++)
	{
		if(i >= (INT32)pstOut->byLogNum)
			break;
		if(-1 == DecodeDT_PLAYER_FACTION_BATTLELOG_DATA(&pstOut->astPlayerFactionLog[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(DT_PLAYER_FACTION_BATTLELOG_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LogNum", (double)(data.byLogNum));
	cJSON *PlayerFactionLog = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PlayerFactionLog", PlayerFactionLog);
	for( UINT32 dwIndex=0; dwIndex<data.byLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(PlayerFactionLog, " ", GetJsonDT_PLAYER_FACTION_BATTLELOG_DATA(data.astPlayerFactionLog[dwIndex]));
	}

	return root;
}

INT32 DT_PLAYER_FACTION_BATTLELOG_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLogNum);
	memcpy(pDataBuff + dwOffset, &byLogNum, sizeof(byLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byLogNum > MAX_FACTION_BATTLE_LOG_NUM)
	{
		byLogNum = MAX_FACTION_BATTLE_LOG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byLogNum; i++)
	{
		dwContextLenTmp += astPlayerFactionLog[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_FACTION_BATTLELOG_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLogNum, 0, sizeof(byLogNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byLogNum)
				{
					wArrNum = wArrNum <= MAX_FACTION_BATTLE_LOG_NUM ? wArrNum : MAX_FACTION_BATTLE_LOG_NUM;
					byLogNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPlayerFactionLog[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPlayerFactionLog, 0, sizeof(astPlayerFactionLog));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPlayerFactionLog, 0, sizeof(astPlayerFactionLog));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HOT_SPRING_EXT_DATA(void *pHost, CNetData* poNetData)
{
	DT_HOT_SPRING_EXT_DATA *pstIn = (DT_HOT_SPRING_EXT_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastEnterTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwExprienceTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDrinkTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFindBackTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byEnterHotSpringType))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HOT_SPRING_EXT_DATA(void *pHost, CNetData* poNetData)
{
	DT_HOT_SPRING_EXT_DATA *pstOut = (DT_HOT_SPRING_EXT_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastEnterTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwExprienceTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDrinkTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFindBackTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byEnterHotSpringType))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HOT_SPRING_EXT_DATA(DT_HOT_SPRING_EXT_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastEnterTime", (double)(data.qwLastEnterTime));
	cJSON_AddNumberToObject(root,"ExprienceTime", (double)(data.qwExprienceTime));
	cJSON_AddNumberToObject(root,"DrinkTime", (double)(data.byDrinkTime));
	cJSON_AddNumberToObject(root,"FindBackTime", (double)(data.byFindBackTime));
	cJSON_AddNumberToObject(root,"EnterHotSpringType", (double)(data.byEnterHotSpringType));

	return root;
}

INT32 DT_HOT_SPRING_EXT_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastEnterTime);
	memcpy(pDataBuff + dwOffset, &qwLastEnterTime, sizeof(qwLastEnterTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwExprienceTime);
	memcpy(pDataBuff + dwOffset, &qwExprienceTime, sizeof(qwExprienceTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byDrinkTime);
	memcpy(pDataBuff + dwOffset, &byDrinkTime, sizeof(byDrinkTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byFindBackTime);
	memcpy(pDataBuff + dwOffset, &byFindBackTime, sizeof(byFindBackTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byEnterHotSpringType);
	memcpy(pDataBuff + dwOffset, &byEnterHotSpringType, sizeof(byEnterHotSpringType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HOT_SPRING_EXT_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastEnterTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastEnterTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastEnterTime, 0, sizeof(qwLastEnterTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwExprienceTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwExprienceTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwExprienceTime, 0, sizeof(qwExprienceTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byDrinkTime) >= pstIndex->dwContextLen)
				{
					memcpy(&byDrinkTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDrinkTime, 0, sizeof(byDrinkTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byFindBackTime) >= pstIndex->dwContextLen)
				{
					memcpy(&byFindBackTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFindBackTime, 0, sizeof(byFindBackTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byEnterHotSpringType) >= pstIndex->dwContextLen)
				{
					memcpy(&byEnterHotSpringType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEnterHotSpringType, 0, sizeof(byEnterHotSpringType));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_FACTION_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_FACTION_DATA *pstIn = (DT_PLAYER_FACTION_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == EncodeDT_RAREITEM_GOODS_DATA(&pstIn->stRareItemGoodsData, poNetData))
		return -1;

	if(-1 == EncodeDT_GYMNASIUM_DATA(&pstIn->stGymnasiumSkillData, poNetData))
		return -1;

	if(-1 == EncodeDT_SHADE_DATA(&pstIn->stShadeData, poNetData))
		return -1;

	if(-1 == EncodeDT_HOT_SPRING_DATA(&pstIn->stHotSpringData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(&pstIn->stPlayerFactionLog, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_MARK_DATA(&pstIn->stPlayerMark, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_DONATE_INFO(&pstIn->stPlayerDoNate, poNetData))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFindBackDoorsTribute))
		return -1;

	if(-1 == EncodeDT_HOT_SPRING_EXT_DATA(&pstIn->stHotSpringExt, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_FACTION_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_FACTION_DATA *pstOut = (DT_PLAYER_FACTION_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == DecodeDT_RAREITEM_GOODS_DATA(&pstOut->stRareItemGoodsData, poNetData))
		return -1;

	if(-1 == DecodeDT_GYMNASIUM_DATA(&pstOut->stGymnasiumSkillData, poNetData))
		return -1;

	if(-1 == DecodeDT_SHADE_DATA(&pstOut->stShadeData, poNetData))
		return -1;

	if(-1 == DecodeDT_HOT_SPRING_DATA(&pstOut->stHotSpringData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(&pstOut->stPlayerFactionLog, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_MARK_DATA(&pstOut->stPlayerMark, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_DONATE_INFO(&pstOut->stPlayerDoNate, poNetData))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFindBackDoorsTribute))
		return -1;

	if(-1 == DecodeDT_HOT_SPRING_EXT_DATA(&pstOut->stHotSpringExt, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_FACTION_DATA(DT_PLAYER_FACTION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddItemToObject(root, "RareItemGoodsData", GetJsonDT_RAREITEM_GOODS_DATA(data.stRareItemGoodsData));
	cJSON_AddItemToObject(root, "GymnasiumSkillData", GetJsonDT_GYMNASIUM_DATA(data.stGymnasiumSkillData));
	cJSON_AddItemToObject(root, "ShadeData", GetJsonDT_SHADE_DATA(data.stShadeData));
	cJSON_AddItemToObject(root, "HotSpringData", GetJsonDT_HOT_SPRING_DATA(data.stHotSpringData));
	cJSON_AddItemToObject(root, "PlayerFactionLog", GetJsonDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(data.stPlayerFactionLog));
	cJSON_AddItemToObject(root, "PlayerMark", GetJsonDT_PLAYER_MARK_DATA(data.stPlayerMark));
	cJSON_AddItemToObject(root, "PlayerDoNate", GetJsonDT_PLAYER_DONATE_INFO(data.stPlayerDoNate));
	cJSON_AddNumberToObject(root,"FindBackDoorsTribute", (double)(data.dwFindBackDoorsTribute));
	cJSON_AddItemToObject(root, "HotSpringExt", GetJsonDT_HOT_SPRING_EXT_DATA(data.stHotSpringExt));

	return root;
}

INT32 DT_PLAYER_FACTION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stRareItemGoodsData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stGymnasiumSkillData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stShadeData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stHotSpringData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stPlayerFactionLog.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stPlayerMark.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stPlayerDoNate.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwFindBackDoorsTribute);
	memcpy(pDataBuff + dwOffset, &dwFindBackDoorsTribute, sizeof(dwFindBackDoorsTribute));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = stHotSpringExt.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_FACTION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				stRareItemGoodsData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stGymnasiumSkillData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stShadeData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stHotSpringData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stPlayerFactionLog.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				stPlayerMark.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stPlayerDoNate.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				if(sizeof(dwFindBackDoorsTribute) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFindBackDoorsTribute, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFindBackDoorsTribute, 0, sizeof(dwFindBackDoorsTribute));
				}
			}
			break;
		case 10:
			{
				stHotSpringExt.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_TODAY_CONSUME_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_TODAY_CONSUME_DATA *pstIn = (DT_PLAYER_TODAY_CONSUME_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwUTCLastConsumeTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddExperience))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterExperience))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAddLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAfterLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAddVipLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAfterVipLevel))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddCoin))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecCoin))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterCoin))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddGold))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecGold))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterGold))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddStory))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecStory))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterStory))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAddPhyStrength))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wDecPhyStrength))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAfterPhyStrength))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddScience))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecScience))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterScience))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddBlueGas))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecBlueGas))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterBlueGas))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddPurpleGas))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecPurpleGas))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterPurpleGas))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddJingJie))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecJingJie))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterJingJie))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddStudyExp))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecStudyExp))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterStudyExp))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddMedal))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecMedal))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterMedal))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAddAmount))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAfterAmount))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddTotalRMB))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterTotalRMB))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszLastConsumeTime, sizeof(pstIn->aszLastConsumeTime)))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddDoorsTribute))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDecDoorsTribute))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAfterDoorsTribute))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddRedStudyNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddTaijiStudyNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwBuyPhyStrengthNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_TODAY_CONSUME_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_TODAY_CONSUME_DATA *pstOut = (DT_PLAYER_TODAY_CONSUME_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwUTCLastConsumeTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddExperience))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterExperience))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAddLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAfterLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAddVipLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAfterVipLevel))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddCoin))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecCoin))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterCoin))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddGold))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecGold))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterGold))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddStory))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecStory))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterStory))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAddPhyStrength))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wDecPhyStrength))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAfterPhyStrength))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddScience))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecScience))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterScience))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddBlueGas))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecBlueGas))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterBlueGas))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddPurpleGas))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecPurpleGas))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterPurpleGas))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddJingJie))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecJingJie))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterJingJie))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddStudyExp))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecStudyExp))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterStudyExp))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddMedal))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecMedal))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterMedal))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAddAmount))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAfterAmount))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddTotalRMB))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterTotalRMB))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszLastConsumeTime, sizeof(pstOut->aszLastConsumeTime)))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddDoorsTribute))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDecDoorsTribute))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAfterDoorsTribute))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddRedStudyNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddTaijiStudyNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwBuyPhyStrengthNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_TODAY_CONSUME_DATA(DT_PLAYER_TODAY_CONSUME_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ID", (double)(data.dwID));
	cJSON_AddNumberToObject(root,"UTCLastConsumeTime", (double)(data.qwUTCLastConsumeTime));
	cJSON_AddNumberToObject(root,"AddExperience", (double)(data.qwAddExperience));
	cJSON_AddNumberToObject(root,"AfterExperience", (double)(data.qwAfterExperience));
	cJSON_AddNumberToObject(root,"AddLevel", (double)(data.wAddLevel));
	cJSON_AddNumberToObject(root,"AfterLevel", (double)(data.wAfterLevel));
	cJSON_AddNumberToObject(root,"AddVipLevel", (double)(data.byAddVipLevel));
	cJSON_AddNumberToObject(root,"AfterVipLevel", (double)(data.byAfterVipLevel));
	cJSON_AddNumberToObject(root,"AddCoin", (double)(data.qwAddCoin));
	cJSON_AddNumberToObject(root,"DecCoin", (double)(data.qwDecCoin));
	cJSON_AddNumberToObject(root,"AfterCoin", (double)(data.qwAfterCoin));
	cJSON_AddNumberToObject(root,"AddGold", (double)(data.qwAddGold));
	cJSON_AddNumberToObject(root,"DecGold", (double)(data.qwDecGold));
	cJSON_AddNumberToObject(root,"AfterGold", (double)(data.qwAfterGold));
	cJSON_AddNumberToObject(root,"AddStory", (double)(data.qwAddStory));
	cJSON_AddNumberToObject(root,"DecStory", (double)(data.qwDecStory));
	cJSON_AddNumberToObject(root,"AfterStory", (double)(data.qwAfterStory));
	cJSON_AddNumberToObject(root,"AddPhyStrength", (double)(data.wAddPhyStrength));
	cJSON_AddNumberToObject(root,"DecPhyStrength", (double)(data.wDecPhyStrength));
	cJSON_AddNumberToObject(root,"AfterPhyStrength", (double)(data.wAfterPhyStrength));
	cJSON_AddNumberToObject(root,"AddScience", (double)(data.qwAddScience));
	cJSON_AddNumberToObject(root,"DecScience", (double)(data.qwDecScience));
	cJSON_AddNumberToObject(root,"AfterScience", (double)(data.qwAfterScience));
	cJSON_AddNumberToObject(root,"AddBlueGas", (double)(data.qwAddBlueGas));
	cJSON_AddNumberToObject(root,"DecBlueGas", (double)(data.qwDecBlueGas));
	cJSON_AddNumberToObject(root,"AfterBlueGas", (double)(data.qwAfterBlueGas));
	cJSON_AddNumberToObject(root,"AddPurpleGas", (double)(data.qwAddPurpleGas));
	cJSON_AddNumberToObject(root,"DecPurpleGas", (double)(data.qwDecPurpleGas));
	cJSON_AddNumberToObject(root,"AfterPurpleGas", (double)(data.qwAfterPurpleGas));
	cJSON_AddNumberToObject(root,"AddJingJie", (double)(data.qwAddJingJie));
	cJSON_AddNumberToObject(root,"DecJingJie", (double)(data.qwDecJingJie));
	cJSON_AddNumberToObject(root,"AfterJingJie", (double)(data.qwAfterJingJie));
	cJSON_AddNumberToObject(root,"AddStudyExp", (double)(data.qwAddStudyExp));
	cJSON_AddNumberToObject(root,"DecStudyExp", (double)(data.qwDecStudyExp));
	cJSON_AddNumberToObject(root,"AfterStudyExp", (double)(data.qwAfterStudyExp));
	cJSON_AddNumberToObject(root,"AddMedal", (double)(data.qwAddMedal));
	cJSON_AddNumberToObject(root,"DecMedal", (double)(data.qwDecMedal));
	cJSON_AddNumberToObject(root,"AfterMedal", (double)(data.qwAfterMedal));
	cJSON_AddNumberToObject(root,"AddAmount", (double)(data.dwAddAmount));
	cJSON_AddNumberToObject(root,"AfterAmount", (double)(data.dwAfterAmount));
	cJSON_AddNumberToObject(root,"AddTotalRMB", (double)(data.qwAddTotalRMB));
	cJSON_AddNumberToObject(root,"AfterTotalRMB", (double)(data.qwAfterTotalRMB));
	cJSON_AddStringToObject(root,"LastConsumeTime", data.aszLastConsumeTime );
	cJSON_AddNumberToObject(root,"AddDoorsTribute", (double)(data.qwAddDoorsTribute));
	cJSON_AddNumberToObject(root,"DecDoorsTribute", (double)(data.qwDecDoorsTribute));
	cJSON_AddNumberToObject(root,"AfterDoorsTribute", (double)(data.qwAfterDoorsTribute));
	cJSON_AddNumberToObject(root,"AddRedStudyNum", (double)(data.qwAddRedStudyNum));
	cJSON_AddNumberToObject(root,"AddTaijiStudyNum", (double)(data.qwAddTaijiStudyNum));
	cJSON_AddNumberToObject(root,"BuyPhyStrengthNum", (double)(data.qwBuyPhyStrengthNum));

	return root;
}

INT32 DT_PLAYER_TODAY_CONSUME_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 49;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwID);
	memcpy(pDataBuff + dwOffset, &dwID, sizeof(dwID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwUTCLastConsumeTime);
	memcpy(pDataBuff + dwOffset, &qwUTCLastConsumeTime, sizeof(qwUTCLastConsumeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwAddExperience);
	memcpy(pDataBuff + dwOffset, &qwAddExperience, sizeof(qwAddExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwAfterExperience);
	memcpy(pDataBuff + dwOffset, &qwAfterExperience, sizeof(qwAfterExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wAddLevel);
	memcpy(pDataBuff + dwOffset, &wAddLevel, sizeof(wAddLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wAfterLevel);
	memcpy(pDataBuff + dwOffset, &wAfterLevel, sizeof(wAfterLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byAddVipLevel);
	memcpy(pDataBuff + dwOffset, &byAddVipLevel, sizeof(byAddVipLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byAfterVipLevel);
	memcpy(pDataBuff + dwOffset, &byAfterVipLevel, sizeof(byAfterVipLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwAddCoin);
	memcpy(pDataBuff + dwOffset, &qwAddCoin, sizeof(qwAddCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(qwDecCoin);
	memcpy(pDataBuff + dwOffset, &qwDecCoin, sizeof(qwDecCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(qwAfterCoin);
	memcpy(pDataBuff + dwOffset, &qwAfterCoin, sizeof(qwAfterCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(qwAddGold);
	memcpy(pDataBuff + dwOffset, &qwAddGold, sizeof(qwAddGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(qwDecGold);
	memcpy(pDataBuff + dwOffset, &qwDecGold, sizeof(qwDecGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(qwAfterGold);
	memcpy(pDataBuff + dwOffset, &qwAfterGold, sizeof(qwAfterGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(qwAddStory);
	memcpy(pDataBuff + dwOffset, &qwAddStory, sizeof(qwAddStory));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = sizeof(qwDecStory);
	memcpy(pDataBuff + dwOffset, &qwDecStory, sizeof(qwDecStory));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(qwAfterStory);
	memcpy(pDataBuff + dwOffset, &qwAfterStory, sizeof(qwAfterStory));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(wAddPhyStrength);
	memcpy(pDataBuff + dwOffset, &wAddPhyStrength, sizeof(wAddPhyStrength));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 19;
	pstIndex->dwContextLen = sizeof(wDecPhyStrength);
	memcpy(pDataBuff + dwOffset, &wDecPhyStrength, sizeof(wDecPhyStrength));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 20;
	pstIndex->dwContextLen = sizeof(wAfterPhyStrength);
	memcpy(pDataBuff + dwOffset, &wAfterPhyStrength, sizeof(wAfterPhyStrength));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 21;
	pstIndex->dwContextLen = sizeof(qwAddScience);
	memcpy(pDataBuff + dwOffset, &qwAddScience, sizeof(qwAddScience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 22;
	pstIndex->dwContextLen = sizeof(qwDecScience);
	memcpy(pDataBuff + dwOffset, &qwDecScience, sizeof(qwDecScience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 23;
	pstIndex->dwContextLen = sizeof(qwAfterScience);
	memcpy(pDataBuff + dwOffset, &qwAfterScience, sizeof(qwAfterScience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 24;
	pstIndex->dwContextLen = sizeof(qwAddBlueGas);
	memcpy(pDataBuff + dwOffset, &qwAddBlueGas, sizeof(qwAddBlueGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 25;
	pstIndex->dwContextLen = sizeof(qwDecBlueGas);
	memcpy(pDataBuff + dwOffset, &qwDecBlueGas, sizeof(qwDecBlueGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 26;
	pstIndex->dwContextLen = sizeof(qwAfterBlueGas);
	memcpy(pDataBuff + dwOffset, &qwAfterBlueGas, sizeof(qwAfterBlueGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 27;
	pstIndex->dwContextLen = sizeof(qwAddPurpleGas);
	memcpy(pDataBuff + dwOffset, &qwAddPurpleGas, sizeof(qwAddPurpleGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 28;
	pstIndex->dwContextLen = sizeof(qwDecPurpleGas);
	memcpy(pDataBuff + dwOffset, &qwDecPurpleGas, sizeof(qwDecPurpleGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 29;
	pstIndex->dwContextLen = sizeof(qwAfterPurpleGas);
	memcpy(pDataBuff + dwOffset, &qwAfterPurpleGas, sizeof(qwAfterPurpleGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 30;
	pstIndex->dwContextLen = sizeof(qwAddJingJie);
	memcpy(pDataBuff + dwOffset, &qwAddJingJie, sizeof(qwAddJingJie));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 31;
	pstIndex->dwContextLen = sizeof(qwDecJingJie);
	memcpy(pDataBuff + dwOffset, &qwDecJingJie, sizeof(qwDecJingJie));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 32;
	pstIndex->dwContextLen = sizeof(qwAfterJingJie);
	memcpy(pDataBuff + dwOffset, &qwAfterJingJie, sizeof(qwAfterJingJie));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 33;
	pstIndex->dwContextLen = sizeof(qwAddStudyExp);
	memcpy(pDataBuff + dwOffset, &qwAddStudyExp, sizeof(qwAddStudyExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 34;
	pstIndex->dwContextLen = sizeof(qwDecStudyExp);
	memcpy(pDataBuff + dwOffset, &qwDecStudyExp, sizeof(qwDecStudyExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 35;
	pstIndex->dwContextLen = sizeof(qwAfterStudyExp);
	memcpy(pDataBuff + dwOffset, &qwAfterStudyExp, sizeof(qwAfterStudyExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 36;
	pstIndex->dwContextLen = sizeof(qwAddMedal);
	memcpy(pDataBuff + dwOffset, &qwAddMedal, sizeof(qwAddMedal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 37;
	pstIndex->dwContextLen = sizeof(qwDecMedal);
	memcpy(pDataBuff + dwOffset, &qwDecMedal, sizeof(qwDecMedal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 38;
	pstIndex->dwContextLen = sizeof(qwAfterMedal);
	memcpy(pDataBuff + dwOffset, &qwAfterMedal, sizeof(qwAfterMedal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 39;
	pstIndex->dwContextLen = sizeof(dwAddAmount);
	memcpy(pDataBuff + dwOffset, &dwAddAmount, sizeof(dwAddAmount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 40;
	pstIndex->dwContextLen = sizeof(dwAfterAmount);
	memcpy(pDataBuff + dwOffset, &dwAfterAmount, sizeof(dwAfterAmount));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 41;
	pstIndex->dwContextLen = sizeof(qwAddTotalRMB);
	memcpy(pDataBuff + dwOffset, &qwAddTotalRMB, sizeof(qwAddTotalRMB));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 42;
	pstIndex->dwContextLen = sizeof(qwAfterTotalRMB);
	memcpy(pDataBuff + dwOffset, &qwAfterTotalRMB, sizeof(qwAfterTotalRMB));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 43;
	pstIndex->dwContextLen = sizeof(aszLastConsumeTime) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszLastConsumeTime, sizeof(aszLastConsumeTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 44;
	pstIndex->dwContextLen = sizeof(qwAddDoorsTribute);
	memcpy(pDataBuff + dwOffset, &qwAddDoorsTribute, sizeof(qwAddDoorsTribute));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 45;
	pstIndex->dwContextLen = sizeof(qwDecDoorsTribute);
	memcpy(pDataBuff + dwOffset, &qwDecDoorsTribute, sizeof(qwDecDoorsTribute));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 46;
	pstIndex->dwContextLen = sizeof(qwAfterDoorsTribute);
	memcpy(pDataBuff + dwOffset, &qwAfterDoorsTribute, sizeof(qwAfterDoorsTribute));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 47;
	pstIndex->dwContextLen = sizeof(qwAddRedStudyNum);
	memcpy(pDataBuff + dwOffset, &qwAddRedStudyNum, sizeof(qwAddRedStudyNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 48;
	pstIndex->dwContextLen = sizeof(qwAddTaijiStudyNum);
	memcpy(pDataBuff + dwOffset, &qwAddTaijiStudyNum, sizeof(qwAddTaijiStudyNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 49;
	pstIndex->dwContextLen = sizeof(qwBuyPhyStrengthNum);
	memcpy(pDataBuff + dwOffset, &qwBuyPhyStrengthNum, sizeof(qwBuyPhyStrengthNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_TODAY_CONSUME_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwID, 0, sizeof(dwID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwUTCLastConsumeTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwUTCLastConsumeTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwUTCLastConsumeTime, 0, sizeof(qwUTCLastConsumeTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwAddExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddExperience, 0, sizeof(qwAddExperience));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwAfterExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterExperience, 0, sizeof(qwAfterExperience));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wAddLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wAddLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAddLevel, 0, sizeof(wAddLevel));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wAfterLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wAfterLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAfterLevel, 0, sizeof(wAfterLevel));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byAddVipLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byAddVipLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAddVipLevel, 0, sizeof(byAddVipLevel));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byAfterVipLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&byAfterVipLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAfterVipLevel, 0, sizeof(byAfterVipLevel));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwAddCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddCoin, 0, sizeof(qwAddCoin));
				}
			}
			break;
		case 10:
			{
				if(sizeof(qwDecCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecCoin, 0, sizeof(qwDecCoin));
				}
			}
			break;
		case 11:
			{
				if(sizeof(qwAfterCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterCoin, 0, sizeof(qwAfterCoin));
				}
			}
			break;
		case 12:
			{
				if(sizeof(qwAddGold) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddGold, 0, sizeof(qwAddGold));
				}
			}
			break;
		case 13:
			{
				if(sizeof(qwDecGold) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecGold, 0, sizeof(qwDecGold));
				}
			}
			break;
		case 14:
			{
				if(sizeof(qwAfterGold) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterGold, 0, sizeof(qwAfterGold));
				}
			}
			break;
		case 15:
			{
				if(sizeof(qwAddStory) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddStory, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddStory, 0, sizeof(qwAddStory));
				}
			}
			break;
		case 16:
			{
				if(sizeof(qwDecStory) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecStory, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecStory, 0, sizeof(qwDecStory));
				}
			}
			break;
		case 17:
			{
				if(sizeof(qwAfterStory) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterStory, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterStory, 0, sizeof(qwAfterStory));
				}
			}
			break;
		case 18:
			{
				if(sizeof(wAddPhyStrength) >= pstIndex->dwContextLen)
				{
					memcpy(&wAddPhyStrength, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAddPhyStrength, 0, sizeof(wAddPhyStrength));
				}
			}
			break;
		case 19:
			{
				if(sizeof(wDecPhyStrength) >= pstIndex->dwContextLen)
				{
					memcpy(&wDecPhyStrength, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDecPhyStrength, 0, sizeof(wDecPhyStrength));
				}
			}
			break;
		case 20:
			{
				if(sizeof(wAfterPhyStrength) >= pstIndex->dwContextLen)
				{
					memcpy(&wAfterPhyStrength, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAfterPhyStrength, 0, sizeof(wAfterPhyStrength));
				}
			}
			break;
		case 21:
			{
				if(sizeof(qwAddScience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddScience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddScience, 0, sizeof(qwAddScience));
				}
			}
			break;
		case 22:
			{
				if(sizeof(qwDecScience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecScience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecScience, 0, sizeof(qwDecScience));
				}
			}
			break;
		case 23:
			{
				if(sizeof(qwAfterScience) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterScience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterScience, 0, sizeof(qwAfterScience));
				}
			}
			break;
		case 24:
			{
				if(sizeof(qwAddBlueGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddBlueGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddBlueGas, 0, sizeof(qwAddBlueGas));
				}
			}
			break;
		case 25:
			{
				if(sizeof(qwDecBlueGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecBlueGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecBlueGas, 0, sizeof(qwDecBlueGas));
				}
			}
			break;
		case 26:
			{
				if(sizeof(qwAfterBlueGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterBlueGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterBlueGas, 0, sizeof(qwAfterBlueGas));
				}
			}
			break;
		case 27:
			{
				if(sizeof(qwAddPurpleGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddPurpleGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddPurpleGas, 0, sizeof(qwAddPurpleGas));
				}
			}
			break;
		case 28:
			{
				if(sizeof(qwDecPurpleGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecPurpleGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecPurpleGas, 0, sizeof(qwDecPurpleGas));
				}
			}
			break;
		case 29:
			{
				if(sizeof(qwAfterPurpleGas) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterPurpleGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterPurpleGas, 0, sizeof(qwAfterPurpleGas));
				}
			}
			break;
		case 30:
			{
				if(sizeof(qwAddJingJie) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddJingJie, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddJingJie, 0, sizeof(qwAddJingJie));
				}
			}
			break;
		case 31:
			{
				if(sizeof(qwDecJingJie) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecJingJie, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecJingJie, 0, sizeof(qwDecJingJie));
				}
			}
			break;
		case 32:
			{
				if(sizeof(qwAfterJingJie) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterJingJie, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterJingJie, 0, sizeof(qwAfterJingJie));
				}
			}
			break;
		case 33:
			{
				if(sizeof(qwAddStudyExp) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddStudyExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddStudyExp, 0, sizeof(qwAddStudyExp));
				}
			}
			break;
		case 34:
			{
				if(sizeof(qwDecStudyExp) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecStudyExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecStudyExp, 0, sizeof(qwDecStudyExp));
				}
			}
			break;
		case 35:
			{
				if(sizeof(qwAfterStudyExp) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterStudyExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterStudyExp, 0, sizeof(qwAfterStudyExp));
				}
			}
			break;
		case 36:
			{
				if(sizeof(qwAddMedal) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddMedal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddMedal, 0, sizeof(qwAddMedal));
				}
			}
			break;
		case 37:
			{
				if(sizeof(qwDecMedal) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecMedal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecMedal, 0, sizeof(qwDecMedal));
				}
			}
			break;
		case 38:
			{
				if(sizeof(qwAfterMedal) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterMedal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterMedal, 0, sizeof(qwAfterMedal));
				}
			}
			break;
		case 39:
			{
				if(sizeof(dwAddAmount) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAddAmount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAddAmount, 0, sizeof(dwAddAmount));
				}
			}
			break;
		case 40:
			{
				if(sizeof(dwAfterAmount) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAfterAmount, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAfterAmount, 0, sizeof(dwAfterAmount));
				}
			}
			break;
		case 41:
			{
				if(sizeof(qwAddTotalRMB) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddTotalRMB, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddTotalRMB, 0, sizeof(qwAddTotalRMB));
				}
			}
			break;
		case 42:
			{
				if(sizeof(qwAfterTotalRMB) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterTotalRMB, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterTotalRMB, 0, sizeof(qwAfterTotalRMB));
				}
			}
			break;
		case 43:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszLastConsumeTime) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszLastConsumeTime, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszLastConsumeTime, 0, sizeof(aszLastConsumeTime));
				}
			}
			break;
		case 44:
			{
				if(sizeof(qwAddDoorsTribute) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddDoorsTribute, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddDoorsTribute, 0, sizeof(qwAddDoorsTribute));
				}
			}
			break;
		case 45:
			{
				if(sizeof(qwDecDoorsTribute) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDecDoorsTribute, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDecDoorsTribute, 0, sizeof(qwDecDoorsTribute));
				}
			}
			break;
		case 46:
			{
				if(sizeof(qwAfterDoorsTribute) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAfterDoorsTribute, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAfterDoorsTribute, 0, sizeof(qwAfterDoorsTribute));
				}
			}
			break;
		case 47:
			{
				if(sizeof(qwAddRedStudyNum) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddRedStudyNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddRedStudyNum, 0, sizeof(qwAddRedStudyNum));
				}
			}
			break;
		case 48:
			{
				if(sizeof(qwAddTaijiStudyNum) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddTaijiStudyNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddTaijiStudyNum, 0, sizeof(qwAddTaijiStudyNum));
				}
			}
			break;
		case 49:
			{
				if(sizeof(qwBuyPhyStrengthNum) >= pstIndex->dwContextLen)
				{
					memcpy(&qwBuyPhyStrengthNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwBuyPhyStrengthNum, 0, sizeof(qwBuyPhyStrengthNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RECV_FLOWER_DATA_LOG(void *pHost, CNetData* poNetData)
{
	DT_RECV_FLOWER_DATA_LOG *pstIn = (DT_RECV_FLOWER_DATA_LOG*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwSendPlayerID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFlowerNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSendTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsRead))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RECV_FLOWER_DATA_LOG(void *pHost, CNetData* poNetData)
{
	DT_RECV_FLOWER_DATA_LOG *pstOut = (DT_RECV_FLOWER_DATA_LOG*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwSendPlayerID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFlowerNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSendTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsRead))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RECV_FLOWER_DATA_LOG(DT_RECV_FLOWER_DATA_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SendPlayerID", (double)(data.dwSendPlayerID));
	cJSON_AddNumberToObject(root,"FlowerNum", (double)(data.dwFlowerNum));
	cJSON_AddNumberToObject(root,"SendTime", (double)(data.qwSendTime));
	cJSON_AddNumberToObject(root,"IsRead", (double)(data.byIsRead));

	return root;
}

INT32 DT_RECV_FLOWER_DATA_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwSendPlayerID);
	memcpy(pDataBuff + dwOffset, &dwSendPlayerID, sizeof(dwSendPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwFlowerNum);
	memcpy(pDataBuff + dwOffset, &dwFlowerNum, sizeof(dwFlowerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwSendTime);
	memcpy(pDataBuff + dwOffset, &qwSendTime, sizeof(qwSendTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byIsRead);
	memcpy(pDataBuff + dwOffset, &byIsRead, sizeof(byIsRead));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RECV_FLOWER_DATA_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwSendPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSendPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSendPlayerID, 0, sizeof(dwSendPlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwFlowerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFlowerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFlowerNum, 0, sizeof(dwFlowerNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwSendTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSendTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSendTime, 0, sizeof(qwSendTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byIsRead) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsRead, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsRead, 0, sizeof(byIsRead));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RECV_FLOWER_LOG_LIST(void *pHost, CNetData* poNetData)
{
	DT_RECV_FLOWER_LOG_LIST *pstIn = (DT_RECV_FLOWER_LOG_LIST*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RECV_FLOWER_LOG_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstIn->dwLogNum)
			break;
		if(-1 == EncodeDT_RECV_FLOWER_DATA_LOG(&pstIn->astListData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RECV_FLOWER_LOG_LIST(void *pHost, CNetData* poNetData)
{
	DT_RECV_FLOWER_LOG_LIST *pstOut = (DT_RECV_FLOWER_LOG_LIST*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RECV_FLOWER_LOG_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstOut->dwLogNum)
			break;
		if(-1 == DecodeDT_RECV_FLOWER_DATA_LOG(&pstOut->astListData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RECV_FLOWER_LOG_LIST(DT_RECV_FLOWER_LOG_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LogNum", (double)(data.dwLogNum));
	cJSON *ListData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ListData", ListData);
	for( UINT32 dwIndex=0; dwIndex<data.dwLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ListData, " ", GetJsonDT_RECV_FLOWER_DATA_LOG(data.astListData[dwIndex]));
	}

	return root;
}

INT32 DT_RECV_FLOWER_LOG_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwLogNum);
	memcpy(pDataBuff + dwOffset, &dwLogNum, sizeof(dwLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(dwLogNum > MAX_RECV_FLOWER_LOG_LIST_ELEM_NUM)
	{
		dwLogNum = MAX_RECV_FLOWER_LOG_LIST_ELEM_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = dwLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < dwLogNum; i++)
	{
		dwContextLenTmp += astListData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RECV_FLOWER_LOG_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwLogNum, 0, sizeof(dwLogNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == dwLogNum)
				{
					wArrNum = wArrNum <= MAX_RECV_FLOWER_LOG_LIST_ELEM_NUM ? wArrNum : MAX_RECV_FLOWER_LOG_LIST_ELEM_NUM;
					dwLogNum = (UINT32)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astListData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astListData, 0, sizeof(astListData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astListData, 0, sizeof(astListData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RELATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_RELATION_DATA *pstIn = (DT_RELATION_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerIDB))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byrelation))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwAddTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byisRead))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RELATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_RELATION_DATA *pstOut = (DT_RELATION_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerIDB))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byrelation))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwAddTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byisRead))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RELATION_DATA(DT_RELATION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerIDB", (double)(data.dwPlayerIDB));
	cJSON_AddNumberToObject(root,"relation", (double)(data.byrelation));
	cJSON_AddNumberToObject(root,"AddTime", (double)(data.qwAddTime));
	cJSON_AddNumberToObject(root,"isRead", (double)(data.byisRead));

	return root;
}

INT32 DT_RELATION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerIDB);
	memcpy(pDataBuff + dwOffset, &dwPlayerIDB, sizeof(dwPlayerIDB));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byrelation);
	memcpy(pDataBuff + dwOffset, &byrelation, sizeof(byrelation));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwAddTime);
	memcpy(pDataBuff + dwOffset, &qwAddTime, sizeof(qwAddTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byisRead);
	memcpy(pDataBuff + dwOffset, &byisRead, sizeof(byisRead));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RELATION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerIDB) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerIDB, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerIDB, 0, sizeof(dwPlayerIDB));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byrelation) >= pstIndex->dwContextLen)
				{
					memcpy(&byrelation, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byrelation, 0, sizeof(byrelation));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwAddTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwAddTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwAddTime, 0, sizeof(qwAddTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byisRead) >= pstIndex->dwContextLen)
				{
					memcpy(&byisRead, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byisRead, 0, sizeof(byisRead));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RELATION_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_RELATION_DATA_LIST *pstIn = (DT_RELATION_DATA_LIST*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwRelationNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RELATION_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstIn->dwRelationNum)
			break;
		if(-1 == EncodeDT_RELATION_DATA(&pstIn->astListData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RELATION_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_RELATION_DATA_LIST *pstOut = (DT_RELATION_DATA_LIST*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwRelationNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RELATION_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstOut->dwRelationNum)
			break;
		if(-1 == DecodeDT_RELATION_DATA(&pstOut->astListData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RELATION_DATA_LIST(DT_RELATION_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RelationNum", (double)(data.dwRelationNum));
	cJSON *ListData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ListData", ListData);
	for( UINT32 dwIndex=0; dwIndex<data.dwRelationNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ListData, " ", GetJsonDT_RELATION_DATA(data.astListData[dwIndex]));
	}

	return root;
}

INT32 DT_RELATION_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwRelationNum);
	memcpy(pDataBuff + dwOffset, &dwRelationNum, sizeof(dwRelationNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(dwRelationNum > MAX_RELATION_LIST_ELEM_NUM)
	{
		dwRelationNum = MAX_RELATION_LIST_ELEM_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = dwRelationNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < dwRelationNum; i++)
	{
		dwContextLenTmp += astListData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RELATION_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwRelationNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRelationNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRelationNum, 0, sizeof(dwRelationNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == dwRelationNum)
				{
					wArrNum = wArrNum <= MAX_RELATION_LIST_ELEM_NUM ? wArrNum : MAX_RELATION_LIST_ELEM_NUM;
					dwRelationNum = (UINT32)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astListData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astListData, 0, sizeof(astListData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astListData, 0, sizeof(astListData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RELATION_DATA_EVEN(void *pHost, CNetData* poNetData)
{
	DT_RELATION_DATA_EVEN *pstIn = (DT_RELATION_DATA_EVEN*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerIDA))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byisRead))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RELATION_DATA_EVEN(void *pHost, CNetData* poNetData)
{
	DT_RELATION_DATA_EVEN *pstOut = (DT_RELATION_DATA_EVEN*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerIDA))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byisRead))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RELATION_DATA_EVEN(DT_RELATION_DATA_EVEN &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerIDA", (double)(data.dwPlayerIDA));
	cJSON_AddNumberToObject(root,"isRead", (double)(data.byisRead));

	return root;
}

INT32 DT_RELATION_DATA_EVEN::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerIDA);
	memcpy(pDataBuff + dwOffset, &dwPlayerIDA, sizeof(dwPlayerIDA));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byisRead);
	memcpy(pDataBuff + dwOffset, &byisRead, sizeof(byisRead));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RELATION_DATA_EVEN::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerIDA) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerIDA, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerIDA, 0, sizeof(dwPlayerIDA));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byisRead) >= pstIndex->dwContextLen)
				{
					memcpy(&byisRead, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byisRead, 0, sizeof(byisRead));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_UNREAD_DATA_EVEN(void *pHost, CNetData* poNetData)
{
	DT_UNREAD_DATA_EVEN *pstIn = (DT_UNREAD_DATA_EVEN*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwSendPid))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwUnReadNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_UNREAD_DATA_EVEN(void *pHost, CNetData* poNetData)
{
	DT_UNREAD_DATA_EVEN *pstOut = (DT_UNREAD_DATA_EVEN*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwSendPid))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwUnReadNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_UNREAD_DATA_EVEN(DT_UNREAD_DATA_EVEN &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SendPid", (double)(data.dwSendPid));
	cJSON_AddNumberToObject(root,"UnReadNum", (double)(data.dwUnReadNum));

	return root;
}

INT32 DT_UNREAD_DATA_EVEN::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwSendPid);
	memcpy(pDataBuff + dwOffset, &dwSendPid, sizeof(dwSendPid));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwUnReadNum);
	memcpy(pDataBuff + dwOffset, &dwUnReadNum, sizeof(dwUnReadNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_UNREAD_DATA_EVEN::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwSendPid) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSendPid, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSendPid, 0, sizeof(dwSendPid));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwUnReadNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwUnReadNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwUnReadNum, 0, sizeof(dwUnReadNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DATA_EVEN_LIST(void *pHost, CNetData* poNetData)
{
	DT_DATA_EVEN_LIST *pstIn = (DT_DATA_EVEN_LIST*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwRelationNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RELATION_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstIn->dwRelationNum)
			break;
		if(-1 == EncodeDT_RELATION_DATA_EVEN(&pstIn->astRelationEvenData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddDword(pstIn->dwUnReadNum))
		return -1;

	for(i = 0; i < MAX_RELATION_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstIn->dwUnReadNum)
			break;
		if(-1 == EncodeDT_UNREAD_DATA_EVEN(&pstIn->astUnReadEvenData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DATA_EVEN_LIST(void *pHost, CNetData* poNetData)
{
	DT_DATA_EVEN_LIST *pstOut = (DT_DATA_EVEN_LIST*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwRelationNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RELATION_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstOut->dwRelationNum)
			break;
		if(-1 == DecodeDT_RELATION_DATA_EVEN(&pstOut->astRelationEvenData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelDword(pstOut->dwUnReadNum))
		return -1;

	for(i = 0; i < MAX_RELATION_LIST_ELEM_NUM; i++)
	{
		if(i >= (INT32)pstOut->dwUnReadNum)
			break;
		if(-1 == DecodeDT_UNREAD_DATA_EVEN(&pstOut->astUnReadEvenData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DATA_EVEN_LIST(DT_DATA_EVEN_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RelationNum", (double)(data.dwRelationNum));
	cJSON *RelationEvenData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "RelationEvenData", RelationEvenData);
	for( UINT32 dwIndex=0; dwIndex<data.dwRelationNum; ++dwIndex)
	{
		cJSON_AddItemToObject(RelationEvenData, " ", GetJsonDT_RELATION_DATA_EVEN(data.astRelationEvenData[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"UnReadNum", (double)(data.dwUnReadNum));
	cJSON *UnReadEvenData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "UnReadEvenData", UnReadEvenData);
	for( UINT32 dwIndex=0; dwIndex<data.dwUnReadNum; ++dwIndex)
	{
		cJSON_AddItemToObject(UnReadEvenData, " ", GetJsonDT_UNREAD_DATA_EVEN(data.astUnReadEvenData[dwIndex]));
	}

	return root;
}

INT32 DT_DATA_EVEN_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwRelationNum);
	memcpy(pDataBuff + dwOffset, &dwRelationNum, sizeof(dwRelationNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(dwRelationNum > MAX_RELATION_LIST_ELEM_NUM)
	{
		dwRelationNum = MAX_RELATION_LIST_ELEM_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = dwRelationNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < dwRelationNum; i++)
	{
		dwContextLenTmp += astRelationEvenData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwUnReadNum);
	memcpy(pDataBuff + dwOffset, &dwUnReadNum, sizeof(dwUnReadNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	dwContextLenTmp = 0;
	if(dwUnReadNum > MAX_RELATION_LIST_ELEM_NUM)
	{
		dwUnReadNum = MAX_RELATION_LIST_ELEM_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = dwUnReadNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < dwUnReadNum; i++)
	{
		dwContextLenTmp += astUnReadEvenData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DATA_EVEN_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwRelationNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRelationNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRelationNum, 0, sizeof(dwRelationNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == dwRelationNum)
				{
					wArrNum = wArrNum <= MAX_RELATION_LIST_ELEM_NUM ? wArrNum : MAX_RELATION_LIST_ELEM_NUM;
					dwRelationNum = (UINT32)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astRelationEvenData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astRelationEvenData, 0, sizeof(astRelationEvenData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astRelationEvenData, 0, sizeof(astRelationEvenData));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwUnReadNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwUnReadNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwUnReadNum, 0, sizeof(dwUnReadNum));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == dwUnReadNum)
				{
					wArrNum = wArrNum <= MAX_RELATION_LIST_ELEM_NUM ? wArrNum : MAX_RELATION_LIST_ELEM_NUM;
					dwUnReadNum = (UINT32)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astUnReadEvenData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astUnReadEvenData, 0, sizeof(astUnReadEvenData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astUnReadEvenData, 0, sizeof(astUnReadEvenData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_PLAYER_HEROID_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_PLAYER_HEROID_DATA *pstIn = (DT_COURAGE_PLAYER_HEROID_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleType))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwExperience))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszDispPlayerName, sizeof(pstIn->aszDispPlayerName)))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurAttackObjIdx))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwUpgradeExperience))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byColor))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_PLAYER_HEROID_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_PLAYER_HEROID_DATA *pstOut = (DT_COURAGE_PLAYER_HEROID_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleType))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwExperience))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszDispPlayerName, sizeof(pstOut->aszDispPlayerName)))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurAttackObjIdx))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwUpgradeExperience))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byColor))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_PLAYER_HEROID_DATA(DT_COURAGE_PLAYER_HEROID_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayID", (double)(data.dwPlayID));
	cJSON_AddNumberToObject(root,"HeroID", (double)(data.wHeroID));
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"BattleType", (double)(data.byBattleType));
	cJSON_AddNumberToObject(root,"Experience", (double)(data.dwExperience));
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddStringToObject(root,"DispPlayerName", data.aszDispPlayerName );
	cJSON_AddNumberToObject(root,"CurAttackObjIdx", (double)(data.byCurAttackObjIdx));
	cJSON_AddNumberToObject(root,"UpgradeExperience", (double)(data.dwUpgradeExperience));
	cJSON_AddNumberToObject(root,"Color", (double)(data.byColor));

	return root;
}

INT32 DT_COURAGE_PLAYER_HEROID_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayID);
	memcpy(pDataBuff + dwOffset, &dwPlayID, sizeof(dwPlayID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wHeroID);
	memcpy(pDataBuff + dwOffset, &wHeroID, sizeof(wHeroID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byBattleType);
	memcpy(pDataBuff + dwOffset, &byBattleType, sizeof(byBattleType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwExperience);
	memcpy(pDataBuff + dwOffset, &dwExperience, sizeof(dwExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(aszDispPlayerName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispPlayerName, sizeof(aszDispPlayerName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byCurAttackObjIdx);
	memcpy(pDataBuff + dwOffset, &byCurAttackObjIdx, sizeof(byCurAttackObjIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwUpgradeExperience);
	memcpy(pDataBuff + dwOffset, &dwUpgradeExperience, sizeof(dwUpgradeExperience));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byColor);
	memcpy(pDataBuff + dwOffset, &byColor, sizeof(byColor));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_PLAYER_HEROID_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayID, 0, sizeof(dwPlayID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wHeroID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroID, 0, sizeof(wHeroID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byBattleType) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleType, 0, sizeof(byBattleType));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwExperience, 0, sizeof(dwExperience));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 7:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispPlayerName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispPlayerName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispPlayerName, 0, sizeof(aszDispPlayerName));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byCurAttackObjIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurAttackObjIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurAttackObjIdx, 0, sizeof(byCurAttackObjIdx));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwUpgradeExperience) >= pstIndex->dwContextLen)
				{
					memcpy(&dwUpgradeExperience, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwUpgradeExperience, 0, sizeof(dwUpgradeExperience));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byColor) >= pstIndex->dwContextLen)
				{
					memcpy(&byColor, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byColor, 0, sizeof(byColor));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_COMMON_PLAYER_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_COMMON_PLAYER_BATTLE_DATA *pstIn = (DT_COURAGE_COMMON_PLAYER_BATTLE_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPlayerNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_COURAGE_MEMBER_NUM; i++)
	{
		if(i >= (INT32)pstIn->byPlayerNum)
			break;
		if(-1 == EncodeDT_COURAGE_PLAYER_HEROID_DATA(&pstIn->astPlayerInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_COMMON_PLAYER_BATTLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_COMMON_PLAYER_BATTLE_DATA *pstOut = (DT_COURAGE_COMMON_PLAYER_BATTLE_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPlayerNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_COURAGE_MEMBER_NUM; i++)
	{
		if(i >= (INT32)pstOut->byPlayerNum)
			break;
		if(-1 == DecodeDT_COURAGE_PLAYER_HEROID_DATA(&pstOut->astPlayerInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_COMMON_PLAYER_BATTLE_DATA(DT_COURAGE_COMMON_PLAYER_BATTLE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerNum", (double)(data.byPlayerNum));
	cJSON *PlayerInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PlayerInfo", PlayerInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byPlayerNum; ++dwIndex)
	{
		cJSON_AddItemToObject(PlayerInfo, " ", GetJsonDT_COURAGE_PLAYER_HEROID_DATA(data.astPlayerInfo[dwIndex]));
	}

	return root;
}

INT32 DT_COURAGE_COMMON_PLAYER_BATTLE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPlayerNum);
	memcpy(pDataBuff + dwOffset, &byPlayerNum, sizeof(byPlayerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byPlayerNum > MAX_COURAGE_MEMBER_NUM)
	{
		byPlayerNum = MAX_COURAGE_MEMBER_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byPlayerNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byPlayerNum; i++)
	{
		dwContextLenTmp += astPlayerInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_COMMON_PLAYER_BATTLE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPlayerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerNum, 0, sizeof(byPlayerNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byPlayerNum)
				{
					wArrNum = wArrNum <= MAX_COURAGE_MEMBER_NUM ? wArrNum : MAX_COURAGE_MEMBER_NUM;
					byPlayerNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPlayerInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPlayerInfo, 0, sizeof(astPlayerInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPlayerInfo, 0, sizeof(astPlayerInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_ITEM_DATA_CLI(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ITEM_DATA_CLI *pstIn = (DT_COURAGE_ITEM_DATA_CLI*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGoodsMainKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPileNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_ITEM_DATA_CLI(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ITEM_DATA_CLI *pstOut = (DT_COURAGE_ITEM_DATA_CLI*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGoodsMainKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPileNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_ITEM_DATA_CLI(DT_COURAGE_ITEM_DATA_CLI &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"GoodsMainKindID", (double)(data.byGoodsMainKindID));
	cJSON_AddNumberToObject(root,"PileNum", (double)(data.wPileNum));

	return root;
}

INT32 DT_COURAGE_ITEM_DATA_CLI::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byGoodsMainKindID);
	memcpy(pDataBuff + dwOffset, &byGoodsMainKindID, sizeof(byGoodsMainKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wPileNum);
	memcpy(pDataBuff + dwOffset, &wPileNum, sizeof(wPileNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_ITEM_DATA_CLI::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byGoodsMainKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&byGoodsMainKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGoodsMainKindID, 0, sizeof(byGoodsMainKindID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wPileNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPileNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPileNum, 0, sizeof(wPileNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_ITEM_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ITEM_DATA_LIST *pstIn = (DT_COURAGE_ITEM_DATA_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byItemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM; i++)
	{
		if(i >= (INT32)pstIn->byItemNum)
			break;
		if(-1 == EncodeDT_COURAGE_ITEM_DATA_CLI(&pstIn->astItemList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_ITEM_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ITEM_DATA_LIST *pstOut = (DT_COURAGE_ITEM_DATA_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byItemNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BAG_OPEN_NUM; i++)
	{
		if(i >= (INT32)pstOut->byItemNum)
			break;
		if(-1 == DecodeDT_COURAGE_ITEM_DATA_CLI(&pstOut->astItemList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_ITEM_DATA_LIST(DT_COURAGE_ITEM_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ItemNum", (double)(data.byItemNum));
	cJSON *ItemList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ItemList", ItemList);
	for( UINT32 dwIndex=0; dwIndex<data.byItemNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ItemList, " ", GetJsonDT_COURAGE_ITEM_DATA_CLI(data.astItemList[dwIndex]));
	}

	return root;
}

INT32 DT_COURAGE_ITEM_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byItemNum);
	memcpy(pDataBuff + dwOffset, &byItemNum, sizeof(byItemNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byItemNum > MAX_BAG_OPEN_NUM)
	{
		byItemNum = MAX_BAG_OPEN_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byItemNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byItemNum; i++)
	{
		dwContextLenTmp += astItemList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_ITEM_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byItemNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byItemNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byItemNum, 0, sizeof(byItemNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byItemNum)
				{
					wArrNum = wArrNum <= MAX_BAG_OPEN_NUM ? wArrNum : MAX_BAG_OPEN_NUM;
					byItemNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astItemList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astItemList, 0, sizeof(astItemList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astItemList, 0, sizeof(astItemList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_ENCOURAGE_BOX_GROUP_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ENCOURAGE_BOX_GROUP_DATA *pstIn = (DT_COURAGE_ENCOURAGE_BOX_GROUP_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwCoin))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGold))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHitItemIdx))
		return -1;

	if(-1 == EncodeDT_COURAGE_ITEM_DATA_LIST(&pstIn->stItemInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwBlueGas))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_ENCOURAGE_BOX_GROUP_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ENCOURAGE_BOX_GROUP_DATA *pstOut = (DT_COURAGE_ENCOURAGE_BOX_GROUP_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwCoin))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGold))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHitItemIdx))
		return -1;

	if(-1 == DecodeDT_COURAGE_ITEM_DATA_LIST(&pstOut->stItemInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwBlueGas))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_ENCOURAGE_BOX_GROUP_DATA(DT_COURAGE_ENCOURAGE_BOX_GROUP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Coin", (double)(data.dwCoin));
	cJSON_AddNumberToObject(root,"Gold", (double)(data.dwGold));
	cJSON_AddNumberToObject(root,"HitItemIdx", (double)(data.byHitItemIdx));
	cJSON_AddItemToObject(root, "ItemInfo", GetJsonDT_COURAGE_ITEM_DATA_LIST(data.stItemInfo));
	cJSON_AddNumberToObject(root,"BlueGas", (double)(data.dwBlueGas));

	return root;
}

INT32 DT_COURAGE_ENCOURAGE_BOX_GROUP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwCoin);
	memcpy(pDataBuff + dwOffset, &dwCoin, sizeof(dwCoin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwGold);
	memcpy(pDataBuff + dwOffset, &dwGold, sizeof(dwGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byHitItemIdx);
	memcpy(pDataBuff + dwOffset, &byHitItemIdx, sizeof(byHitItemIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stItemInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwBlueGas);
	memcpy(pDataBuff + dwOffset, &dwBlueGas, sizeof(dwBlueGas));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_ENCOURAGE_BOX_GROUP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwCoin) >= pstIndex->dwContextLen)
				{
					memcpy(&dwCoin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwCoin, 0, sizeof(dwCoin));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwGold) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGold, 0, sizeof(dwGold));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byHitItemIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byHitItemIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHitItemIdx, 0, sizeof(byHitItemIdx));
				}
			}
			break;
		case 4:
			{
				stItemInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				if(sizeof(dwBlueGas) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBlueGas, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBlueGas, 0, sizeof(dwBlueGas));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_ENCOURAGE_BOX_DATA2(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ENCOURAGE_BOX_DATA2 *pstIn = (DT_COURAGE_ENCOURAGE_BOX_DATA2*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byGroupNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVE_ENCOURAGE_BOX_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstIn->byGroupNum)
			break;
		if(-1 == EncodeDT_COURAGE_ENCOURAGE_BOX_GROUP_DATA(&pstIn->astBoxGroupInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_ENCOURAGE_BOX_DATA2(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_ENCOURAGE_BOX_DATA2 *pstOut = (DT_COURAGE_ENCOURAGE_BOX_DATA2*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byGroupNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVE_ENCOURAGE_BOX_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstOut->byGroupNum)
			break;
		if(-1 == DecodeDT_COURAGE_ENCOURAGE_BOX_GROUP_DATA(&pstOut->astBoxGroupInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_ENCOURAGE_BOX_DATA2(DT_COURAGE_ENCOURAGE_BOX_DATA2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GroupNum", (double)(data.byGroupNum));
	cJSON *BoxGroupInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BoxGroupInfo", BoxGroupInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byGroupNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BoxGroupInfo, " ", GetJsonDT_COURAGE_ENCOURAGE_BOX_GROUP_DATA(data.astBoxGroupInfo[dwIndex]));
	}

	return root;
}

INT32 DT_COURAGE_ENCOURAGE_BOX_DATA2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byGroupNum);
	memcpy(pDataBuff + dwOffset, &byGroupNum, sizeof(byGroupNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byGroupNum > MAX_GVE_ENCOURAGE_BOX_GROUP_NUM)
	{
		byGroupNum = MAX_GVE_ENCOURAGE_BOX_GROUP_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byGroupNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byGroupNum; i++)
	{
		dwContextLenTmp += astBoxGroupInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_ENCOURAGE_BOX_DATA2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byGroupNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byGroupNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGroupNum, 0, sizeof(byGroupNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byGroupNum)
				{
					wArrNum = wArrNum <= MAX_GVE_ENCOURAGE_BOX_GROUP_NUM ? wArrNum : MAX_GVE_ENCOURAGE_BOX_GROUP_NUM;
					byGroupNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBoxGroupInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBoxGroupInfo, 0, sizeof(astBoxGroupInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBoxGroupInfo, 0, sizeof(astBoxGroupInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_DATA *pstIn = (DT_COURAGE_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwLastTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwBuyTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwBuyAddTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTodayJoinTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGroupID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wGroupIndex))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTodayHelpTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGiveFreeTimes))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTotalTimes))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNotity))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAverageLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHavePass))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveAward))
		return -1;

	if(-1 == EncodeDT_COURAGE_COMMON_PLAYER_BATTLE_DATA(&pstIn->stGroupPlayerInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_ID(&pstIn->stSceneData, poNetData))
		return -1;

	if(-1 == EncodeDT_BAG_JEWELRY_DATA_LST(&pstIn->stjewelryInfoLst, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySelectGroupType))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_DATA *pstOut = (DT_COURAGE_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwLastTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwBuyTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwBuyAddTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTodayJoinTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGroupID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wGroupIndex))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTodayHelpTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGiveFreeTimes))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTotalTimes))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNotity))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAverageLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHavePass))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveAward))
		return -1;

	if(-1 == DecodeDT_COURAGE_COMMON_PLAYER_BATTLE_DATA(&pstOut->stGroupPlayerInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_ID(&pstOut->stSceneData, poNetData))
		return -1;

	if(-1 == DecodeDT_BAG_JEWELRY_DATA_LST(&pstOut->stjewelryInfoLst, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySelectGroupType))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_DATA(DT_COURAGE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LastTime", (double)(data.qwLastTime));
	cJSON_AddNumberToObject(root,"BuyTimes", (double)(data.dwBuyTimes));
	cJSON_AddNumberToObject(root,"BuyAddTimes", (double)(data.dwBuyAddTimes));
	cJSON_AddNumberToObject(root,"TodayJoinTimes", (double)(data.dwTodayJoinTimes));
	cJSON_AddNumberToObject(root,"GroupID", (double)(data.dwGroupID));
	cJSON_AddNumberToObject(root,"GroupIndex", (double)(data.wGroupIndex));
	cJSON_AddNumberToObject(root,"TodayHelpTimes", (double)(data.dwTodayHelpTimes));
	cJSON_AddNumberToObject(root,"GiveFreeTimes", (double)(data.dwGiveFreeTimes));
	cJSON_AddNumberToObject(root,"TotalTimes", (double)(data.dwTotalTimes));
	cJSON_AddNumberToObject(root,"Notity", (double)(data.byNotity));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddNumberToObject(root,"AverageLevel", (double)(data.wAverageLevel));
	cJSON_AddNumberToObject(root,"HavePass", (double)(data.byHavePass));
	cJSON_AddNumberToObject(root,"HaveAward", (double)(data.byHaveAward));
	cJSON_AddItemToObject(root, "GroupPlayerInfo", GetJsonDT_COURAGE_COMMON_PLAYER_BATTLE_DATA(data.stGroupPlayerInfo));
	cJSON_AddItemToObject(root, "SceneData", GetJsonDT_INSTANCE_ID(data.stSceneData));
	cJSON_AddItemToObject(root, "jewelryInfoLst", GetJsonDT_BAG_JEWELRY_DATA_LST(data.stjewelryInfoLst));
	cJSON_AddNumberToObject(root,"SelectGroupType", (double)(data.bySelectGroupType));

	return root;
}

INT32 DT_COURAGE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 18;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwLastTime);
	memcpy(pDataBuff + dwOffset, &qwLastTime, sizeof(qwLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwBuyTimes);
	memcpy(pDataBuff + dwOffset, &dwBuyTimes, sizeof(dwBuyTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwBuyAddTimes);
	memcpy(pDataBuff + dwOffset, &dwBuyAddTimes, sizeof(dwBuyAddTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwTodayJoinTimes);
	memcpy(pDataBuff + dwOffset, &dwTodayJoinTimes, sizeof(dwTodayJoinTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwGroupID);
	memcpy(pDataBuff + dwOffset, &dwGroupID, sizeof(dwGroupID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wGroupIndex);
	memcpy(pDataBuff + dwOffset, &wGroupIndex, sizeof(wGroupIndex));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwTodayHelpTimes);
	memcpy(pDataBuff + dwOffset, &dwTodayHelpTimes, sizeof(dwTodayHelpTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwGiveFreeTimes);
	memcpy(pDataBuff + dwOffset, &dwGiveFreeTimes, sizeof(dwGiveFreeTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwTotalTimes);
	memcpy(pDataBuff + dwOffset, &dwTotalTimes, sizeof(dwTotalTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byNotity);
	memcpy(pDataBuff + dwOffset, &byNotity, sizeof(byNotity));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(wAverageLevel);
	memcpy(pDataBuff + dwOffset, &wAverageLevel, sizeof(wAverageLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(byHavePass);
	memcpy(pDataBuff + dwOffset, &byHavePass, sizeof(byHavePass));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(byHaveAward);
	memcpy(pDataBuff + dwOffset, &byHaveAward, sizeof(byHaveAward));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = stGroupPlayerInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = stSceneData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = stjewelryInfoLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(bySelectGroupType);
	memcpy(pDataBuff + dwOffset, &bySelectGroupType, sizeof(bySelectGroupType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastTime, 0, sizeof(qwLastTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwBuyTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBuyTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBuyTimes, 0, sizeof(dwBuyTimes));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwBuyAddTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBuyAddTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBuyAddTimes, 0, sizeof(dwBuyAddTimes));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwTodayJoinTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTodayJoinTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTodayJoinTimes, 0, sizeof(dwTodayJoinTimes));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwGroupID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGroupID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGroupID, 0, sizeof(dwGroupID));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wGroupIndex) >= pstIndex->dwContextLen)
				{
					memcpy(&wGroupIndex, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wGroupIndex, 0, sizeof(wGroupIndex));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwTodayHelpTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTodayHelpTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTodayHelpTimes, 0, sizeof(dwTodayHelpTimes));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwGiveFreeTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGiveFreeTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGiveFreeTimes, 0, sizeof(dwGiveFreeTimes));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwTotalTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTotalTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTotalTimes, 0, sizeof(dwTotalTimes));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byNotity) >= pstIndex->dwContextLen)
				{
					memcpy(&byNotity, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNotity, 0, sizeof(byNotity));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 12:
			{
				if(sizeof(wAverageLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wAverageLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAverageLevel, 0, sizeof(wAverageLevel));
				}
			}
			break;
		case 13:
			{
				if(sizeof(byHavePass) >= pstIndex->dwContextLen)
				{
					memcpy(&byHavePass, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHavePass, 0, sizeof(byHavePass));
				}
			}
			break;
		case 14:
			{
				if(sizeof(byHaveAward) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveAward, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveAward, 0, sizeof(byHaveAward));
				}
			}
			break;
		case 15:
			{
				stGroupPlayerInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 16:
			{
				stSceneData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 17:
			{
				stjewelryInfoLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 18:
			{
				if(sizeof(bySelectGroupType) >= pstIndex->dwContextLen)
				{
					memcpy(&bySelectGroupType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySelectGroupType, 0, sizeof(bySelectGroupType));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EQUIP_MASTER_DETAIL(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_MASTER_DETAIL *pstIn = (DT_EQUIP_MASTER_DETAIL*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byMasterKind))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byMasterRank))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMasterLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwExp))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EQUIP_MASTER_DETAIL(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_MASTER_DETAIL *pstOut = (DT_EQUIP_MASTER_DETAIL*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byMasterKind))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byMasterRank))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMasterLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwExp))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EQUIP_MASTER_DETAIL(DT_EQUIP_MASTER_DETAIL &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MasterKind", (double)(data.byMasterKind));
	cJSON_AddNumberToObject(root,"MasterRank", (double)(data.byMasterRank));
	cJSON_AddNumberToObject(root,"MasterLevel", (double)(data.wMasterLevel));
	cJSON_AddNumberToObject(root,"Exp", (double)(data.dwExp));

	return root;
}

INT32 DT_EQUIP_MASTER_DETAIL::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byMasterKind);
	memcpy(pDataBuff + dwOffset, &byMasterKind, sizeof(byMasterKind));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byMasterRank);
	memcpy(pDataBuff + dwOffset, &byMasterRank, sizeof(byMasterRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wMasterLevel);
	memcpy(pDataBuff + dwOffset, &wMasterLevel, sizeof(wMasterLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwExp);
	memcpy(pDataBuff + dwOffset, &dwExp, sizeof(dwExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EQUIP_MASTER_DETAIL::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byMasterKind) >= pstIndex->dwContextLen)
				{
					memcpy(&byMasterKind, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMasterKind, 0, sizeof(byMasterKind));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byMasterRank) >= pstIndex->dwContextLen)
				{
					memcpy(&byMasterRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMasterRank, 0, sizeof(byMasterRank));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wMasterLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wMasterLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMasterLevel, 0, sizeof(wMasterLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwExp) >= pstIndex->dwContextLen)
				{
					memcpy(&dwExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwExp, 0, sizeof(dwExp));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MASTER_EXP_BOOK_DETAIL(void *pHost, CNetData* poNetData)
{
	DT_MASTER_EXP_BOOK_DETAIL *pstIn = (DT_MASTER_EXP_BOOK_DETAIL*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBigExpBookCnt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MASTER_EXP_BOOK_DETAIL(void *pHost, CNetData* poNetData)
{
	DT_MASTER_EXP_BOOK_DETAIL *pstOut = (DT_MASTER_EXP_BOOK_DETAIL*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBigExpBookCnt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MASTER_EXP_BOOK_DETAIL(DT_MASTER_EXP_BOOK_DETAIL &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BigExpBookCnt", (double)(data.byBigExpBookCnt));

	return root;
}

INT32 DT_MASTER_EXP_BOOK_DETAIL::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byBigExpBookCnt);
	memcpy(pDataBuff + dwOffset, &byBigExpBookCnt, sizeof(byBigExpBookCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MASTER_EXP_BOOK_DETAIL::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byBigExpBookCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byBigExpBookCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBigExpBookCnt, 0, sizeof(byBigExpBookCnt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EQUIP_MASTER(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_MASTER *pstIn = (DT_EQUIP_MASTER*)pHost;

	INT32 i;
	for(i = 0; i < EQUIP_KIND_COUNT; i++)
	{
		if(-1 == EncodeDT_EQUIP_MASTER_DETAIL(&pstIn->astMasterInfo[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byCultivatePanelState))
		return -1;

	for(i = 0; i < EQUIP_KIND_COUNT; i++)
	{
		if(-1 == EncodeDT_MASTER_EXP_BOOK_DETAIL(&pstIn->astExpBookPanel[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byCheatTimes))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EQUIP_MASTER(void *pHost, CNetData* poNetData)
{
	DT_EQUIP_MASTER *pstOut = (DT_EQUIP_MASTER*)pHost;

	INT32 i;
		for(i = 0; i < EQUIP_KIND_COUNT; i++)
		{
			if(-1 == DecodeDT_EQUIP_MASTER_DETAIL(&pstOut->astMasterInfo[i], poNetData))
				return -1;
		}

	if(-1 == poNetData->DelByte(pstOut->byCultivatePanelState))
		return -1;

		for(i = 0; i < EQUIP_KIND_COUNT; i++)
		{
			if(-1 == DecodeDT_MASTER_EXP_BOOK_DETAIL(&pstOut->astExpBookPanel[i], poNetData))
				return -1;
		}

	if(-1 == poNetData->DelByte(pstOut->byCheatTimes))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EQUIP_MASTER(DT_EQUIP_MASTER &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON *MasterInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "MasterInfo", MasterInfo);
	for( UINT32 dwIndex=0; dwIndex<EQUIP_KIND_COUNT; ++dwIndex)
	{
		cJSON_AddItemToObject(MasterInfo, " ", GetJsonDT_EQUIP_MASTER_DETAIL(data.astMasterInfo[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"CultivatePanelState", (double)(data.byCultivatePanelState));
	cJSON *ExpBookPanel = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ExpBookPanel", ExpBookPanel);
	for( UINT32 dwIndex=0; dwIndex<EQUIP_KIND_COUNT; ++dwIndex)
	{
		cJSON_AddItemToObject(ExpBookPanel, " ", GetJsonDT_MASTER_EXP_BOOK_DETAIL(data.astExpBookPanel[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"CheatTimes", (double)(data.byCheatTimes));
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));

	return root;
}

INT32 DT_EQUIP_MASTER::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = EQUIP_KIND_COUNT;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < EQUIP_KIND_COUNT; i++)
	{
		dwContextLenTmp += astMasterInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCultivatePanelState);
	memcpy(pDataBuff + dwOffset, &byCultivatePanelState, sizeof(byCultivatePanelState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = EQUIP_KIND_COUNT;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < EQUIP_KIND_COUNT; i++)
	{
		dwContextLenTmp += astExpBookPanel[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byCheatTimes);
	memcpy(pDataBuff + dwOffset, &byCheatTimes, sizeof(byCheatTimes));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EQUIP_MASTER::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= EQUIP_KIND_COUNT ? wArrNum : EQUIP_KIND_COUNT;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astMasterInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astMasterInfo, 0, sizeof(astMasterInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCultivatePanelState) >= pstIndex->dwContextLen)
				{
					memcpy(&byCultivatePanelState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCultivatePanelState, 0, sizeof(byCultivatePanelState));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= EQUIP_KIND_COUNT ? wArrNum : EQUIP_KIND_COUNT;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astExpBookPanel[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astExpBookPanel, 0, sizeof(astExpBookPanel));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 4:
			{
				if(sizeof(byCheatTimes) >= pstIndex->dwContextLen)
				{
					memcpy(&byCheatTimes, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCheatTimes, 0, sizeof(byCheatTimes));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FRIENDS_DATA(void *pHost, CNetData* poNetData)
{
	DT_FRIENDS_DATA *pstIn = (DT_FRIENDS_DATA*)pHost;

	if(-1 == EncodeDT_FRIENDS_BASE_DATA(&pstIn->stFriendsBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_RECV_FLOWER_LOG_LIST(&pstIn->stRecvFlowerLogList, poNetData))
		return -1;

	if(-1 == EncodeDT_RELATION_DATA_LIST(&pstIn->stRelationDataList, poNetData))
		return -1;

	if(-1 == EncodeDT_DATA_EVEN_LIST(&pstIn->stDataEvenList, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FRIENDS_DATA(void *pHost, CNetData* poNetData)
{
	DT_FRIENDS_DATA *pstOut = (DT_FRIENDS_DATA*)pHost;

	if(-1 == DecodeDT_FRIENDS_BASE_DATA(&pstOut->stFriendsBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_RECV_FLOWER_LOG_LIST(&pstOut->stRecvFlowerLogList, poNetData))
		return -1;

	if(-1 == DecodeDT_RELATION_DATA_LIST(&pstOut->stRelationDataList, poNetData))
		return -1;

	if(-1 == DecodeDT_DATA_EVEN_LIST(&pstOut->stDataEvenList, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FRIENDS_DATA(DT_FRIENDS_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "FriendsBaseData", GetJsonDT_FRIENDS_BASE_DATA(data.stFriendsBaseData));
	cJSON_AddItemToObject(root, "RecvFlowerLogList", GetJsonDT_RECV_FLOWER_LOG_LIST(data.stRecvFlowerLogList));
	cJSON_AddItemToObject(root, "RelationDataList", GetJsonDT_RELATION_DATA_LIST(data.stRelationDataList));
	cJSON_AddItemToObject(root, "DataEvenList", GetJsonDT_DATA_EVEN_LIST(data.stDataEvenList));

	return root;
}

INT32 DT_FRIENDS_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stFriendsBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stRecvFlowerLogList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stRelationDataList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stDataEvenList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FRIENDS_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stFriendsBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stRecvFlowerLogList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stRelationDataList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stDataEvenList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_INSTANCE_DB_DATA(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_DB_DATA *pstIn = (DT_INSTANCE_DB_DATA*)pHost;

	if(-1 == EncodeDT_INSTANCE_DATA_LIST(&pstIn->stCommonInstanceData, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_DATA_LIST(&pstIn->stEliteInstanceData, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_DATA_LIST(&pstIn->stClimbTowerInstanceData, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_BATTLE_DATA(&pstIn->stCommonBattleRcd, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_BATTLE_DATA(&pstIn->stEliteBattleRcd, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_BATTLE_DATA(&pstIn->stClimbTowerBattleRcd, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_DATA_LIST(&pstIn->stOutBoundInstanceData, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_DATA_LIST(&pstIn->stNeiDanInstanceData, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_BATTLE_DATA(&pstIn->stNeiDanBattleRcd, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_INSTANCE_DB_DATA(void *pHost, CNetData* poNetData)
{
	DT_INSTANCE_DB_DATA *pstOut = (DT_INSTANCE_DB_DATA*)pHost;

	if(-1 == DecodeDT_INSTANCE_DATA_LIST(&pstOut->stCommonInstanceData, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_DATA_LIST(&pstOut->stEliteInstanceData, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_DATA_LIST(&pstOut->stClimbTowerInstanceData, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_BATTLE_DATA(&pstOut->stCommonBattleRcd, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_BATTLE_DATA(&pstOut->stEliteBattleRcd, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_BATTLE_DATA(&pstOut->stClimbTowerBattleRcd, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_DATA_LIST(&pstOut->stOutBoundInstanceData, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_DATA_LIST(&pstOut->stNeiDanInstanceData, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_BATTLE_DATA(&pstOut->stNeiDanBattleRcd, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_INSTANCE_DB_DATA(DT_INSTANCE_DB_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "CommonInstanceData", GetJsonDT_INSTANCE_DATA_LIST(data.stCommonInstanceData));
	cJSON_AddItemToObject(root, "EliteInstanceData", GetJsonDT_INSTANCE_DATA_LIST(data.stEliteInstanceData));
	cJSON_AddItemToObject(root, "ClimbTowerInstanceData", GetJsonDT_INSTANCE_DATA_LIST(data.stClimbTowerInstanceData));
	cJSON_AddItemToObject(root, "CommonBattleRcd", GetJsonDT_INSTANCE_BATTLE_DATA(data.stCommonBattleRcd));
	cJSON_AddItemToObject(root, "EliteBattleRcd", GetJsonDT_INSTANCE_BATTLE_DATA(data.stEliteBattleRcd));
	cJSON_AddItemToObject(root, "ClimbTowerBattleRcd", GetJsonDT_INSTANCE_BATTLE_DATA(data.stClimbTowerBattleRcd));
	cJSON_AddItemToObject(root, "OutBoundInstanceData", GetJsonDT_INSTANCE_DATA_LIST(data.stOutBoundInstanceData));
	cJSON_AddItemToObject(root, "NeiDanInstanceData", GetJsonDT_INSTANCE_DATA_LIST(data.stNeiDanInstanceData));
	cJSON_AddItemToObject(root, "NeiDanBattleRcd", GetJsonDT_INSTANCE_BATTLE_DATA(data.stNeiDanBattleRcd));

	return root;
}

INT32 DT_INSTANCE_DB_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stCommonInstanceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stEliteInstanceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stClimbTowerInstanceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stCommonBattleRcd.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stEliteBattleRcd.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stClimbTowerBattleRcd.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stOutBoundInstanceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stNeiDanInstanceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stNeiDanBattleRcd.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_INSTANCE_DB_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stCommonInstanceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stEliteInstanceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stClimbTowerInstanceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stCommonBattleRcd.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stEliteBattleRcd.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stClimbTowerBattleRcd.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				stOutBoundInstanceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stNeiDanInstanceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stNeiDanBattleRcd.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_RACE_DATA(void *pHost, CNetData* poNetData)
{
	DT_RACE_DATA *pstIn = (DT_RACE_DATA*)pHost;

	if(-1 == EncodeDT_RACE_BASE_DATA(&pstIn->stRaceBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_RACE_BATTLELOG_DATA_LIST(&pstIn->stRaceBattleLog, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_RACE_DATA(void *pHost, CNetData* poNetData)
{
	DT_RACE_DATA *pstOut = (DT_RACE_DATA*)pHost;

	if(-1 == DecodeDT_RACE_BASE_DATA(&pstOut->stRaceBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_RACE_BATTLELOG_DATA_LIST(&pstOut->stRaceBattleLog, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_RACE_DATA(DT_RACE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "RaceBaseData", GetJsonDT_RACE_BASE_DATA(data.stRaceBaseData));
	cJSON_AddItemToObject(root, "RaceBattleLog", GetJsonDT_RACE_BATTLELOG_DATA_LIST(data.stRaceBattleLog));

	return root;
}

INT32 DT_RACE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stRaceBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stRaceBattleLog.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_RACE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stRaceBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stRaceBattleLog.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLUNDER_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_DATA *pstIn = (DT_PLUNDER_DATA*)pHost;

	if(-1 == EncodeDT_PLUNDER_BASE_DATA(&pstIn->stPlunderBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLUNDER_BATTLELOG_DATA_LIST(&pstIn->stPlunderBattleLog, poNetData))
		return -1;

	if(-1 == EncodeDT_CAPTURE_DATA_LIST(&pstIn->stCaptureData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLUNDER_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLUNDER_DATA *pstOut = (DT_PLUNDER_DATA*)pHost;

	if(-1 == DecodeDT_PLUNDER_BASE_DATA(&pstOut->stPlunderBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLUNDER_BATTLELOG_DATA_LIST(&pstOut->stPlunderBattleLog, poNetData))
		return -1;

	if(-1 == DecodeDT_CAPTURE_DATA_LIST(&pstOut->stCaptureData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLUNDER_DATA(DT_PLUNDER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "PlunderBaseData", GetJsonDT_PLUNDER_BASE_DATA(data.stPlunderBaseData));
	cJSON_AddItemToObject(root, "PlunderBattleLog", GetJsonDT_PLUNDER_BATTLELOG_DATA_LIST(data.stPlunderBattleLog));
	cJSON_AddItemToObject(root, "CaptureData", GetJsonDT_CAPTURE_DATA_LIST(data.stCaptureData));

	return root;
}

INT32 DT_PLUNDER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stPlunderBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stPlunderBattleLog.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stCaptureData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLUNDER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stPlunderBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stPlunderBattleLog.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stCaptureData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_YABIAO_DATA(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_DATA *pstIn = (DT_YABIAO_DATA*)pHost;

	if(-1 == EncodeDT_YABIAO_BASE_DATA(&pstIn->stYabiaoBaseInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_YABIAO_BATTLELOG_DATA_LIST(&pstIn->stYabiaoBattleLog, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_YABIAO_DATA(void *pHost, CNetData* poNetData)
{
	DT_YABIAO_DATA *pstOut = (DT_YABIAO_DATA*)pHost;

	if(-1 == DecodeDT_YABIAO_BASE_DATA(&pstOut->stYabiaoBaseInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_YABIAO_BATTLELOG_DATA_LIST(&pstOut->stYabiaoBattleLog, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_YABIAO_DATA(DT_YABIAO_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "YabiaoBaseInfo", GetJsonDT_YABIAO_BASE_DATA(data.stYabiaoBaseInfo));
	cJSON_AddItemToObject(root, "YabiaoBattleLog", GetJsonDT_YABIAO_BATTLELOG_DATA_LIST(data.stYabiaoBattleLog));

	return root;
}

INT32 DT_YABIAO_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 31;
	pstIndex->dwContextLen = stYabiaoBaseInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 35;
	pstIndex->dwContextLen = stYabiaoBattleLog.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_YABIAO_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 31:
			{
				stYabiaoBaseInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 35:
			{
				stYabiaoBattleLog.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BOSS_BATTLE_PLAYER_DATA_INFO(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_DATA_INFO *pstIn = (DT_BOSS_BATTLE_PLAYER_DATA_INFO*)pHost;

	if(-1 == EncodeDT_BOSS_BATTLE_PLAYER_DATA(&pstIn->stBossBattleData, poNetData))
		return -1;

	if(-1 == EncodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST(&pstIn->stBossBBLData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BOSS_BATTLE_PLAYER_DATA_INFO(void *pHost, CNetData* poNetData)
{
	DT_BOSS_BATTLE_PLAYER_DATA_INFO *pstOut = (DT_BOSS_BATTLE_PLAYER_DATA_INFO*)pHost;

	if(-1 == DecodeDT_BOSS_BATTLE_PLAYER_DATA(&pstOut->stBossBattleData, poNetData))
		return -1;

	if(-1 == DecodeDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST(&pstOut->stBossBBLData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BOSS_BATTLE_PLAYER_DATA_INFO(DT_BOSS_BATTLE_PLAYER_DATA_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "BossBattleData", GetJsonDT_BOSS_BATTLE_PLAYER_DATA(data.stBossBattleData));
	cJSON_AddItemToObject(root, "BossBBLData", GetJsonDT_BOSS_BATTLE_PLAYER_BATTLE_LOG_DATA_LST(data.stBossBBLData));

	return root;
}

INT32 DT_BOSS_BATTLE_PLAYER_DATA_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stBossBattleData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stBossBBLData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BOSS_BATTLE_PLAYER_DATA_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stBossBattleData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stBossBBLData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EXCHANGE_RESULT_LOG(void *pHost, CNetData* poNetData)
{
	DT_EXCHANGE_RESULT_LOG *pstIn = (DT_EXCHANGE_RESULT_LOG*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byNtfFlag))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwExchangeGold))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EXCHANGE_RESULT_LOG(void *pHost, CNetData* poNetData)
{
	DT_EXCHANGE_RESULT_LOG *pstOut = (DT_EXCHANGE_RESULT_LOG*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byNtfFlag))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwExchangeGold))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EXCHANGE_RESULT_LOG(DT_EXCHANGE_RESULT_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"NtfFlag", (double)(data.byNtfFlag));
	cJSON_AddNumberToObject(root,"ExchangeGold", (double)(data.dwExchangeGold));

	return root;
}

INT32 DT_EXCHANGE_RESULT_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byNtfFlag);
	memcpy(pDataBuff + dwOffset, &byNtfFlag, sizeof(byNtfFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwExchangeGold);
	memcpy(pDataBuff + dwOffset, &dwExchangeGold, sizeof(dwExchangeGold));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EXCHANGE_RESULT_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byNtfFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byNtfFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNtfFlag, 0, sizeof(byNtfFlag));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwExchangeGold) >= pstIndex->dwContextLen)
				{
					memcpy(&dwExchangeGold, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwExchangeGold, 0, sizeof(dwExchangeGold));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GAMBLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_GAMBLE_DATA *pstIn = (DT_GAMBLE_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwGameID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSupportFactionID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GAMBLE_DATA(void *pHost, CNetData* poNetData)
{
	DT_GAMBLE_DATA *pstOut = (DT_GAMBLE_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwGameID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSupportFactionID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GAMBLE_DATA(DT_GAMBLE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GameID", (double)(data.qwGameID));
	cJSON_AddNumberToObject(root,"SupportFactionID", (double)(data.dwSupportFactionID));

	return root;
}

INT32 DT_GAMBLE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwGameID);
	memcpy(pDataBuff + dwOffset, &qwGameID, sizeof(qwGameID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwSupportFactionID);
	memcpy(pDataBuff + dwOffset, &dwSupportFactionID, sizeof(dwSupportFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GAMBLE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwGameID) >= pstIndex->dwContextLen)
				{
					memcpy(&qwGameID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwGameID, 0, sizeof(qwGameID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwSupportFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSupportFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSupportFactionID, 0, sizeof(dwSupportFactionID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_GIFT_REWARD_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_GIFT_REWARD_DATA *pstIn = (DT_GVG_GIFT_REWARD_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSessionID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGvGRound))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleIdx))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionName, sizeof(pstIn->aszFactionName)))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGiftID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGiftType))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byRank))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_GIFT_REWARD_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_GIFT_REWARD_DATA *pstOut = (DT_GVG_GIFT_REWARD_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSessionID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGvGRound))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleIdx))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionName, sizeof(pstOut->aszFactionName)))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGiftID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGiftType))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byRank))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_GIFT_REWARD_DATA(DT_GVG_GIFT_REWARD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SessionID", (double)(data.wSessionID));
	cJSON_AddNumberToObject(root,"GvGRound", (double)(data.byGvGRound));
	cJSON_AddNumberToObject(root,"BattleIdx", (double)(data.byBattleIdx));
	cJSON_AddStringToObject(root,"FactionName", data.aszFactionName );
	cJSON_AddNumberToObject(root,"BattleResult", (double)(data.byBattleResult));
	cJSON_AddNumberToObject(root,"GiftID", (double)(data.byGiftID));
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddNumberToObject(root,"GiftType", (double)(data.byGiftType));
	cJSON_AddNumberToObject(root,"Rank", (double)(data.byRank));

	return root;
}

INT32 DT_GVG_GIFT_REWARD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSessionID);
	memcpy(pDataBuff + dwOffset, &wSessionID, sizeof(wSessionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byGvGRound);
	memcpy(pDataBuff + dwOffset, &byGvGRound, sizeof(byGvGRound));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBattleIdx);
	memcpy(pDataBuff + dwOffset, &byBattleIdx, sizeof(byBattleIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszFactionName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionName, sizeof(aszFactionName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBattleResult);
	memcpy(pDataBuff + dwOffset, &byBattleResult, sizeof(byBattleResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byGiftID);
	memcpy(pDataBuff + dwOffset, &byGiftID, sizeof(byGiftID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byGiftType);
	memcpy(pDataBuff + dwOffset, &byGiftType, sizeof(byGiftType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byRank);
	memcpy(pDataBuff + dwOffset, &byRank, sizeof(byRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_GIFT_REWARD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSessionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSessionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSessionID, 0, sizeof(wSessionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byGvGRound) >= pstIndex->dwContextLen)
				{
					memcpy(&byGvGRound, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGvGRound, 0, sizeof(byGvGRound));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byBattleIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleIdx, 0, sizeof(byBattleIdx));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionName) >= dwContextLen) && (wArrNum <= MAX_FACTION_NUM))
				{
					memcpy(&aszFactionName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionName, 0, sizeof(aszFactionName));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBattleResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleResult, 0, sizeof(byBattleResult));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byGiftID) >= pstIndex->dwContextLen)
				{
					memcpy(&byGiftID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGiftID, 0, sizeof(byGiftID));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byGiftType) >= pstIndex->dwContextLen)
				{
					memcpy(&byGiftType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGiftType, 0, sizeof(byGiftType));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byRank) >= pstIndex->dwContextLen)
				{
					memcpy(&byRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRank, 0, sizeof(byRank));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_GIFT_REWARD_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_GIFT_REWARD_LST_DATA *pstIn = (DT_GVG_GIFT_REWARD_LST_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byGiftNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GIFT_NUM; i++)
	{
		if(i >= (INT32)pstIn->byGiftNum)
			break;
		if(-1 == EncodeDT_GVG_GIFT_REWARD_DATA(&pstIn->astGiftInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_GIFT_REWARD_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_GIFT_REWARD_LST_DATA *pstOut = (DT_GVG_GIFT_REWARD_LST_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byGiftNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GIFT_NUM; i++)
	{
		if(i >= (INT32)pstOut->byGiftNum)
			break;
		if(-1 == DecodeDT_GVG_GIFT_REWARD_DATA(&pstOut->astGiftInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_GIFT_REWARD_LST_DATA(DT_GVG_GIFT_REWARD_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GiftNum", (double)(data.byGiftNum));
	cJSON *GiftInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GiftInfo", GiftInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byGiftNum; ++dwIndex)
	{
		cJSON_AddItemToObject(GiftInfo, " ", GetJsonDT_GVG_GIFT_REWARD_DATA(data.astGiftInfo[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_GIFT_REWARD_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byGiftNum);
	memcpy(pDataBuff + dwOffset, &byGiftNum, sizeof(byGiftNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byGiftNum > MAX_GVG_GIFT_NUM)
	{
		byGiftNum = MAX_GVG_GIFT_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byGiftNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byGiftNum; i++)
	{
		dwContextLenTmp += astGiftInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_GIFT_REWARD_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byGiftNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byGiftNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGiftNum, 0, sizeof(byGiftNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byGiftNum)
				{
					wArrNum = wArrNum <= MAX_GVG_GIFT_NUM ? wArrNum : MAX_GVG_GIFT_NUM;
					byGiftNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astGiftInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astGiftInfo, 0, sizeof(astGiftInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astGiftInfo, 0, sizeof(astGiftInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_GIFT_KEY_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_GIFT_KEY_LST_DATA *pstIn = (DT_GVG_GIFT_KEY_LST_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byGiftNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GIFT_NUM; i++)
	{
		if(i >= (INT32)pstIn->byGiftNum)
			break;
		if(-1 == poNetData->AddUint64(pstIn->aqwGiftKey[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_GIFT_KEY_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_GIFT_KEY_LST_DATA *pstOut = (DT_GVG_GIFT_KEY_LST_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byGiftNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GIFT_NUM; i++)
	{
		if(i >= (INT32)pstOut->byGiftNum)
			break;
		if(-1 == poNetData->DelUint64(pstOut->aqwGiftKey[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_GIFT_KEY_LST_DATA(DT_GVG_GIFT_KEY_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GiftNum", (double)(data.byGiftNum));
	cJSON *GiftKey = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GiftKey", GiftKey);
	for( UINT32 dwIndex=0; dwIndex<data.byGiftNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"GiftKey", (double)(data.aqwGiftKey[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_GIFT_KEY_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byGiftNum);
	memcpy(pDataBuff + dwOffset, &byGiftNum, sizeof(byGiftNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(byGiftNum > MAX_GVG_GIFT_NUM)
	{
		byGiftNum = MAX_GVG_GIFT_NUM;
	}
	pstIndex->dwContextLen = byGiftNum * sizeof(UINT64) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byGiftNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aqwGiftKey, byGiftNum * sizeof(UINT64));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_GIFT_KEY_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byGiftNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byGiftNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGiftNum, 0, sizeof(byGiftNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aqwGiftKey) >= dwContextLen) && (wArrNum == byGiftNum) && (wArrNum <= MAX_GVG_GIFT_NUM))
				{
					memcpy(&aqwGiftKey, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aqwGiftKey, 0, sizeof(aqwGiftKey));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_GVG_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_GVG_DATA *pstIn = (DT_PLAYER_GVG_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GAMBLE_NUM; i++)
	{
		if(-1 == EncodeDT_GAMBLE_DATA(&pstIn->astGambleLstInfo[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_GVG_GIFT_KEY_LST_DATA(&pstIn->stGetGiftData, poNetData))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSessionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wReadLogCnt))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsGetGamble))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_GVG_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_GVG_DATA *pstOut = (DT_PLAYER_GVG_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_GAMBLE_NUM; i++)
		{
			if(-1 == DecodeDT_GAMBLE_DATA(&pstOut->astGambleLstInfo[i], poNetData))
				return -1;
		}

	if(-1 == DecodeDT_GVG_GIFT_KEY_LST_DATA(&pstOut->stGetGiftData, poNetData))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSessionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wReadLogCnt))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsGetGamble))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_GVG_DATA(DT_PLAYER_GVG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON *GambleLstInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GambleLstInfo", GambleLstInfo);
	for( UINT32 dwIndex=0; dwIndex<MAX_GAMBLE_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(GambleLstInfo, " ", GetJsonDT_GAMBLE_DATA(data.astGambleLstInfo[dwIndex]));
	}
	cJSON_AddItemToObject(root, "GetGiftData", GetJsonDT_GVG_GIFT_KEY_LST_DATA(data.stGetGiftData));
	cJSON_AddNumberToObject(root,"SessionID", (double)(data.wSessionID));
	cJSON_AddNumberToObject(root,"ReadLogCnt", (double)(data.wReadLogCnt));
	cJSON_AddNumberToObject(root,"IsGetGamble", (double)(data.byIsGetGamble));

	return root;
}

INT32 DT_PLAYER_GVG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_GAMBLE_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_GAMBLE_NUM; i++)
	{
		dwContextLenTmp += astGambleLstInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stGetGiftData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wSessionID);
	memcpy(pDataBuff + dwOffset, &wSessionID, sizeof(wSessionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wReadLogCnt);
	memcpy(pDataBuff + dwOffset, &wReadLogCnt, sizeof(wReadLogCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byIsGetGamble);
	memcpy(pDataBuff + dwOffset, &byIsGetGamble, sizeof(byIsGetGamble));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_GVG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_GAMBLE_NUM ? wArrNum : MAX_GAMBLE_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astGambleLstInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astGambleLstInfo, 0, sizeof(astGambleLstInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 3:
			{
				stGetGiftData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				if(sizeof(wSessionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSessionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSessionID, 0, sizeof(wSessionID));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wReadLogCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wReadLogCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wReadLogCnt, 0, sizeof(wReadLogCnt));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byIsGetGamble) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsGetGamble, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsGetGamble, 0, sizeof(byIsGetGamble));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_FORMATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_FORMATION_DATA *pstIn = (DT_GVG_FORMATION_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPlayerNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_FORMATION_PLAYER_CNT; i++)
	{
		if(-1 == poNetData->AddDword(pstIn->adwPlayerIDList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_FORMATION_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_FORMATION_DATA *pstOut = (DT_GVG_FORMATION_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPlayerNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_FORMATION_PLAYER_CNT; i++)
	{
		if(-1 == poNetData->DelDword(pstOut->adwPlayerIDList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_FORMATION_DATA(DT_GVG_FORMATION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerNum", (double)(data.byPlayerNum));
	cJSON *PlayerIDList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PlayerIDList", PlayerIDList);
	for( UINT32 dwIndex=0; dwIndex<MAX_GVG_FORMATION_PLAYER_CNT; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"PlayerIDList", (double)(data.adwPlayerIDList[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_FORMATION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPlayerNum);
	memcpy(pDataBuff + dwOffset, &byPlayerNum, sizeof(byPlayerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(adwPlayerIDList) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_GVG_FORMATION_PLAYER_CNT;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &adwPlayerIDList, sizeof(adwPlayerIDList));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_FORMATION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPlayerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerNum, 0, sizeof(byPlayerNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(adwPlayerIDList) >= dwContextLen) && (wArrNum <= MAX_GVG_FORMATION_PLAYER_CNT))
				{
					memcpy(&adwPlayerIDList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&adwPlayerIDList, 0, sizeof(adwPlayerIDList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_BASE_DATA_CLI2(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BASE_DATA_CLI2 *pstIn = (DT_FACTION_BASE_DATA_CLI2*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIconID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszHeadName, sizeof(pstIn->aszHeadName)))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionName, sizeof(pstIn->aszFactionName)))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wCurPlayerNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMaxPlayerNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionRank))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionFunds))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwFactionFundsSum))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionAnnouncement, sizeof(pstIn->aszFactionAnnouncement)))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszZoneName, sizeof(pstIn->aszZoneName)))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_BASE_DATA_CLI2(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BASE_DATA_CLI2 *pstOut = (DT_FACTION_BASE_DATA_CLI2*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIconID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszHeadName, sizeof(pstOut->aszHeadName)))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionName, sizeof(pstOut->aszFactionName)))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wCurPlayerNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMaxPlayerNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionRank))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionFunds))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwFactionFundsSum))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionAnnouncement, sizeof(pstOut->aszFactionAnnouncement)))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszZoneName, sizeof(pstOut->aszZoneName)))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_BASE_DATA_CLI2(DT_FACTION_BASE_DATA_CLI2 &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));
	cJSON_AddNumberToObject(root,"IconID", (double)(data.byIconID));
	cJSON_AddStringToObject(root,"HeadName", data.aszHeadName );
	cJSON_AddStringToObject(root,"FactionName", data.aszFactionName );
	cJSON_AddNumberToObject(root,"CurPlayerNum", (double)(data.wCurPlayerNum));
	cJSON_AddNumberToObject(root,"MaxPlayerNum", (double)(data.wMaxPlayerNum));
	cJSON_AddNumberToObject(root,"FactionRank", (double)(data.dwFactionRank));
	cJSON_AddNumberToObject(root,"FactionLevel", (double)(data.dwFactionLevel));
	cJSON_AddNumberToObject(root,"FactionFunds", (double)(data.dwFactionFunds));
	cJSON_AddNumberToObject(root,"FactionFundsSum", (double)(data.qwFactionFundsSum));
	cJSON_AddStringToObject(root,"FactionAnnouncement", data.aszFactionAnnouncement );
	cJSON_AddStringToObject(root,"ZoneName", data.aszZoneName );

	return root;
}

INT32 DT_FACTION_BASE_DATA_CLI2::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 12;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byIconID);
	memcpy(pDataBuff + dwOffset, &byIconID, sizeof(byIconID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszHeadName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszHeadName, sizeof(aszHeadName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszFactionName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionName, sizeof(aszFactionName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wCurPlayerNum);
	memcpy(pDataBuff + dwOffset, &wCurPlayerNum, sizeof(wCurPlayerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wMaxPlayerNum);
	memcpy(pDataBuff + dwOffset, &wMaxPlayerNum, sizeof(wMaxPlayerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwFactionRank);
	memcpy(pDataBuff + dwOffset, &dwFactionRank, sizeof(dwFactionRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwFactionLevel);
	memcpy(pDataBuff + dwOffset, &dwFactionLevel, sizeof(dwFactionLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwFactionFunds);
	memcpy(pDataBuff + dwOffset, &dwFactionFunds, sizeof(dwFactionFunds));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(qwFactionFundsSum);
	memcpy(pDataBuff + dwOffset, &qwFactionFundsSum, sizeof(qwFactionFundsSum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(aszFactionAnnouncement) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_DESC_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionAnnouncement, sizeof(aszFactionAnnouncement));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(aszZoneName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = ZONENAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszZoneName, sizeof(aszZoneName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_BASE_DATA_CLI2::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byIconID) >= pstIndex->dwContextLen)
				{
					memcpy(&byIconID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIconID, 0, sizeof(byIconID));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszHeadName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszHeadName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszHeadName, 0, sizeof(aszHeadName));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionName) >= dwContextLen) && (wArrNum <= MAX_FACTION_NUM))
				{
					memcpy(&aszFactionName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionName, 0, sizeof(aszFactionName));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wCurPlayerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wCurPlayerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wCurPlayerNum, 0, sizeof(wCurPlayerNum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wMaxPlayerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wMaxPlayerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMaxPlayerNum, 0, sizeof(wMaxPlayerNum));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwFactionRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionRank, 0, sizeof(dwFactionRank));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwFactionLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionLevel, 0, sizeof(dwFactionLevel));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwFactionFunds) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionFunds, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionFunds, 0, sizeof(dwFactionFunds));
				}
			}
			break;
		case 10:
			{
				if(sizeof(qwFactionFundsSum) >= pstIndex->dwContextLen)
				{
					memcpy(&qwFactionFundsSum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwFactionFundsSum, 0, sizeof(qwFactionFundsSum));
				}
			}
			break;
		case 11:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionAnnouncement) >= dwContextLen) && (wArrNum <= MAX_FACTION_DESC_NUM))
				{
					memcpy(&aszFactionAnnouncement, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionAnnouncement, 0, sizeof(aszFactionAnnouncement));
				}
			}
			break;
		case 12:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszZoneName) >= dwContextLen) && (wArrNum <= ZONENAME_LEN))
				{
					memcpy(&aszZoneName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszZoneName, 0, sizeof(aszZoneName));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GAMBLE_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_GAMBLE_FACTION_INFO *pstIn = (DT_GAMBLE_FACTION_INFO*)pHost;

	if(-1 == EncodeDT_FACTION_BASE_DATA_CLI2(&pstIn->stFactionInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wZoneID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsWin))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsGamble))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GAMBLE_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_GAMBLE_FACTION_INFO *pstOut = (DT_GAMBLE_FACTION_INFO*)pHost;

	if(-1 == DecodeDT_FACTION_BASE_DATA_CLI2(&pstOut->stFactionInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wZoneID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsWin))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsGamble))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GAMBLE_FACTION_INFO(DT_GAMBLE_FACTION_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "FactionInfo", GetJsonDT_FACTION_BASE_DATA_CLI2(data.stFactionInfo));
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.wZoneID));
	cJSON_AddNumberToObject(root,"IsWin", (double)(data.byIsWin));
	cJSON_AddNumberToObject(root,"IsGamble", (double)(data.byIsGamble));

	return root;
}

INT32 DT_GAMBLE_FACTION_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stFactionInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wZoneID);
	memcpy(pDataBuff + dwOffset, &wZoneID, sizeof(wZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byIsWin);
	memcpy(pDataBuff + dwOffset, &byIsWin, sizeof(byIsWin));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byIsGamble);
	memcpy(pDataBuff + dwOffset, &byIsGamble, sizeof(byIsGamble));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GAMBLE_FACTION_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stFactionInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				if(sizeof(wZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&wZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wZoneID, 0, sizeof(wZoneID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byIsWin) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsWin, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsWin, 0, sizeof(byIsWin));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byIsGamble) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsGamble, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsGamble, 0, sizeof(byIsGamble));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_ROUND(void *pHost, CNetData* poNetData)
{
	DT_GVG_ROUND *pstIn = (DT_GVG_ROUND*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byBigRound))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySmallRound))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_ROUND(void *pHost, CNetData* poNetData)
{
	DT_GVG_ROUND *pstOut = (DT_GVG_ROUND*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byBigRound))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySmallRound))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_ROUND(DT_GVG_ROUND &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"BigRound", (double)(data.byBigRound));
	cJSON_AddNumberToObject(root,"SmallRound", (double)(data.bySmallRound));

	return root;
}

INT32 DT_GVG_ROUND::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byBigRound);
	memcpy(pDataBuff + dwOffset, &byBigRound, sizeof(byBigRound));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(bySmallRound);
	memcpy(pDataBuff + dwOffset, &bySmallRound, sizeof(bySmallRound));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_ROUND::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 3:
			{
				if(sizeof(byBigRound) >= pstIndex->dwContextLen)
				{
					memcpy(&byBigRound, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBigRound, 0, sizeof(byBigRound));
				}
			}
			break;
		case 4:
			{
				if(sizeof(bySmallRound) >= pstIndex->dwContextLen)
				{
					memcpy(&bySmallRound, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySmallRound, 0, sizeof(bySmallRound));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_GVG_SINGLE_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_SINGLE_LOG *pstIn = (DT_FACTION_GVG_SINGLE_LOG*)pHost;

	if(-1 == EncodeDT_GVG_ROUND(&pstIn->stRound, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwVideoID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byResult))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wScore))
		return -1;

	if(-1 == EncodeDT_GAMBLE_FACTION_INFO(&pstIn->stG1, poNetData))
		return -1;

	if(-1 == EncodeDT_GAMBLE_FACTION_INFO(&pstIn->stG2, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_GVG_SINGLE_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_SINGLE_LOG *pstOut = (DT_FACTION_GVG_SINGLE_LOG*)pHost;

	if(-1 == DecodeDT_GVG_ROUND(&pstOut->stRound, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwVideoID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byResult))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wScore))
		return -1;

	if(-1 == DecodeDT_GAMBLE_FACTION_INFO(&pstOut->stG1, poNetData))
		return -1;

	if(-1 == DecodeDT_GAMBLE_FACTION_INFO(&pstOut->stG2, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_GVG_SINGLE_LOG(DT_FACTION_GVG_SINGLE_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "Round", GetJsonDT_GVG_ROUND(data.stRound));
	cJSON_AddNumberToObject(root,"VideoID", (double)(data.qwVideoID));
	cJSON_AddNumberToObject(root,"Result", (double)(data.byResult));
	cJSON_AddNumberToObject(root,"Score", (double)(data.wScore));
	cJSON_AddItemToObject(root, "G1", GetJsonDT_GAMBLE_FACTION_INFO(data.stG1));
	cJSON_AddItemToObject(root, "G2", GetJsonDT_GAMBLE_FACTION_INFO(data.stG2));

	return root;
}

INT32 DT_FACTION_GVG_SINGLE_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stRound.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwVideoID);
	memcpy(pDataBuff + dwOffset, &qwVideoID, sizeof(qwVideoID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byResult);
	memcpy(pDataBuff + dwOffset, &byResult, sizeof(byResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wScore);
	memcpy(pDataBuff + dwOffset, &wScore, sizeof(wScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stG1.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stG2.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_GVG_SINGLE_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stRound.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				if(sizeof(qwVideoID) >= pstIndex->dwContextLen)
				{
					memcpy(&qwVideoID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwVideoID, 0, sizeof(qwVideoID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResult, 0, sizeof(byResult));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wScore) >= pstIndex->dwContextLen)
				{
					memcpy(&wScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wScore, 0, sizeof(wScore));
				}
			}
			break;
		case 5:
			{
				stG1.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stG2.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_SIMPLE_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_SIMPLE_GVG_LOG *pstIn = (DT_FACTION_SIMPLE_GVG_LOG*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID1))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID2))
		return -1;

	if(-1 == EncodeDT_GVG_ROUND(&pstIn->stRound, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwVideoID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLogResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byGvGResult))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAddScore))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_SIMPLE_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_SIMPLE_GVG_LOG *pstOut = (DT_FACTION_SIMPLE_GVG_LOG*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID1))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID2))
		return -1;

	if(-1 == DecodeDT_GVG_ROUND(&pstOut->stRound, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwVideoID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLogResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byGvGResult))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAddScore))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_SIMPLE_GVG_LOG(DT_FACTION_SIMPLE_GVG_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionID1", (double)(data.dwFactionID1));
	cJSON_AddNumberToObject(root,"FactionID2", (double)(data.dwFactionID2));
	cJSON_AddItemToObject(root, "Round", GetJsonDT_GVG_ROUND(data.stRound));
	cJSON_AddNumberToObject(root,"VideoID", (double)(data.qwVideoID));
	cJSON_AddNumberToObject(root,"LogResult", (double)(data.byLogResult));
	cJSON_AddNumberToObject(root,"GvGResult", (double)(data.byGvGResult));
	cJSON_AddNumberToObject(root,"AddScore", (double)(data.wAddScore));

	return root;
}

INT32 DT_FACTION_SIMPLE_GVG_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionID1);
	memcpy(pDataBuff + dwOffset, &dwFactionID1, sizeof(dwFactionID1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwFactionID2);
	memcpy(pDataBuff + dwOffset, &dwFactionID2, sizeof(dwFactionID2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stRound.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwVideoID);
	memcpy(pDataBuff + dwOffset, &qwVideoID, sizeof(qwVideoID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byLogResult);
	memcpy(pDataBuff + dwOffset, &byLogResult, sizeof(byLogResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byGvGResult);
	memcpy(pDataBuff + dwOffset, &byGvGResult, sizeof(byGvGResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wAddScore);
	memcpy(pDataBuff + dwOffset, &wAddScore, sizeof(wAddScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_SIMPLE_GVG_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionID1) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID1, 0, sizeof(dwFactionID1));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwFactionID2) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID2, 0, sizeof(dwFactionID2));
				}
			}
			break;
		case 3:
			{
				stRound.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				if(sizeof(qwVideoID) >= pstIndex->dwContextLen)
				{
					memcpy(&qwVideoID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwVideoID, 0, sizeof(qwVideoID));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byLogResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byLogResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLogResult, 0, sizeof(byLogResult));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byGvGResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byGvGResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGvGResult, 0, sizeof(byGvGResult));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wAddScore) >= pstIndex->dwContextLen)
				{
					memcpy(&wAddScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAddScore, 0, sizeof(wAddScore));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_GVG_LOG_LIST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_LOG_LIST *pstIn = (DT_FACTION_GVG_LOG_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wLogCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_LOG_CNT; i++)
	{
		if(i >= (INT32)pstIn->wLogCnt)
			break;
		if(-1 == EncodeDT_FACTION_GVG_SINGLE_LOG(&pstIn->astLogs[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddWord(pstIn->wSessionID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_GVG_LOG_LIST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_LOG_LIST *pstOut = (DT_FACTION_GVG_LOG_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wLogCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_LOG_CNT; i++)
	{
		if(i >= (INT32)pstOut->wLogCnt)
			break;
		if(-1 == DecodeDT_FACTION_GVG_SINGLE_LOG(&pstOut->astLogs[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelWord(pstOut->wSessionID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_GVG_LOG_LIST(DT_FACTION_GVG_LOG_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LogCnt", (double)(data.wLogCnt));
	cJSON *Logs = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "Logs", Logs);
	for( UINT32 dwIndex=0; dwIndex<data.wLogCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(Logs, " ", GetJsonDT_FACTION_GVG_SINGLE_LOG(data.astLogs[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"SessionID", (double)(data.wSessionID));

	return root;
}

INT32 DT_FACTION_GVG_LOG_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wLogCnt);
	memcpy(pDataBuff + dwOffset, &wLogCnt, sizeof(wLogCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wLogCnt > MAX_GVG_LOG_CNT)
	{
		wLogCnt = MAX_GVG_LOG_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wLogCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wLogCnt; i++)
	{
		dwContextLenTmp += astLogs[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wSessionID);
	memcpy(pDataBuff + dwOffset, &wSessionID, sizeof(wSessionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_GVG_LOG_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wLogCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wLogCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLogCnt, 0, sizeof(wLogCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wLogCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_LOG_CNT ? wArrNum : MAX_GVG_LOG_CNT;
					wLogCnt = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astLogs[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astLogs, 0, sizeof(astLogs));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astLogs, 0, sizeof(astLogs));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wSessionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSessionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSessionID, 0, sizeof(wSessionID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_SIMPLE_GVG_LOG_LIST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_SIMPLE_GVG_LOG_LIST *pstIn = (DT_FACTION_SIMPLE_GVG_LOG_LIST*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLogCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_SIMPLE_LOG_CNT; i++)
	{
		if(i >= (INT32)pstIn->wLogCnt)
			break;
		if(-1 == EncodeDT_FACTION_SIMPLE_GVG_LOG(&pstIn->astLogs[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_SIMPLE_GVG_LOG_LIST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_SIMPLE_GVG_LOG_LIST *pstOut = (DT_FACTION_SIMPLE_GVG_LOG_LIST*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLogCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_SIMPLE_LOG_CNT; i++)
	{
		if(i >= (INT32)pstOut->wLogCnt)
			break;
		if(-1 == DecodeDT_FACTION_SIMPLE_GVG_LOG(&pstOut->astLogs[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_SIMPLE_GVG_LOG_LIST(DT_FACTION_SIMPLE_GVG_LOG_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));
	cJSON_AddNumberToObject(root,"LogCnt", (double)(data.wLogCnt));
	cJSON *Logs = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "Logs", Logs);
	for( UINT32 dwIndex=0; dwIndex<data.wLogCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(Logs, " ", GetJsonDT_FACTION_SIMPLE_GVG_LOG(data.astLogs[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_SIMPLE_GVG_LOG_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLogCnt);
	memcpy(pDataBuff + dwOffset, &wLogCnt, sizeof(wLogCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(wLogCnt > MAX_GVG_SIMPLE_LOG_CNT)
	{
		wLogCnt = MAX_GVG_SIMPLE_LOG_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wLogCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wLogCnt; i++)
	{
		dwContextLenTmp += astLogs[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_SIMPLE_GVG_LOG_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLogCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wLogCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLogCnt, 0, sizeof(wLogCnt));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wLogCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_SIMPLE_LOG_CNT ? wArrNum : MAX_GVG_SIMPLE_LOG_CNT;
					wLogCnt = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astLogs[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astLogs, 0, sizeof(astLogs));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astLogs, 0, sizeof(astLogs));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_LIST_SIMPLE_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LIST_SIMPLE_GVG_LOG *pstIn = (DT_FACTION_LIST_SIMPLE_GVG_LOG*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->wFactionCnt)
			break;
		if(-1 == EncodeDT_FACTION_SIMPLE_GVG_LOG_LIST(&pstIn->astLogList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_LIST_SIMPLE_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LIST_SIMPLE_GVG_LOG *pstOut = (DT_FACTION_LIST_SIMPLE_GVG_LOG*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->wFactionCnt)
			break;
		if(-1 == DecodeDT_FACTION_SIMPLE_GVG_LOG_LIST(&pstOut->astLogList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_LIST_SIMPLE_GVG_LOG(DT_FACTION_LIST_SIMPLE_GVG_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.wFactionCnt));
	cJSON *LogList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "LogList", LogList);
	for( UINT32 dwIndex=0; dwIndex<data.wFactionCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(LogList, " ", GetJsonDT_FACTION_SIMPLE_GVG_LOG_LIST(data.astLogList[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_LIST_SIMPLE_GVG_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wFactionCnt);
	memcpy(pDataBuff + dwOffset, &wFactionCnt, sizeof(wFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wFactionCnt > MAX_GVG_ARENA_FACTION_CNT)
	{
		wFactionCnt = MAX_GVG_ARENA_FACTION_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wFactionCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wFactionCnt; i++)
	{
		dwContextLenTmp += astLogList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_LIST_SIMPLE_GVG_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFactionCnt, 0, sizeof(wFactionCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wFactionCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_ARENA_FACTION_CNT ? wArrNum : MAX_GVG_ARENA_FACTION_CNT;
					wFactionCnt = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astLogList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astLogList, 0, sizeof(astLogList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astLogList, 0, sizeof(astLogList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_LOG_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_GVG_LOG_FACTION_INFO *pstIn = (DT_GVG_LOG_FACTION_INFO*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wFactionIconID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionName, sizeof(pstIn->aszFactionName)))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszHeadName, sizeof(pstIn->aszHeadName)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwScore))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wFactionLevel))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSumPower))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wJoinNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_LOG_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_GVG_LOG_FACTION_INFO *pstOut = (DT_GVG_LOG_FACTION_INFO*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wFactionIconID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionName, sizeof(pstOut->aszFactionName)))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszHeadName, sizeof(pstOut->aszHeadName)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwScore))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wFactionLevel))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSumPower))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wJoinNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_LOG_FACTION_INFO(DT_GVG_LOG_FACTION_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));
	cJSON_AddNumberToObject(root,"FactionIconID", (double)(data.wFactionIconID));
	cJSON_AddStringToObject(root,"FactionName", data.aszFactionName );
	cJSON_AddStringToObject(root,"HeadName", data.aszHeadName );
	cJSON_AddNumberToObject(root,"Score", (double)(data.dwScore));
	cJSON_AddNumberToObject(root,"FactionLevel", (double)(data.wFactionLevel));
	cJSON_AddNumberToObject(root,"SumPower", (double)(data.qwSumPower));
	cJSON_AddNumberToObject(root,"JoinNum", (double)(data.wJoinNum));

	return root;
}

INT32 DT_GVG_LOG_FACTION_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wFactionIconID);
	memcpy(pDataBuff + dwOffset, &wFactionIconID, sizeof(wFactionIconID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszFactionName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionName, sizeof(aszFactionName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszHeadName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszHeadName, sizeof(aszHeadName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwScore);
	memcpy(pDataBuff + dwOffset, &dwScore, sizeof(dwScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wFactionLevel);
	memcpy(pDataBuff + dwOffset, &wFactionLevel, sizeof(wFactionLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwSumPower);
	memcpy(pDataBuff + dwOffset, &qwSumPower, sizeof(qwSumPower));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wJoinNum);
	memcpy(pDataBuff + dwOffset, &wJoinNum, sizeof(wJoinNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_LOG_FACTION_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wFactionIconID) >= pstIndex->dwContextLen)
				{
					memcpy(&wFactionIconID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFactionIconID, 0, sizeof(wFactionIconID));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionName) >= dwContextLen) && (wArrNum <= MAX_FACTION_NUM))
				{
					memcpy(&aszFactionName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionName, 0, sizeof(aszFactionName));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszHeadName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszHeadName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszHeadName, 0, sizeof(aszHeadName));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwScore) >= pstIndex->dwContextLen)
				{
					memcpy(&dwScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwScore, 0, sizeof(dwScore));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wFactionLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wFactionLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFactionLevel, 0, sizeof(wFactionLevel));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwSumPower) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSumPower, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSumPower, 0, sizeof(qwSumPower));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wJoinNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wJoinNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wJoinNum, 0, sizeof(wJoinNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_LOG *pstIn = (DT_FACTION_GVG_LOG*)pHost;

	if(-1 == EncodeDT_GVG_LOG_FACTION_INFO(&pstIn->stFlag, poNetData))
		return -1;

	if(-1 == EncodeDT_FACTION_GVG_LOG_LIST(&pstIn->stLogList, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_LOG *pstOut = (DT_FACTION_GVG_LOG*)pHost;

	if(-1 == DecodeDT_GVG_LOG_FACTION_INFO(&pstOut->stFlag, poNetData))
		return -1;

	if(-1 == DecodeDT_FACTION_GVG_LOG_LIST(&pstOut->stLogList, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_GVG_LOG(DT_FACTION_GVG_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "Flag", GetJsonDT_GVG_LOG_FACTION_INFO(data.stFlag));
	cJSON_AddItemToObject(root, "LogList", GetJsonDT_FACTION_GVG_LOG_LIST(data.stLogList));

	return root;
}

INT32 DT_FACTION_GVG_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stFlag.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stLogList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_GVG_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stFlag.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stLogList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_GVG_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_DATA *pstIn = (DT_FACTION_GVG_DATA*)pHost;

	if(-1 == EncodeDT_FACTION_GVG_LOG_LIST(&pstIn->stGvGLogList, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_FORMATION_DATA(&pstIn->stGvGFormation, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwGVGFactionFunds))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSumPower))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_GVG_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_GVG_DATA *pstOut = (DT_FACTION_GVG_DATA*)pHost;

	if(-1 == DecodeDT_FACTION_GVG_LOG_LIST(&pstOut->stGvGLogList, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_FORMATION_DATA(&pstOut->stGvGFormation, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwGVGFactionFunds))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSumPower))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_GVG_DATA(DT_FACTION_GVG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "GvGLogList", GetJsonDT_FACTION_GVG_LOG_LIST(data.stGvGLogList));
	cJSON_AddItemToObject(root, "GvGFormation", GetJsonDT_GVG_FORMATION_DATA(data.stGvGFormation));
	cJSON_AddNumberToObject(root,"GVGFactionFunds", (double)(data.qwGVGFactionFunds));
	cJSON_AddNumberToObject(root,"SumPower", (double)(data.qwSumPower));

	return root;
}

INT32 DT_FACTION_GVG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stGvGLogList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stGvGFormation.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwGVGFactionFunds);
	memcpy(pDataBuff + dwOffset, &qwGVGFactionFunds, sizeof(qwGVGFactionFunds));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwSumPower);
	memcpy(pDataBuff + dwOffset, &qwSumPower, sizeof(qwSumPower));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_GVG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stGvGLogList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stGvGFormation.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(qwGVGFactionFunds) >= pstIndex->dwContextLen)
				{
					memcpy(&qwGVGFactionFunds, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwGVGFactionFunds, 0, sizeof(qwGVGFactionFunds));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwSumPower) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSumPower, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSumPower, 0, sizeof(qwSumPower));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_FORMATION_PLAYER_INFO(void *pHost, CNetData* poNetData)
{
	DT_GVG_FORMATION_PLAYER_INFO *pstIn = (DT_GVG_FORMATION_PLAYER_INFO*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszPlayerName, sizeof(pstIn->aszPlayerName)))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPlayerJob))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKillCombo))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_FORMATION_PLAYER_INFO(void *pHost, CNetData* poNetData)
{
	DT_GVG_FORMATION_PLAYER_INFO *pstOut = (DT_GVG_FORMATION_PLAYER_INFO*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszPlayerName, sizeof(pstOut->aszPlayerName)))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPlayerJob))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKillCombo))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_FORMATION_PLAYER_INFO(DT_GVG_FORMATION_PLAYER_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddStringToObject(root,"PlayerName", data.aszPlayerName );
	cJSON_AddNumberToObject(root,"PlayerJob", (double)(data.byPlayerJob));
	cJSON_AddNumberToObject(root,"KillCombo", (double)(data.byKillCombo));

	return root;
}

INT32 DT_GVG_FORMATION_PLAYER_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(aszPlayerName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszPlayerName, sizeof(aszPlayerName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byPlayerJob);
	memcpy(pDataBuff + dwOffset, &byPlayerJob, sizeof(byPlayerJob));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byKillCombo);
	memcpy(pDataBuff + dwOffset, &byKillCombo, sizeof(byKillCombo));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_FORMATION_PLAYER_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszPlayerName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszPlayerName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszPlayerName, 0, sizeof(aszPlayerName));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byPlayerJob) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerJob, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerJob, 0, sizeof(byPlayerJob));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byKillCombo) >= pstIndex->dwContextLen)
				{
					memcpy(&byKillCombo, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKillCombo, 0, sizeof(byKillCombo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_FORMATION_PLAYER_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_FORMATION_PLAYER_LIST *pstIn = (DT_GVG_FORMATION_PLAYER_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPlayerCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_FORMATION_PLAYER_CNT; i++)
	{
		if(i >= (INT32)pstIn->byPlayerCnt)
			break;
		if(-1 == EncodeDT_GVG_FORMATION_PLAYER_INFO(&pstIn->astPlayerList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_FORMATION_PLAYER_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_FORMATION_PLAYER_LIST *pstOut = (DT_GVG_FORMATION_PLAYER_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPlayerCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_FORMATION_PLAYER_CNT; i++)
	{
		if(i >= (INT32)pstOut->byPlayerCnt)
			break;
		if(-1 == DecodeDT_GVG_FORMATION_PLAYER_INFO(&pstOut->astPlayerList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_FORMATION_PLAYER_LIST(DT_GVG_FORMATION_PLAYER_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerCnt", (double)(data.byPlayerCnt));
	cJSON *PlayerList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PlayerList", PlayerList);
	for( UINT32 dwIndex=0; dwIndex<data.byPlayerCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(PlayerList, " ", GetJsonDT_GVG_FORMATION_PLAYER_INFO(data.astPlayerList[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_FORMATION_PLAYER_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPlayerCnt);
	memcpy(pDataBuff + dwOffset, &byPlayerCnt, sizeof(byPlayerCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byPlayerCnt > MAX_GVG_FORMATION_PLAYER_CNT)
	{
		byPlayerCnt = MAX_GVG_FORMATION_PLAYER_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byPlayerCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byPlayerCnt; i++)
	{
		dwContextLenTmp += astPlayerList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_FORMATION_PLAYER_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPlayerCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerCnt, 0, sizeof(byPlayerCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byPlayerCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_FORMATION_PLAYER_CNT ? wArrNum : MAX_GVG_FORMATION_PLAYER_CNT;
					byPlayerCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPlayerList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPlayerList, 0, sizeof(astPlayerList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPlayerList, 0, sizeof(astPlayerList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DOORSTRIBUTE_LEVEL_DATA(void *pHost, CNetData* poNetData)
{
	DT_DOORSTRIBUTE_LEVEL_DATA *pstIn = (DT_DOORSTRIBUTE_LEVEL_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byCrownNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySunNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byMoonNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byStarNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwNextUpgradeNeed))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wDoorsTributeLevel))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DOORSTRIBUTE_LEVEL_DATA(void *pHost, CNetData* poNetData)
{
	DT_DOORSTRIBUTE_LEVEL_DATA *pstOut = (DT_DOORSTRIBUTE_LEVEL_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byCrownNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySunNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byMoonNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byStarNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwNextUpgradeNeed))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wDoorsTributeLevel))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DOORSTRIBUTE_LEVEL_DATA(DT_DOORSTRIBUTE_LEVEL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"CrownNum", (double)(data.byCrownNum));
	cJSON_AddNumberToObject(root,"SunNum", (double)(data.bySunNum));
	cJSON_AddNumberToObject(root,"MoonNum", (double)(data.byMoonNum));
	cJSON_AddNumberToObject(root,"StarNum", (double)(data.byStarNum));
	cJSON_AddNumberToObject(root,"NextUpgradeNeed", (double)(data.dwNextUpgradeNeed));
	cJSON_AddNumberToObject(root,"DoorsTributeLevel", (double)(data.wDoorsTributeLevel));

	return root;
}

INT32 DT_DOORSTRIBUTE_LEVEL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byCrownNum);
	memcpy(pDataBuff + dwOffset, &byCrownNum, sizeof(byCrownNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(bySunNum);
	memcpy(pDataBuff + dwOffset, &bySunNum, sizeof(bySunNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byMoonNum);
	memcpy(pDataBuff + dwOffset, &byMoonNum, sizeof(byMoonNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byStarNum);
	memcpy(pDataBuff + dwOffset, &byStarNum, sizeof(byStarNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwNextUpgradeNeed);
	memcpy(pDataBuff + dwOffset, &dwNextUpgradeNeed, sizeof(dwNextUpgradeNeed));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wDoorsTributeLevel);
	memcpy(pDataBuff + dwOffset, &wDoorsTributeLevel, sizeof(wDoorsTributeLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DOORSTRIBUTE_LEVEL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byCrownNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byCrownNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCrownNum, 0, sizeof(byCrownNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(bySunNum) >= pstIndex->dwContextLen)
				{
					memcpy(&bySunNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySunNum, 0, sizeof(bySunNum));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byMoonNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byMoonNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMoonNum, 0, sizeof(byMoonNum));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byStarNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byStarNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStarNum, 0, sizeof(byStarNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwNextUpgradeNeed) >= pstIndex->dwContextLen)
				{
					memcpy(&dwNextUpgradeNeed, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwNextUpgradeNeed, 0, sizeof(dwNextUpgradeNeed));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wDoorsTributeLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wDoorsTributeLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDoorsTributeLevel, 0, sizeof(wDoorsTributeLevel));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DOORSTRIBUTE_LEVE_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_DOORSTRIBUTE_LEVE_DATA_LST *pstIn = (DT_DOORSTRIBUTE_LEVE_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wDoorsTributeNum))
		return -1;

	INT32 i;
	for(i = 0; i < DT_FACTION_PLAYER_NUM; i++)
	{
		if(i >= (INT32)pstIn->wDoorsTributeNum)
			break;
		if(-1 == EncodeDT_DOORSTRIBUTE_LEVEL_DATA(&pstIn->astDoorsTributeInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DOORSTRIBUTE_LEVE_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_DOORSTRIBUTE_LEVE_DATA_LST *pstOut = (DT_DOORSTRIBUTE_LEVE_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wDoorsTributeNum))
		return -1;

	INT32 i;
	for(i = 0; i < DT_FACTION_PLAYER_NUM; i++)
	{
		if(i >= (INT32)pstOut->wDoorsTributeNum)
			break;
		if(-1 == DecodeDT_DOORSTRIBUTE_LEVEL_DATA(&pstOut->astDoorsTributeInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DOORSTRIBUTE_LEVE_DATA_LST(DT_DOORSTRIBUTE_LEVE_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"DoorsTributeNum", (double)(data.wDoorsTributeNum));
	cJSON *DoorsTributeInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "DoorsTributeInfo", DoorsTributeInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wDoorsTributeNum; ++dwIndex)
	{
		cJSON_AddItemToObject(DoorsTributeInfo, " ", GetJsonDT_DOORSTRIBUTE_LEVEL_DATA(data.astDoorsTributeInfo[dwIndex]));
	}

	return root;
}

INT32 DT_DOORSTRIBUTE_LEVE_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wDoorsTributeNum);
	memcpy(pDataBuff + dwOffset, &wDoorsTributeNum, sizeof(wDoorsTributeNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wDoorsTributeNum > DT_FACTION_PLAYER_NUM)
	{
		wDoorsTributeNum = DT_FACTION_PLAYER_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wDoorsTributeNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wDoorsTributeNum; i++)
	{
		dwContextLenTmp += astDoorsTributeInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DOORSTRIBUTE_LEVE_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wDoorsTributeNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wDoorsTributeNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wDoorsTributeNum, 0, sizeof(wDoorsTributeNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wDoorsTributeNum)
				{
					wArrNum = wArrNum <= DT_FACTION_PLAYER_NUM ? wArrNum : DT_FACTION_PLAYER_NUM;
					wDoorsTributeNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astDoorsTributeInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astDoorsTributeInfo, 0, sizeof(astDoorsTributeInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astDoorsTributeInfo, 0, sizeof(astDoorsTributeInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_MEMBER_INFO(void *pHost, CNetData* poNetData)
{
	DT_FACTION_MEMBER_INFO *pstIn = (DT_FACTION_MEMBER_INFO*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroKindID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszPlayerName, sizeof(pstIn->aszPlayerName)))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPlayerLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPlayerJob))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPower))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRank))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_MEMBER_INFO(void *pHost, CNetData* poNetData)
{
	DT_FACTION_MEMBER_INFO *pstOut = (DT_FACTION_MEMBER_INFO*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroKindID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszPlayerName, sizeof(pstOut->aszPlayerName)))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPlayerLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPlayerJob))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPower))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRank))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_MEMBER_INFO(DT_FACTION_MEMBER_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddNumberToObject(root,"HeroKindID", (double)(data.wHeroKindID));
	cJSON_AddStringToObject(root,"PlayerName", data.aszPlayerName );
	cJSON_AddNumberToObject(root,"PlayerLevel", (double)(data.wPlayerLevel));
	cJSON_AddNumberToObject(root,"PlayerJob", (double)(data.byPlayerJob));
	cJSON_AddNumberToObject(root,"Power", (double)(data.dwPower));
	cJSON_AddNumberToObject(root,"Rank", (double)(data.dwRank));

	return root;
}

INT32 DT_FACTION_MEMBER_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wHeroKindID);
	memcpy(pDataBuff + dwOffset, &wHeroKindID, sizeof(wHeroKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszPlayerName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszPlayerName, sizeof(aszPlayerName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wPlayerLevel);
	memcpy(pDataBuff + dwOffset, &wPlayerLevel, sizeof(wPlayerLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byPlayerJob);
	memcpy(pDataBuff + dwOffset, &byPlayerJob, sizeof(byPlayerJob));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwPower);
	memcpy(pDataBuff + dwOffset, &dwPower, sizeof(dwPower));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwRank);
	memcpy(pDataBuff + dwOffset, &dwRank, sizeof(dwRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_MEMBER_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wHeroKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroKindID, 0, sizeof(wHeroKindID));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszPlayerName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszPlayerName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszPlayerName, 0, sizeof(aszPlayerName));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wPlayerLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wPlayerLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPlayerLevel, 0, sizeof(wPlayerLevel));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byPlayerJob) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerJob, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerJob, 0, sizeof(byPlayerJob));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwPower) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPower, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPower, 0, sizeof(dwPower));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRank, 0, sizeof(dwRank));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_MEMBER_INFO_LIST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_MEMBER_INFO_LIST *pstIn = (DT_FACTION_MEMBER_INFO_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byMemberCnt))
		return -1;

	INT32 i;
	for(i = 0; i < DT_FACTION_PLAYER_NUM; i++)
	{
		if(i >= (INT32)pstIn->byMemberCnt)
			break;
		if(-1 == EncodeDT_FACTION_MEMBER_INFO(&pstIn->astMembers[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_MEMBER_INFO_LIST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_MEMBER_INFO_LIST *pstOut = (DT_FACTION_MEMBER_INFO_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byMemberCnt))
		return -1;

	INT32 i;
	for(i = 0; i < DT_FACTION_PLAYER_NUM; i++)
	{
		if(i >= (INT32)pstOut->byMemberCnt)
			break;
		if(-1 == DecodeDT_FACTION_MEMBER_INFO(&pstOut->astMembers[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_MEMBER_INFO_LIST(DT_FACTION_MEMBER_INFO_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MemberCnt", (double)(data.byMemberCnt));
	cJSON *Members = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "Members", Members);
	for( UINT32 dwIndex=0; dwIndex<data.byMemberCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(Members, " ", GetJsonDT_FACTION_MEMBER_INFO(data.astMembers[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_MEMBER_INFO_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byMemberCnt);
	memcpy(pDataBuff + dwOffset, &byMemberCnt, sizeof(byMemberCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byMemberCnt > DT_FACTION_PLAYER_NUM)
	{
		byMemberCnt = DT_FACTION_PLAYER_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byMemberCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byMemberCnt; i++)
	{
		dwContextLenTmp += astMembers[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_MEMBER_INFO_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byMemberCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byMemberCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMemberCnt, 0, sizeof(byMemberCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byMemberCnt)
				{
					wArrNum = wArrNum <= DT_FACTION_PLAYER_NUM ? wArrNum : DT_FACTION_PLAYER_NUM;
					byMemberCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astMembers[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astMembers, 0, sizeof(astMembers));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astMembers, 0, sizeof(astMembers));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_FACTION(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION *pstIn = (DT_GVG_FACTION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wZoneID))
		return -1;

	if(-1 == EncodeDT_FACTION_BASE_DATA_CLI2(&pstIn->stBaseData, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byJoinCnt))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSumPower))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wScore))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGambleCnt))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byWinCnt))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLoseCnt))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wOriZoneID))
		return -1;

	if(-1 == EncodeDT_FACTION_MEMBER_INFO_LIST(&pstIn->stMembers, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_FACTION(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION *pstOut = (DT_GVG_FACTION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wZoneID))
		return -1;

	if(-1 == DecodeDT_FACTION_BASE_DATA_CLI2(&pstOut->stBaseData, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byJoinCnt))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSumPower))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wScore))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGambleCnt))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byWinCnt))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLoseCnt))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wOriZoneID))
		return -1;

	if(-1 == DecodeDT_FACTION_MEMBER_INFO_LIST(&pstOut->stMembers, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_FACTION(DT_GVG_FACTION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.wZoneID));
	cJSON_AddItemToObject(root, "BaseData", GetJsonDT_FACTION_BASE_DATA_CLI2(data.stBaseData));
	cJSON_AddNumberToObject(root,"JoinCnt", (double)(data.byJoinCnt));
	cJSON_AddNumberToObject(root,"SumPower", (double)(data.qwSumPower));
	cJSON_AddNumberToObject(root,"Score", (double)(data.wScore));
	cJSON_AddNumberToObject(root,"GambleCnt", (double)(data.dwGambleCnt));
	cJSON_AddNumberToObject(root,"WinCnt", (double)(data.byWinCnt));
	cJSON_AddNumberToObject(root,"LoseCnt", (double)(data.byLoseCnt));
	cJSON_AddNumberToObject(root,"OriZoneID", (double)(data.wOriZoneID));
	cJSON_AddItemToObject(root, "Members", GetJsonDT_FACTION_MEMBER_INFO_LIST(data.stMembers));

	return root;
}

INT32 DT_GVG_FACTION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wZoneID);
	memcpy(pDataBuff + dwOffset, &wZoneID, sizeof(wZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byJoinCnt);
	memcpy(pDataBuff + dwOffset, &byJoinCnt, sizeof(byJoinCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(qwSumPower);
	memcpy(pDataBuff + dwOffset, &qwSumPower, sizeof(qwSumPower));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wScore);
	memcpy(pDataBuff + dwOffset, &wScore, sizeof(wScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(dwGambleCnt);
	memcpy(pDataBuff + dwOffset, &dwGambleCnt, sizeof(dwGambleCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byWinCnt);
	memcpy(pDataBuff + dwOffset, &byWinCnt, sizeof(byWinCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(byLoseCnt);
	memcpy(pDataBuff + dwOffset, &byLoseCnt, sizeof(byLoseCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(wOriZoneID);
	memcpy(pDataBuff + dwOffset, &wOriZoneID, sizeof(wOriZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = stMembers.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_FACTION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&wZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wZoneID, 0, sizeof(wZoneID));
				}
			}
			break;
		case 2:
			{
				stBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				if(sizeof(byJoinCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byJoinCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byJoinCnt, 0, sizeof(byJoinCnt));
				}
			}
			break;
		case 8:
			{
				if(sizeof(qwSumPower) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSumPower, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSumPower, 0, sizeof(qwSumPower));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wScore) >= pstIndex->dwContextLen)
				{
					memcpy(&wScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wScore, 0, sizeof(wScore));
				}
			}
			break;
		case 10:
			{
				if(sizeof(dwGambleCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGambleCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGambleCnt, 0, sizeof(dwGambleCnt));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byWinCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byWinCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWinCnt, 0, sizeof(byWinCnt));
				}
			}
			break;
		case 12:
			{
				if(sizeof(byLoseCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byLoseCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLoseCnt, 0, sizeof(byLoseCnt));
				}
			}
			break;
		case 13:
			{
				if(sizeof(wOriZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&wOriZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wOriZoneID, 0, sizeof(wOriZoneID));
				}
			}
			break;
		case 14:
			{
				stMembers.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PK_FACTION(void *pHost, CNetData* poNetData)
{
	DT_PK_FACTION *pstIn = (DT_PK_FACTION*)pHost;

	if(-1 == EncodeDT_GVG_FACTION(&pstIn->stBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_FORMATION_DATA(&pstIn->stFormation, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_FORMATION_PLAYER_LIST(&pstIn->stPlayerList, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PK_FACTION(void *pHost, CNetData* poNetData)
{
	DT_PK_FACTION *pstOut = (DT_PK_FACTION*)pHost;

	if(-1 == DecodeDT_GVG_FACTION(&pstOut->stBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_FORMATION_DATA(&pstOut->stFormation, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_FORMATION_PLAYER_LIST(&pstOut->stPlayerList, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PK_FACTION(DT_PK_FACTION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "BaseData", GetJsonDT_GVG_FACTION(data.stBaseData));
	cJSON_AddItemToObject(root, "Formation", GetJsonDT_GVG_FORMATION_DATA(data.stFormation));
	cJSON_AddItemToObject(root, "PlayerList", GetJsonDT_GVG_FORMATION_PLAYER_LIST(data.stPlayerList));

	return root;
}

INT32 DT_PK_FACTION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stFormation.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stPlayerList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PK_FACTION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stFormation.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stPlayerList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PVP_VIDEO_DATA(void *pHost, CNetData* poNetData)
{
	DT_PVP_VIDEO_DATA *pstIn = (DT_PVP_VIDEO_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwVideoID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwVideoTime))
		return -1;

	if(-1 == EncodeDT_BATTLE_DATA3(&pstIn->stPvPVideo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PVP_VIDEO_DATA(void *pHost, CNetData* poNetData)
{
	DT_PVP_VIDEO_DATA *pstOut = (DT_PVP_VIDEO_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwVideoID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwVideoTime))
		return -1;

	if(-1 == DecodeDT_BATTLE_DATA3(&pstOut->stPvPVideo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PVP_VIDEO_DATA(DT_PVP_VIDEO_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"VideoID", (double)(data.dwVideoID));
	cJSON_AddNumberToObject(root,"VideoTime", (double)(data.qwVideoTime));
	cJSON_AddItemToObject(root, "PvPVideo", GetJsonDT_BATTLE_DATA3(data.stPvPVideo));

	return root;
}

INT32 DT_PVP_VIDEO_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwVideoID);
	memcpy(pDataBuff + dwOffset, &dwVideoID, sizeof(dwVideoID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwVideoTime);
	memcpy(pDataBuff + dwOffset, &qwVideoTime, sizeof(qwVideoTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stPvPVideo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PVP_VIDEO_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwVideoID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwVideoID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwVideoID, 0, sizeof(dwVideoID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwVideoTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwVideoTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwVideoTime, 0, sizeof(qwVideoTime));
				}
			}
			break;
		case 3:
			{
				stPvPVideo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_MVP(void *pHost, CNetData* poNetData)
{
	DT_GVG_MVP *pstIn = (DT_GVG_MVP*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFactionIconID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszPlayerName, sizeof(pstIn->aszPlayerName)))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKillCombo))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byScore))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwAward))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byWinOrLose))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_MVP(void *pHost, CNetData* poNetData)
{
	DT_GVG_MVP *pstOut = (DT_GVG_MVP*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFactionIconID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszPlayerName, sizeof(pstOut->aszPlayerName)))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKillCombo))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byScore))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwAward))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byWinOrLose))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_MVP(DT_GVG_MVP &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionIconID", (double)(data.byFactionIconID));
	cJSON_AddStringToObject(root,"PlayerName", data.aszPlayerName );
	cJSON_AddNumberToObject(root,"KillCombo", (double)(data.byKillCombo));
	cJSON_AddNumberToObject(root,"Score", (double)(data.byScore));
	cJSON_AddNumberToObject(root,"Award", (double)(data.dwAward));
	cJSON_AddNumberToObject(root,"WinOrLose", (double)(data.byWinOrLose));

	return root;
}

INT32 DT_GVG_MVP::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFactionIconID);
	memcpy(pDataBuff + dwOffset, &byFactionIconID, sizeof(byFactionIconID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(aszPlayerName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszPlayerName, sizeof(aszPlayerName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byKillCombo);
	memcpy(pDataBuff + dwOffset, &byKillCombo, sizeof(byKillCombo));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byScore);
	memcpy(pDataBuff + dwOffset, &byScore, sizeof(byScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwAward);
	memcpy(pDataBuff + dwOffset, &dwAward, sizeof(dwAward));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byWinOrLose);
	memcpy(pDataBuff + dwOffset, &byWinOrLose, sizeof(byWinOrLose));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_MVP::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFactionIconID) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionIconID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionIconID, 0, sizeof(byFactionIconID));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszPlayerName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszPlayerName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszPlayerName, 0, sizeof(aszPlayerName));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byKillCombo) >= pstIndex->dwContextLen)
				{
					memcpy(&byKillCombo, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKillCombo, 0, sizeof(byKillCombo));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byScore) >= pstIndex->dwContextLen)
				{
					memcpy(&byScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byScore, 0, sizeof(byScore));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwAward) >= pstIndex->dwContextLen)
				{
					memcpy(&dwAward, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwAward, 0, sizeof(dwAward));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byWinOrLose) >= pstIndex->dwContextLen)
				{
					memcpy(&byWinOrLose, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWinOrLose, 0, sizeof(byWinOrLose));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_MVP_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_MVP_LIST *pstIn = (DT_GVG_MVP_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byMVPCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_MVP_CNT; i++)
	{
		if(i >= (INT32)pstIn->byMVPCnt)
			break;
		if(-1 == EncodeDT_GVG_MVP(&pstIn->astMVPList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_MVP_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_MVP_LIST *pstOut = (DT_GVG_MVP_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byMVPCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_MVP_CNT; i++)
	{
		if(i >= (INT32)pstOut->byMVPCnt)
			break;
		if(-1 == DecodeDT_GVG_MVP(&pstOut->astMVPList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_MVP_LIST(DT_GVG_MVP_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MVPCnt", (double)(data.byMVPCnt));
	cJSON *MVPList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "MVPList", MVPList);
	for( UINT32 dwIndex=0; dwIndex<data.byMVPCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(MVPList, " ", GetJsonDT_GVG_MVP(data.astMVPList[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_MVP_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byMVPCnt);
	memcpy(pDataBuff + dwOffset, &byMVPCnt, sizeof(byMVPCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byMVPCnt > MAX_GVG_MVP_CNT)
	{
		byMVPCnt = MAX_GVG_MVP_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byMVPCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byMVPCnt; i++)
	{
		dwContextLenTmp += astMVPList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_MVP_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byMVPCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byMVPCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMVPCnt, 0, sizeof(byMVPCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byMVPCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_MVP_CNT ? wArrNum : MAX_GVG_MVP_CNT;
					byMVPCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astMVPList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astMVPList, 0, sizeof(astMVPList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astMVPList, 0, sizeof(astMVPList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_VIDEO_FACTION(void *pHost, CNetData* poNetData)
{
	DT_GVG_VIDEO_FACTION *pstIn = (DT_GVG_VIDEO_FACTION*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wZoneID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFactionIconID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionName, sizeof(pstIn->aszFactionName)))
		return -1;

	if(-1 == EncodeDT_GVG_FORMATION_PLAYER_LIST(&pstIn->stPlayerList, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_VIDEO_FACTION(void *pHost, CNetData* poNetData)
{
	DT_GVG_VIDEO_FACTION *pstOut = (DT_GVG_VIDEO_FACTION*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wZoneID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFactionIconID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionName, sizeof(pstOut->aszFactionName)))
		return -1;

	if(-1 == DecodeDT_GVG_FORMATION_PLAYER_LIST(&pstOut->stPlayerList, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_VIDEO_FACTION(DT_GVG_VIDEO_FACTION &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.wZoneID));
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));
	cJSON_AddNumberToObject(root,"FactionIconID", (double)(data.byFactionIconID));
	cJSON_AddStringToObject(root,"FactionName", data.aszFactionName );
	cJSON_AddItemToObject(root, "PlayerList", GetJsonDT_GVG_FORMATION_PLAYER_LIST(data.stPlayerList));

	return root;
}

INT32 DT_GVG_VIDEO_FACTION::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wZoneID);
	memcpy(pDataBuff + dwOffset, &wZoneID, sizeof(wZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byFactionIconID);
	memcpy(pDataBuff + dwOffset, &byFactionIconID, sizeof(byFactionIconID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(aszFactionName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionName, sizeof(aszFactionName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stPlayerList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_VIDEO_FACTION::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&wZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wZoneID, 0, sizeof(wZoneID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byFactionIconID) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionIconID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionIconID, 0, sizeof(byFactionIconID));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionName) >= dwContextLen) && (wArrNum <= MAX_FACTION_NUM))
				{
					memcpy(&aszFactionName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionName, 0, sizeof(aszFactionName));
				}
			}
			break;
		case 5:
			{
				stPlayerList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_PK_VIDEO(void *pHost, CNetData* poNetData)
{
	DT_GVG_PK_VIDEO *pstIn = (DT_GVG_PK_VIDEO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPlayerIdx1))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPlayerIdx2))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKillCombo1))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKillCombo2))
		return -1;

	if(-1 == EncodeDT_EMPTY_HP_VIDEO(&pstIn->stPKVideo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_PK_VIDEO(void *pHost, CNetData* poNetData)
{
	DT_GVG_PK_VIDEO *pstOut = (DT_GVG_PK_VIDEO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPlayerIdx1))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPlayerIdx2))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKillCombo1))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKillCombo2))
		return -1;

	if(-1 == DecodeDT_EMPTY_HP_VIDEO(&pstOut->stPKVideo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_PK_VIDEO(DT_GVG_PK_VIDEO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerIdx1", (double)(data.byPlayerIdx1));
	cJSON_AddNumberToObject(root,"PlayerIdx2", (double)(data.byPlayerIdx2));
	cJSON_AddNumberToObject(root,"KillCombo1", (double)(data.byKillCombo1));
	cJSON_AddNumberToObject(root,"KillCombo2", (double)(data.byKillCombo2));
	cJSON_AddItemToObject(root, "PKVideo", GetJsonDT_EMPTY_HP_VIDEO(data.stPKVideo));

	return root;
}

INT32 DT_GVG_PK_VIDEO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPlayerIdx1);
	memcpy(pDataBuff + dwOffset, &byPlayerIdx1, sizeof(byPlayerIdx1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byPlayerIdx2);
	memcpy(pDataBuff + dwOffset, &byPlayerIdx2, sizeof(byPlayerIdx2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byKillCombo1);
	memcpy(pDataBuff + dwOffset, &byKillCombo1, sizeof(byKillCombo1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byKillCombo2);
	memcpy(pDataBuff + dwOffset, &byKillCombo2, sizeof(byKillCombo2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stPKVideo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_PK_VIDEO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPlayerIdx1) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerIdx1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerIdx1, 0, sizeof(byPlayerIdx1));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byPlayerIdx2) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerIdx2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerIdx2, 0, sizeof(byPlayerIdx2));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byKillCombo1) >= pstIndex->dwContextLen)
				{
					memcpy(&byKillCombo1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKillCombo1, 0, sizeof(byKillCombo1));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byKillCombo2) >= pstIndex->dwContextLen)
				{
					memcpy(&byKillCombo2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKillCombo2, 0, sizeof(byKillCombo2));
				}
			}
			break;
		case 5:
			{
				stPKVideo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_PK_VIDEO_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_PK_VIDEO_LIST *pstIn = (DT_GVG_PK_VIDEO_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byPKVideoCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_PK_VIDEO_CNT; i++)
	{
		if(i >= (INT32)pstIn->byPKVideoCnt)
			break;
		if(-1 == EncodeDT_GVG_PK_VIDEO(&pstIn->astPKVideoList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_PK_VIDEO_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_PK_VIDEO_LIST *pstOut = (DT_GVG_PK_VIDEO_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byPKVideoCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_PK_VIDEO_CNT; i++)
	{
		if(i >= (INT32)pstOut->byPKVideoCnt)
			break;
		if(-1 == DecodeDT_GVG_PK_VIDEO(&pstOut->astPKVideoList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_PK_VIDEO_LIST(DT_GVG_PK_VIDEO_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PKVideoCnt", (double)(data.byPKVideoCnt));
	cJSON *PKVideoList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PKVideoList", PKVideoList);
	for( UINT32 dwIndex=0; dwIndex<data.byPKVideoCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(PKVideoList, " ", GetJsonDT_GVG_PK_VIDEO(data.astPKVideoList[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_PK_VIDEO_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byPKVideoCnt);
	memcpy(pDataBuff + dwOffset, &byPKVideoCnt, sizeof(byPKVideoCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byPKVideoCnt > MAX_GVG_PK_VIDEO_CNT)
	{
		byPKVideoCnt = MAX_GVG_PK_VIDEO_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byPKVideoCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byPKVideoCnt; i++)
	{
		dwContextLenTmp += astPKVideoList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_PK_VIDEO_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byPKVideoCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byPKVideoCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPKVideoCnt, 0, sizeof(byPKVideoCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byPKVideoCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_PK_VIDEO_CNT ? wArrNum : MAX_GVG_PK_VIDEO_CNT;
					byPKVideoCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPKVideoList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPKVideoList, 0, sizeof(astPKVideoList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPKVideoList, 0, sizeof(astPKVideoList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_VIDEO(void *pHost, CNetData* poNetData)
{
	DT_GVG_VIDEO *pstIn = (DT_GVG_VIDEO*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwVideoID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwTime))
		return -1;

	if(-1 == EncodeDT_GVG_ROUND(&pstIn->stRound, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_VIDEO_FACTION(&pstIn->stG1, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_VIDEO_FACTION(&pstIn->stG2, poNetData))
		return -1;

	if(-1 == EncodeDT_FINAL_ROUND_BATTLE_OBJ_INFO(&pstIn->stFinalRoundInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleResult))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPKVideoCnt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_VIDEO(void *pHost, CNetData* poNetData)
{
	DT_GVG_VIDEO *pstOut = (DT_GVG_VIDEO*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwVideoID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwTime))
		return -1;

	if(-1 == DecodeDT_GVG_ROUND(&pstOut->stRound, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_VIDEO_FACTION(&pstOut->stG1, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_VIDEO_FACTION(&pstOut->stG2, poNetData))
		return -1;

	if(-1 == DecodeDT_FINAL_ROUND_BATTLE_OBJ_INFO(&pstOut->stFinalRoundInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleResult))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPKVideoCnt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_VIDEO(DT_GVG_VIDEO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"VideoID", (double)(data.qwVideoID));
	cJSON_AddNumberToObject(root,"Time", (double)(data.qwTime));
	cJSON_AddItemToObject(root, "Round", GetJsonDT_GVG_ROUND(data.stRound));
	cJSON_AddItemToObject(root, "G1", GetJsonDT_GVG_VIDEO_FACTION(data.stG1));
	cJSON_AddItemToObject(root, "G2", GetJsonDT_GVG_VIDEO_FACTION(data.stG2));
	cJSON_AddItemToObject(root, "FinalRoundInfo", GetJsonDT_FINAL_ROUND_BATTLE_OBJ_INFO(data.stFinalRoundInfo));
	cJSON_AddNumberToObject(root,"BattleResult", (double)(data.byBattleResult));
	cJSON_AddNumberToObject(root,"PKVideoCnt", (double)(data.byPKVideoCnt));

	return root;
}

INT32 DT_GVG_VIDEO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwVideoID);
	memcpy(pDataBuff + dwOffset, &qwVideoID, sizeof(qwVideoID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwTime);
	memcpy(pDataBuff + dwOffset, &qwTime, sizeof(qwTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stRound.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stG1.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stG2.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stFinalRoundInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byBattleResult);
	memcpy(pDataBuff + dwOffset, &byBattleResult, sizeof(byBattleResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byPKVideoCnt);
	memcpy(pDataBuff + dwOffset, &byPKVideoCnt, sizeof(byPKVideoCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_VIDEO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwVideoID) >= pstIndex->dwContextLen)
				{
					memcpy(&qwVideoID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwVideoID, 0, sizeof(qwVideoID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwTime, 0, sizeof(qwTime));
				}
			}
			break;
		case 3:
			{
				stRound.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stG1.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stG2.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stFinalRoundInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				if(sizeof(byBattleResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleResult, 0, sizeof(byBattleResult));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byPKVideoCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byPKVideoCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPKVideoCnt, 0, sizeof(byPKVideoCnt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_ZONE_MEMBER_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_ZONE_MEMBER_DATA *pstIn = (DT_GVG_ZONE_MEMBER_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byZoneCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_ZONE_CNT; i++)
	{
		if(i >= (INT32)pstIn->byZoneCnt)
			break;
		if(-1 == poNetData->AddDword(pstIn->adwZoneIDList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_ZONE_MEMBER_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_ZONE_MEMBER_DATA *pstOut = (DT_GVG_ZONE_MEMBER_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byZoneCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_ZONE_CNT; i++)
	{
		if(i >= (INT32)pstOut->byZoneCnt)
			break;
		if(-1 == poNetData->DelDword(pstOut->adwZoneIDList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_ZONE_MEMBER_DATA(DT_GVG_ZONE_MEMBER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneCnt", (double)(data.byZoneCnt));
	cJSON *ZoneIDList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ZoneIDList", ZoneIDList);
	for( UINT32 dwIndex=0; dwIndex<data.byZoneCnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"ZoneIDList", (double)(data.adwZoneIDList[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_ZONE_MEMBER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byZoneCnt);
	memcpy(pDataBuff + dwOffset, &byZoneCnt, sizeof(byZoneCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(byZoneCnt > MAX_GVG_ARENA_ZONE_CNT)
	{
		byZoneCnt = MAX_GVG_ARENA_ZONE_CNT;
	}
	pstIndex->dwContextLen = byZoneCnt * sizeof(UINT32) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byZoneCnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &adwZoneIDList, byZoneCnt * sizeof(UINT32));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_ZONE_MEMBER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byZoneCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byZoneCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byZoneCnt, 0, sizeof(byZoneCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(adwZoneIDList) >= dwContextLen) && (wArrNum == byZoneCnt) && (wArrNum <= MAX_GVG_ARENA_ZONE_CNT))
				{
					memcpy(&adwZoneIDList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&adwZoneIDList, 0, sizeof(adwZoneIDList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ZONE_FACTION_ID(void *pHost, CNetData* poNetData)
{
	DT_ZONE_FACTION_ID *pstIn = (DT_ZONE_FACTION_ID*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwZoneID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ZONE_FACTION_ID(void *pHost, CNetData* poNetData)
{
	DT_ZONE_FACTION_ID *pstOut = (DT_ZONE_FACTION_ID*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwZoneID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ZONE_FACTION_ID(DT_ZONE_FACTION_ID &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.dwZoneID));
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));

	return root;
}

INT32 DT_ZONE_FACTION_ID::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwZoneID);
	memcpy(pDataBuff + dwOffset, &dwZoneID, sizeof(dwZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ZONE_FACTION_ID::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwZoneID, 0, sizeof(dwZoneID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_DIFF_ZONE_FACTION_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_DIFF_ZONE_FACTION_ID_LIST *pstIn = (DT_DIFF_ZONE_FACTION_ID_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byFactionCnt)
			break;
		if(-1 == EncodeDT_ZONE_FACTION_ID(&pstIn->astFactionList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_DIFF_ZONE_FACTION_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_DIFF_ZONE_FACTION_ID_LIST *pstOut = (DT_DIFF_ZONE_FACTION_ID_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byFactionCnt)
			break;
		if(-1 == DecodeDT_ZONE_FACTION_ID(&pstOut->astFactionList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_DIFF_ZONE_FACTION_ID_LIST(DT_DIFF_ZONE_FACTION_ID_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.byFactionCnt));
	cJSON *FactionList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionList", FactionList);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionList, " ", GetJsonDT_ZONE_FACTION_ID(data.astFactionList[dwIndex]));
	}

	return root;
}

INT32 DT_DIFF_ZONE_FACTION_ID_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFactionCnt);
	memcpy(pDataBuff + dwOffset, &byFactionCnt, sizeof(byFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byFactionCnt > GVG_16_TO_8_FACTION_CNT)
	{
		byFactionCnt = GVG_16_TO_8_FACTION_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFactionCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFactionCnt; i++)
	{
		dwContextLenTmp += astFactionList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_DIFF_ZONE_FACTION_ID_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionCnt, 0, sizeof(byFactionCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFactionCnt)
				{
					wArrNum = wArrNum <= GVG_16_TO_8_FACTION_CNT ? wArrNum : GVG_16_TO_8_FACTION_CNT;
					byFactionCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionList, 0, sizeof(astFactionList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionList, 0, sizeof(astFactionList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ONE_ZONE_FACTION_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_ONE_ZONE_FACTION_ID_LIST *pstIn = (DT_ONE_ZONE_FACTION_ID_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wZoneID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byFactionCnt)
			break;
		if(-1 == poNetData->AddDword(pstIn->adwFactionList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ONE_ZONE_FACTION_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_ONE_ZONE_FACTION_ID_LIST *pstOut = (DT_ONE_ZONE_FACTION_ID_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wZoneID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byFactionCnt)
			break;
		if(-1 == poNetData->DelDword(pstOut->adwFactionList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ONE_ZONE_FACTION_ID_LIST(DT_ONE_ZONE_FACTION_ID_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.wZoneID));
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.byFactionCnt));
	cJSON *FactionList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionList", FactionList);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionCnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"FactionList", (double)(data.adwFactionList[dwIndex]));
	}

	return root;
}

INT32 DT_ONE_ZONE_FACTION_ID_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wZoneID);
	memcpy(pDataBuff + dwOffset, &wZoneID, sizeof(wZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byFactionCnt);
	memcpy(pDataBuff + dwOffset, &byFactionCnt, sizeof(byFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	if(byFactionCnt > GVG_16_TO_8_FACTION_CNT)
	{
		byFactionCnt = GVG_16_TO_8_FACTION_CNT;
	}
	pstIndex->dwContextLen = byFactionCnt * sizeof(UINT32) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byFactionCnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &adwFactionList, byFactionCnt * sizeof(UINT32));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ONE_ZONE_FACTION_ID_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&wZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wZoneID, 0, sizeof(wZoneID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionCnt, 0, sizeof(byFactionCnt));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(adwFactionList) >= dwContextLen) && (wArrNum == byFactionCnt) && (wArrNum <= GVG_16_TO_8_FACTION_CNT))
				{
					memcpy(&adwFactionList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&adwFactionList, 0, sizeof(adwFactionList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ZONE_LIST(void *pHost, CNetData* poNetData)
{
	DT_ZONE_LIST *pstIn = (DT_ZONE_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byZoneCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_ZONE_CNT; i++)
	{
		if(i >= (INT32)pstIn->byZoneCnt)
			break;
		if(-1 == EncodeDT_ONE_ZONE_FACTION_ID_LIST(&pstIn->astZoneList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ZONE_LIST(void *pHost, CNetData* poNetData)
{
	DT_ZONE_LIST *pstOut = (DT_ZONE_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byZoneCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_ZONE_CNT; i++)
	{
		if(i >= (INT32)pstOut->byZoneCnt)
			break;
		if(-1 == DecodeDT_ONE_ZONE_FACTION_ID_LIST(&pstOut->astZoneList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ZONE_LIST(DT_ZONE_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneCnt", (double)(data.byZoneCnt));
	cJSON *ZoneList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ZoneList", ZoneList);
	for( UINT32 dwIndex=0; dwIndex<data.byZoneCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(ZoneList, " ", GetJsonDT_ONE_ZONE_FACTION_ID_LIST(data.astZoneList[dwIndex]));
	}

	return root;
}

INT32 DT_ZONE_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byZoneCnt);
	memcpy(pDataBuff + dwOffset, &byZoneCnt, sizeof(byZoneCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byZoneCnt > MAX_GVG_ARENA_ZONE_CNT)
	{
		byZoneCnt = MAX_GVG_ARENA_ZONE_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byZoneCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byZoneCnt; i++)
	{
		dwContextLenTmp += astZoneList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ZONE_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byZoneCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byZoneCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byZoneCnt, 0, sizeof(byZoneCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byZoneCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_ARENA_ZONE_CNT ? wArrNum : MAX_GVG_ARENA_ZONE_CNT;
					byZoneCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astZoneList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astZoneList, 0, sizeof(astZoneList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astZoneList, 0, sizeof(astZoneList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ZONE_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_ZONE_ID_LIST *pstIn = (DT_ZONE_ID_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byZoneCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_ZONE_CNT; i++)
	{
		if(i >= (INT32)pstIn->byZoneCnt)
			break;
		if(-1 == poNetData->AddWord(pstIn->awZoneIDList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ZONE_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_ZONE_ID_LIST *pstOut = (DT_ZONE_ID_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byZoneCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_ARENA_ZONE_CNT; i++)
	{
		if(i >= (INT32)pstOut->byZoneCnt)
			break;
		if(-1 == poNetData->DelWord(pstOut->awZoneIDList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ZONE_ID_LIST(DT_ZONE_ID_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneCnt", (double)(data.byZoneCnt));
	cJSON *ZoneIDList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ZoneIDList", ZoneIDList);
	for( UINT32 dwIndex=0; dwIndex<data.byZoneCnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"ZoneIDList", (double)(data.awZoneIDList[dwIndex]));
	}

	return root;
}

INT32 DT_ZONE_ID_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byZoneCnt);
	memcpy(pDataBuff + dwOffset, &byZoneCnt, sizeof(byZoneCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(byZoneCnt > MAX_GVG_ARENA_ZONE_CNT)
	{
		byZoneCnt = MAX_GVG_ARENA_ZONE_CNT;
	}
	pstIndex->dwContextLen = byZoneCnt * sizeof(UINT16) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byZoneCnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awZoneIDList, byZoneCnt * sizeof(UINT16));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ZONE_ID_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byZoneCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byZoneCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byZoneCnt, 0, sizeof(byZoneCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awZoneIDList) >= dwContextLen) && (wArrNum == byZoneCnt) && (wArrNum <= MAX_GVG_ARENA_ZONE_CNT))
				{
					memcpy(&awZoneIDList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awZoneIDList, 0, sizeof(awZoneIDList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_LIST_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LIST_GVG_LOG *pstIn = (DT_FACTION_LIST_GVG_LOG*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->wFactionCnt)
			break;
		if(-1 == EncodeDT_FACTION_GVG_LOG(&pstIn->astFactionLogs[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_LIST_GVG_LOG(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LIST_GVG_LOG *pstOut = (DT_FACTION_LIST_GVG_LOG*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->wFactionCnt)
			break;
		if(-1 == DecodeDT_FACTION_GVG_LOG(&pstOut->astFactionLogs[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_LIST_GVG_LOG(DT_FACTION_LIST_GVG_LOG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.wFactionCnt));
	cJSON *FactionLogs = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionLogs", FactionLogs);
	for( UINT32 dwIndex=0; dwIndex<data.wFactionCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionLogs, " ", GetJsonDT_FACTION_GVG_LOG(data.astFactionLogs[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_LIST_GVG_LOG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wFactionCnt);
	memcpy(pDataBuff + dwOffset, &wFactionCnt, sizeof(wFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wFactionCnt > GVG_16_TO_8_FACTION_CNT)
	{
		wFactionCnt = GVG_16_TO_8_FACTION_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wFactionCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wFactionCnt; i++)
	{
		dwContextLenTmp += astFactionLogs[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_LIST_GVG_LOG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFactionCnt, 0, sizeof(wFactionCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wFactionCnt)
				{
					wArrNum = wArrNum <= GVG_16_TO_8_FACTION_CNT ? wArrNum : GVG_16_TO_8_FACTION_CNT;
					wFactionCnt = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionLogs[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionLogs, 0, sizeof(astFactionLogs));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionLogs, 0, sizeof(astFactionLogs));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_VIDEO_ID(void *pHost, CNetData* poNetData)
{
	DT_VIDEO_ID *pstIn = (DT_VIDEO_ID*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwVideoID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_VIDEO_ID(void *pHost, CNetData* poNetData)
{
	DT_VIDEO_ID *pstOut = (DT_VIDEO_ID*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwVideoID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_VIDEO_ID(DT_VIDEO_ID &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"VideoID", (double)(data.qwVideoID));

	return root;
}

INT32 DT_VIDEO_ID::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwVideoID);
	memcpy(pDataBuff + dwOffset, &qwVideoID, sizeof(qwVideoID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_VIDEO_ID::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwVideoID) >= pstIndex->dwContextLen)
				{
					memcpy(&qwVideoID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwVideoID, 0, sizeof(qwVideoID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FINAL_WAR_EACH_ROUND_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_WAR_EACH_ROUND_FACTION_INFO *pstIn = (DT_FINAL_WAR_EACH_ROUND_FACTION_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byEnemyPos))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wScore))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwVideoID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byResult))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FINAL_WAR_EACH_ROUND_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_WAR_EACH_ROUND_FACTION_INFO *pstOut = (DT_FINAL_WAR_EACH_ROUND_FACTION_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byEnemyPos))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wScore))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwVideoID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byResult))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FINAL_WAR_EACH_ROUND_FACTION_INFO(DT_FINAL_WAR_EACH_ROUND_FACTION_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"EnemyPos", (double)(data.byEnemyPos));
	cJSON_AddNumberToObject(root,"Score", (double)(data.wScore));
	cJSON_AddNumberToObject(root,"VideoID", (double)(data.qwVideoID));
	cJSON_AddNumberToObject(root,"Result", (double)(data.byResult));

	return root;
}

INT32 DT_FINAL_WAR_EACH_ROUND_FACTION_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byEnemyPos);
	memcpy(pDataBuff + dwOffset, &byEnemyPos, sizeof(byEnemyPos));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wScore);
	memcpy(pDataBuff + dwOffset, &wScore, sizeof(wScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwVideoID);
	memcpy(pDataBuff + dwOffset, &qwVideoID, sizeof(qwVideoID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byResult);
	memcpy(pDataBuff + dwOffset, &byResult, sizeof(byResult));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FINAL_WAR_EACH_ROUND_FACTION_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byEnemyPos) >= pstIndex->dwContextLen)
				{
					memcpy(&byEnemyPos, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEnemyPos, 0, sizeof(byEnemyPos));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wScore) >= pstIndex->dwContextLen)
				{
					memcpy(&wScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wScore, 0, sizeof(wScore));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwVideoID) >= pstIndex->dwContextLen)
				{
					memcpy(&qwVideoID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwVideoID, 0, sizeof(qwVideoID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byResult) >= pstIndex->dwContextLen)
				{
					memcpy(&byResult, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResult, 0, sizeof(byResult));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FINAL_WAR_ROUND_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_WAR_ROUND_INFO *pstIn = (DT_FINAL_WAR_ROUND_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byFactionCnt)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyRankList[i]))
			return -1;
	}

	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byFactionCnt)
			break;
		if(-1 == EncodeDT_FINAL_WAR_EACH_ROUND_FACTION_INFO(&pstIn->astFactionList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FINAL_WAR_ROUND_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_WAR_ROUND_INFO *pstOut = (DT_FINAL_WAR_ROUND_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byFactionCnt)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyRankList[i]))
			return -1;
	}

	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byFactionCnt)
			break;
		if(-1 == DecodeDT_FINAL_WAR_EACH_ROUND_FACTION_INFO(&pstOut->astFactionList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FINAL_WAR_ROUND_INFO(DT_FINAL_WAR_ROUND_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.byFactionCnt));
	cJSON *RankList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "RankList", RankList);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionCnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"RankList", (double)(data.abyRankList[dwIndex]));
	}
	cJSON *FactionList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionList", FactionList);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionList, " ", GetJsonDT_FINAL_WAR_EACH_ROUND_FACTION_INFO(data.astFactionList[dwIndex]));
	}

	return root;
}

INT32 DT_FINAL_WAR_ROUND_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFactionCnt);
	memcpy(pDataBuff + dwOffset, &byFactionCnt, sizeof(byFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(byFactionCnt > GVG_FINAL_WAR_FACTION_CNT)
	{
		byFactionCnt = GVG_FINAL_WAR_FACTION_CNT;
	}
	pstIndex->dwContextLen = byFactionCnt * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byFactionCnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyRankList, byFactionCnt * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(byFactionCnt > GVG_FINAL_WAR_FACTION_CNT)
	{
		byFactionCnt = GVG_FINAL_WAR_FACTION_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFactionCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFactionCnt; i++)
	{
		dwContextLenTmp += astFactionList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FINAL_WAR_ROUND_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionCnt, 0, sizeof(byFactionCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyRankList) >= dwContextLen) && (wArrNum == byFactionCnt) && (wArrNum <= GVG_FINAL_WAR_FACTION_CNT))
				{
					memcpy(&abyRankList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyRankList, 0, sizeof(abyRankList));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFactionCnt)
				{
					wArrNum = wArrNum <= GVG_FINAL_WAR_FACTION_CNT ? wArrNum : GVG_FINAL_WAR_FACTION_CNT;
					byFactionCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionList, 0, sizeof(astFactionList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionList, 0, sizeof(astFactionList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_16_TO_8_TO_4_WAR_INFO(void *pHost, CNetData* poNetData)
{
	DT_16_TO_8_TO_4_WAR_INFO *pstIn = (DT_16_TO_8_TO_4_WAR_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byFactionCnt)
			break;
		if(-1 == EncodeDT_GVG_FACTION(&pstIn->astFactionList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byWin8Cnt))
		return -1;

	for(i = 0; i < GVG_16_TO_8_WIN_CNT; i++)
	{
		if(i >= (INT32)pstIn->byWin8Cnt)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyWin8List[i]))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byWin4Cnt))
		return -1;

	for(i = 0; i < GVG_8_TO_4_WIN_CNT; i++)
	{
		if(i >= (INT32)pstIn->byWin4Cnt)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyWin4List[i]))
			return -1;
	}

	for(i = 0; i < GVG_16_TO_8_WIN_CNT; i++)
	{
		if(-1 == poNetData->AddUint64(pstIn->aqwVideoIDList16To8[i]))
			return -1;
	}

	for(i = 0; i < GVG_8_TO_4_WIN_CNT; i++)
	{
		if(-1 == poNetData->AddUint64(pstIn->aqwVideoIDList8To4[i]))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byRolled))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byReady16To8))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byReady8To4))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_16_TO_8_TO_4_WAR_INFO(void *pHost, CNetData* poNetData)
{
	DT_16_TO_8_TO_4_WAR_INFO *pstOut = (DT_16_TO_8_TO_4_WAR_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_16_TO_8_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byFactionCnt)
			break;
		if(-1 == DecodeDT_GVG_FACTION(&pstOut->astFactionList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byWin8Cnt))
		return -1;

	for(i = 0; i < GVG_16_TO_8_WIN_CNT; i++)
	{
		if(i >= (INT32)pstOut->byWin8Cnt)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyWin8List[i]))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byWin4Cnt))
		return -1;

	for(i = 0; i < GVG_8_TO_4_WIN_CNT; i++)
	{
		if(i >= (INT32)pstOut->byWin4Cnt)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyWin4List[i]))
			return -1;
	}

	for(i = 0; i < GVG_16_TO_8_WIN_CNT; i++)
	{
		if(-1 == poNetData->DelUint64(pstOut->aqwVideoIDList16To8[i]))
			return -1;
	}

	for(i = 0; i < GVG_8_TO_4_WIN_CNT; i++)
	{
		if(-1 == poNetData->DelUint64(pstOut->aqwVideoIDList8To4[i]))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byRolled))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byReady16To8))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byReady8To4))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_16_TO_8_TO_4_WAR_INFO(DT_16_TO_8_TO_4_WAR_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.byFactionCnt));
	cJSON *FactionList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionList", FactionList);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionList, " ", GetJsonDT_GVG_FACTION(data.astFactionList[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"Win8Cnt", (double)(data.byWin8Cnt));
	cJSON *Win8List = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "Win8List", Win8List);
	for( UINT32 dwIndex=0; dwIndex<data.byWin8Cnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"Win8List", (double)(data.abyWin8List[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"Win4Cnt", (double)(data.byWin4Cnt));
	cJSON *Win4List = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "Win4List", Win4List);
	for( UINT32 dwIndex=0; dwIndex<data.byWin4Cnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"Win4List", (double)(data.abyWin4List[dwIndex]));
	}
	cJSON *VideoIDList16To8 = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "VideoIDList16To8", VideoIDList16To8);
	for( UINT32 dwIndex=0; dwIndex<GVG_16_TO_8_WIN_CNT; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"VideoIDList16To8", (double)(data.aqwVideoIDList16To8[dwIndex]));
	}
	cJSON *VideoIDList8To4 = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "VideoIDList8To4", VideoIDList8To4);
	for( UINT32 dwIndex=0; dwIndex<GVG_8_TO_4_WIN_CNT; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"VideoIDList8To4", (double)(data.aqwVideoIDList8To4[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"Rolled", (double)(data.byRolled));
	cJSON_AddNumberToObject(root,"Ready16To8", (double)(data.byReady16To8));
	cJSON_AddNumberToObject(root,"Ready8To4", (double)(data.byReady8To4));

	return root;
}

INT32 DT_16_TO_8_TO_4_WAR_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 11;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFactionCnt);
	memcpy(pDataBuff + dwOffset, &byFactionCnt, sizeof(byFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byFactionCnt > GVG_16_TO_8_FACTION_CNT)
	{
		byFactionCnt = GVG_16_TO_8_FACTION_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFactionCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFactionCnt; i++)
	{
		dwContextLenTmp += astFactionList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byWin8Cnt);
	memcpy(pDataBuff + dwOffset, &byWin8Cnt, sizeof(byWin8Cnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	if(byWin8Cnt > GVG_16_TO_8_WIN_CNT)
	{
		byWin8Cnt = GVG_16_TO_8_WIN_CNT;
	}
	pstIndex->dwContextLen = byWin8Cnt * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byWin8Cnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyWin8List, byWin8Cnt * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byWin4Cnt);
	memcpy(pDataBuff + dwOffset, &byWin4Cnt, sizeof(byWin4Cnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	if(byWin4Cnt > GVG_8_TO_4_WIN_CNT)
	{
		byWin4Cnt = GVG_8_TO_4_WIN_CNT;
	}
	pstIndex->dwContextLen = byWin4Cnt * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byWin4Cnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyWin4List, byWin4Cnt * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(aqwVideoIDList16To8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = GVG_16_TO_8_WIN_CNT;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aqwVideoIDList16To8, sizeof(aqwVideoIDList16To8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(aqwVideoIDList8To4) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = GVG_8_TO_4_WIN_CNT;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aqwVideoIDList8To4, sizeof(aqwVideoIDList8To4));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byRolled);
	memcpy(pDataBuff + dwOffset, &byRolled, sizeof(byRolled));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byReady16To8);
	memcpy(pDataBuff + dwOffset, &byReady16To8, sizeof(byReady16To8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byReady8To4);
	memcpy(pDataBuff + dwOffset, &byReady8To4, sizeof(byReady8To4));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_16_TO_8_TO_4_WAR_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionCnt, 0, sizeof(byFactionCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFactionCnt)
				{
					wArrNum = wArrNum <= GVG_16_TO_8_FACTION_CNT ? wArrNum : GVG_16_TO_8_FACTION_CNT;
					byFactionCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionList, 0, sizeof(astFactionList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionList, 0, sizeof(astFactionList));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byWin8Cnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byWin8Cnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWin8Cnt, 0, sizeof(byWin8Cnt));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyWin8List) >= dwContextLen) && (wArrNum == byWin8Cnt) && (wArrNum <= GVG_16_TO_8_WIN_CNT))
				{
					memcpy(&abyWin8List, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyWin8List, 0, sizeof(abyWin8List));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byWin4Cnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byWin4Cnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWin4Cnt, 0, sizeof(byWin4Cnt));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyWin4List) >= dwContextLen) && (wArrNum == byWin4Cnt) && (wArrNum <= GVG_8_TO_4_WIN_CNT))
				{
					memcpy(&abyWin4List, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyWin4List, 0, sizeof(abyWin4List));
				}
			}
			break;
		case 7:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aqwVideoIDList16To8) >= dwContextLen) && (wArrNum <= GVG_16_TO_8_WIN_CNT))
				{
					memcpy(&aqwVideoIDList16To8, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aqwVideoIDList16To8, 0, sizeof(aqwVideoIDList16To8));
				}
			}
			break;
		case 8:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aqwVideoIDList8To4) >= dwContextLen) && (wArrNum <= GVG_8_TO_4_WIN_CNT))
				{
					memcpy(&aqwVideoIDList8To4, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aqwVideoIDList8To4, 0, sizeof(aqwVideoIDList8To4));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byRolled) >= pstIndex->dwContextLen)
				{
					memcpy(&byRolled, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byRolled, 0, sizeof(byRolled));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byReady16To8) >= pstIndex->dwContextLen)
				{
					memcpy(&byReady16To8, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byReady16To8, 0, sizeof(byReady16To8));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byReady8To4) >= pstIndex->dwContextLen)
				{
					memcpy(&byReady8To4, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byReady8To4, 0, sizeof(byReady8To4));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FINAL_WAR_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_WAR_INFO *pstIn = (DT_FINAL_WAR_INFO*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byTotalRound))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byFactionCnt)
			break;
		if(-1 == EncodeDT_GVG_FACTION(&pstIn->astFactionList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byTopCnt))
		return -1;

	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byTopCnt)
			break;
		if(-1 == poNetData->AddByte(pstIn->abyTopList[i]))
			return -1;
	}

	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(-1 == EncodeDT_FINAL_WAR_ROUND_INFO(&pstIn->astEachRoundInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FINAL_WAR_INFO(void *pHost, CNetData* poNetData)
{
	DT_FINAL_WAR_INFO *pstOut = (DT_FINAL_WAR_INFO*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byTotalRound))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byFactionCnt)
			break;
		if(-1 == DecodeDT_GVG_FACTION(&pstOut->astFactionList[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byTopCnt))
		return -1;

	for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byTopCnt)
			break;
		if(-1 == poNetData->DelByte(pstOut->abyTopList[i]))
			return -1;
	}

		for(i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
		{
			if(-1 == DecodeDT_FINAL_WAR_ROUND_INFO(&pstOut->astEachRoundInfo[i], poNetData))
				return -1;
		}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FINAL_WAR_INFO(DT_FINAL_WAR_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"TotalRound", (double)(data.byTotalRound));
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.byFactionCnt));
	cJSON *FactionList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionList", FactionList);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionList, " ", GetJsonDT_GVG_FACTION(data.astFactionList[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"TopCnt", (double)(data.byTopCnt));
	cJSON *TopList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "TopList", TopList);
	for( UINT32 dwIndex=0; dwIndex<data.byTopCnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"TopList", (double)(data.abyTopList[dwIndex]));
	}
	cJSON *EachRoundInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "EachRoundInfo", EachRoundInfo);
	for( UINT32 dwIndex=0; dwIndex<GVG_FINAL_WAR_FACTION_CNT; ++dwIndex)
	{
		cJSON_AddItemToObject(EachRoundInfo, " ", GetJsonDT_FINAL_WAR_ROUND_INFO(data.astEachRoundInfo[dwIndex]));
	}

	return root;
}

INT32 DT_FINAL_WAR_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byTotalRound);
	memcpy(pDataBuff + dwOffset, &byTotalRound, sizeof(byTotalRound));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byFactionCnt);
	memcpy(pDataBuff + dwOffset, &byFactionCnt, sizeof(byFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	dwContextLenTmp = 0;
	if(byFactionCnt > GVG_FINAL_WAR_FACTION_CNT)
	{
		byFactionCnt = GVG_FINAL_WAR_FACTION_CNT;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFactionCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFactionCnt; i++)
	{
		dwContextLenTmp += astFactionList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byTopCnt);
	memcpy(pDataBuff + dwOffset, &byTopCnt, sizeof(byTopCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	if(byTopCnt > GVG_FINAL_WAR_FACTION_CNT)
	{
		byTopCnt = GVG_FINAL_WAR_FACTION_CNT;
	}
	pstIndex->dwContextLen = byTopCnt * sizeof(UINT8) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byTopCnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyTopList, byTopCnt * sizeof(UINT8));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = GVG_FINAL_WAR_FACTION_CNT;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < GVG_FINAL_WAR_FACTION_CNT; i++)
	{
		dwContextLenTmp += astEachRoundInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FINAL_WAR_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byTotalRound) >= pstIndex->dwContextLen)
				{
					memcpy(&byTotalRound, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTotalRound, 0, sizeof(byTotalRound));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionCnt, 0, sizeof(byFactionCnt));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFactionCnt)
				{
					wArrNum = wArrNum <= GVG_FINAL_WAR_FACTION_CNT ? wArrNum : GVG_FINAL_WAR_FACTION_CNT;
					byFactionCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionList, 0, sizeof(astFactionList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionList, 0, sizeof(astFactionList));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byTopCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byTopCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTopCnt, 0, sizeof(byTopCnt));
				}
			}
			break;
		case 5:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyTopList) >= dwContextLen) && (wArrNum == byTopCnt) && (wArrNum <= GVG_FINAL_WAR_FACTION_CNT))
				{
					memcpy(&abyTopList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyTopList, 0, sizeof(abyTopList));
				}
			}
			break;
		case 7:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= GVG_FINAL_WAR_FACTION_CNT ? wArrNum : GVG_FINAL_WAR_FACTION_CNT;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astEachRoundInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astEachRoundInfo, 0, sizeof(astEachRoundInfo));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_STAGE_FINISH_FLAG_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_STAGE_FINISH_FLAG_LIST *pstIn = (DT_GVG_STAGE_FINISH_FLAG_LIST*)pHost;

	INT32 i;
	for(i = 0; i < 30; i++)
	{
		if(-1 == poNetData->AddByte(pstIn->abyFlagList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_STAGE_FINISH_FLAG_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_STAGE_FINISH_FLAG_LIST *pstOut = (DT_GVG_STAGE_FINISH_FLAG_LIST*)pHost;

	INT32 i;
	for(i = 0; i < 30; i++)
	{
		if(-1 == poNetData->DelByte(pstOut->abyFlagList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_STAGE_FINISH_FLAG_LIST(DT_GVG_STAGE_FINISH_FLAG_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON *FlagList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FlagList", FlagList);
	for( UINT32 dwIndex=0; dwIndex<30; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"FlagList", (double)(data.abyFlagList[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_STAGE_FINISH_FLAG_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(abyFlagList) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = 30;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyFlagList, sizeof(abyFlagList));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_STAGE_FINISH_FLAG_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyFlagList) >= dwContextLen) && (wArrNum <= 30))
				{
					memcpy(&abyFlagList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyFlagList, 0, sizeof(abyFlagList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GROUP_ZONE(void *pHost, CNetData* poNetData)
{
	DT_GROUP_ZONE *pstIn = (DT_GROUP_ZONE*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byGroupID))
		return -1;

	INT32 i;
	for(i = 0; i < 2; i++)
	{
		if(-1 == poNetData->AddWord(pstIn->awZoneIDList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GROUP_ZONE(void *pHost, CNetData* poNetData)
{
	DT_GROUP_ZONE *pstOut = (DT_GROUP_ZONE*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byGroupID))
		return -1;

	INT32 i;
	for(i = 0; i < 2; i++)
	{
		if(-1 == poNetData->DelWord(pstOut->awZoneIDList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GROUP_ZONE(DT_GROUP_ZONE &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GroupID", (double)(data.byGroupID));
	cJSON *ZoneIDList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ZoneIDList", ZoneIDList);
	for( UINT32 dwIndex=0; dwIndex<2; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"ZoneIDList", (double)(data.awZoneIDList[dwIndex]));
	}

	return root;
}

INT32 DT_GROUP_ZONE::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byGroupID);
	memcpy(pDataBuff + dwOffset, &byGroupID, sizeof(byGroupID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(awZoneIDList) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = 2;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &awZoneIDList, sizeof(awZoneIDList));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GROUP_ZONE::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byGroupID) >= pstIndex->dwContextLen)
				{
					memcpy(&byGroupID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGroupID, 0, sizeof(byGroupID));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(awZoneIDList) >= dwContextLen) && (wArrNum <= 2))
				{
					memcpy(&awZoneIDList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&awZoneIDList, 0, sizeof(awZoneIDList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GROUP_ZONE_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_GROUP_ZONE_ID_LIST *pstIn = (DT_GROUP_ZONE_ID_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byGroupCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstIn->byGroupCnt)
			break;
		if(-1 == EncodeDT_GROUP_ZONE(&pstIn->astGroupList[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GROUP_ZONE_ID_LIST(void *pHost, CNetData* poNetData)
{
	DT_GROUP_ZONE_ID_LIST *pstOut = (DT_GROUP_ZONE_ID_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byGroupCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstOut->byGroupCnt)
			break;
		if(-1 == DecodeDT_GROUP_ZONE(&pstOut->astGroupList[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GROUP_ZONE_ID_LIST(DT_GROUP_ZONE_ID_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GroupCnt", (double)(data.byGroupCnt));
	cJSON *GroupList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GroupList", GroupList);
	for( UINT32 dwIndex=0; dwIndex<data.byGroupCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(GroupList, " ", GetJsonDT_GROUP_ZONE(data.astGroupList[dwIndex]));
	}

	return root;
}

INT32 DT_GROUP_ZONE_ID_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byGroupCnt);
	memcpy(pDataBuff + dwOffset, &byGroupCnt, sizeof(byGroupCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byGroupCnt > MAX_GVG_GROUP_NUM)
	{
		byGroupCnt = MAX_GVG_GROUP_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byGroupCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byGroupCnt; i++)
	{
		dwContextLenTmp += astGroupList[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GROUP_ZONE_ID_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byGroupCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byGroupCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byGroupCnt, 0, sizeof(byGroupCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byGroupCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_GROUP_NUM ? wArrNum : MAX_GVG_GROUP_NUM;
					byGroupCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astGroupList[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astGroupList, 0, sizeof(astGroupList));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astGroupList, 0, sizeof(astGroupList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_WAR_16_TO_8_LIST(void *pHost, CNetData* poNetData)
{
	DT_WAR_16_TO_8_LIST *pstIn = (DT_WAR_16_TO_8_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byWarCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstIn->byWarCnt)
			break;
		if(-1 == EncodeDT_16_TO_8_TO_4_WAR_INFO(&pstIn->astWar16To8To4Info[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_WAR_16_TO_8_LIST(void *pHost, CNetData* poNetData)
{
	DT_WAR_16_TO_8_LIST *pstOut = (DT_WAR_16_TO_8_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byWarCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstOut->byWarCnt)
			break;
		if(-1 == DecodeDT_16_TO_8_TO_4_WAR_INFO(&pstOut->astWar16To8To4Info[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_WAR_16_TO_8_LIST(DT_WAR_16_TO_8_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"WarCnt", (double)(data.byWarCnt));
	cJSON *War16To8To4Info = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "War16To8To4Info", War16To8To4Info);
	for( UINT32 dwIndex=0; dwIndex<data.byWarCnt; ++dwIndex)
	{
		cJSON_AddItemToObject(War16To8To4Info, " ", GetJsonDT_16_TO_8_TO_4_WAR_INFO(data.astWar16To8To4Info[dwIndex]));
	}

	return root;
}

INT32 DT_WAR_16_TO_8_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byWarCnt);
	memcpy(pDataBuff + dwOffset, &byWarCnt, sizeof(byWarCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byWarCnt > MAX_GVG_GROUP_NUM)
	{
		byWarCnt = MAX_GVG_GROUP_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byWarCnt;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byWarCnt; i++)
	{
		dwContextLenTmp += astWar16To8To4Info[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_WAR_16_TO_8_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byWarCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byWarCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWarCnt, 0, sizeof(byWarCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byWarCnt)
				{
					wArrNum = wArrNum <= MAX_GVG_GROUP_NUM ? wArrNum : MAX_GVG_GROUP_NUM;
					byWarCnt = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astWar16To8To4Info[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astWar16To8To4Info, 0, sizeof(astWar16To8To4Info));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astWar16To8To4Info, 0, sizeof(astWar16To8To4Info));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_ARENA_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_ARENA_DATA *pstIn = (DT_GVG_ARENA_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wArenaID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurStage))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsDone))
		return -1;

	if(-1 == EncodeDT_ZONE_ID_LIST(&pstIn->stZoneIDList, poNetData))
		return -1;

	if(-1 == EncodeDT_GROUP_ZONE_ID_LIST(&pstIn->stGroupZoneIDList, poNetData))
		return -1;

	if(-1 == EncodeDT_WAR_16_TO_8_LIST(&pstIn->stWar16To8List, poNetData))
		return -1;

	if(-1 == EncodeDT_FINAL_WAR_INFO(&pstIn->stFinalWarInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_FACTION_LIST_SIMPLE_GVG_LOG(&pstIn->stFactionsLog, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_STAGE_FINISH_FLAG_LIST(&pstIn->stStageDoneFlagList, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_ARENA_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_ARENA_DATA *pstOut = (DT_GVG_ARENA_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wArenaID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurStage))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsDone))
		return -1;

	if(-1 == DecodeDT_ZONE_ID_LIST(&pstOut->stZoneIDList, poNetData))
		return -1;

	if(-1 == DecodeDT_GROUP_ZONE_ID_LIST(&pstOut->stGroupZoneIDList, poNetData))
		return -1;

	if(-1 == DecodeDT_WAR_16_TO_8_LIST(&pstOut->stWar16To8List, poNetData))
		return -1;

	if(-1 == DecodeDT_FINAL_WAR_INFO(&pstOut->stFinalWarInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_FACTION_LIST_SIMPLE_GVG_LOG(&pstOut->stFactionsLog, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_STAGE_FINISH_FLAG_LIST(&pstOut->stStageDoneFlagList, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_ARENA_DATA(DT_GVG_ARENA_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ArenaID", (double)(data.wArenaID));
	cJSON_AddNumberToObject(root,"CurStage", (double)(data.byCurStage));
	cJSON_AddNumberToObject(root,"IsDone", (double)(data.byIsDone));
	cJSON_AddItemToObject(root, "ZoneIDList", GetJsonDT_ZONE_ID_LIST(data.stZoneIDList));
	cJSON_AddItemToObject(root, "GroupZoneIDList", GetJsonDT_GROUP_ZONE_ID_LIST(data.stGroupZoneIDList));
	cJSON_AddItemToObject(root, "War16To8List", GetJsonDT_WAR_16_TO_8_LIST(data.stWar16To8List));
	cJSON_AddItemToObject(root, "FinalWarInfo", GetJsonDT_FINAL_WAR_INFO(data.stFinalWarInfo));
	cJSON_AddItemToObject(root, "FactionsLog", GetJsonDT_FACTION_LIST_SIMPLE_GVG_LOG(data.stFactionsLog));
	cJSON_AddItemToObject(root, "StageDoneFlagList", GetJsonDT_GVG_STAGE_FINISH_FLAG_LIST(data.stStageDoneFlagList));

	return root;
}

INT32 DT_GVG_ARENA_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wArenaID);
	memcpy(pDataBuff + dwOffset, &wArenaID, sizeof(wArenaID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCurStage);
	memcpy(pDataBuff + dwOffset, &byCurStage, sizeof(byCurStage));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byIsDone);
	memcpy(pDataBuff + dwOffset, &byIsDone, sizeof(byIsDone));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stZoneIDList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stGroupZoneIDList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stWar16To8List.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stFinalWarInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stFactionsLog.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stStageDoneFlagList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_ARENA_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wArenaID) >= pstIndex->dwContextLen)
				{
					memcpy(&wArenaID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wArenaID, 0, sizeof(wArenaID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCurStage) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurStage, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurStage, 0, sizeof(byCurStage));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byIsDone) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsDone, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsDone, 0, sizeof(byIsDone));
				}
			}
			break;
		case 4:
			{
				stZoneIDList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stGroupZoneIDList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stWar16To8List.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				stFinalWarInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stFactionsLog.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stStageDoneFlagList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_ZONE_FACTION_MEMBER(void *pHost, CNetData* poNetData)
{
	DT_ZONE_FACTION_MEMBER *pstIn = (DT_ZONE_FACTION_MEMBER*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwZoneID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_TOP_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstIn->byFactionCnt)
			break;
		if(-1 == poNetData->AddDword(pstIn->adwFactionIDList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_ZONE_FACTION_MEMBER(void *pHost, CNetData* poNetData)
{
	DT_ZONE_FACTION_MEMBER *pstOut = (DT_ZONE_FACTION_MEMBER*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwZoneID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_TOP_FACTION_CNT; i++)
	{
		if(i >= (INT32)pstOut->byFactionCnt)
			break;
		if(-1 == poNetData->DelDword(pstOut->adwFactionIDList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_ZONE_FACTION_MEMBER(DT_ZONE_FACTION_MEMBER &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.dwZoneID));
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.byFactionCnt));
	cJSON *FactionIDList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionIDList", FactionIDList);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionCnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"FactionIDList", (double)(data.adwFactionIDList[dwIndex]));
	}

	return root;
}

INT32 DT_ZONE_FACTION_MEMBER::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwZoneID);
	memcpy(pDataBuff + dwOffset, &dwZoneID, sizeof(dwZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byFactionCnt);
	memcpy(pDataBuff + dwOffset, &byFactionCnt, sizeof(byFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	if(byFactionCnt > MAX_GVG_TOP_FACTION_CNT)
	{
		byFactionCnt = MAX_GVG_TOP_FACTION_CNT;
	}
	pstIndex->dwContextLen = byFactionCnt * sizeof(UINT32) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byFactionCnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &adwFactionIDList, byFactionCnt * sizeof(UINT32));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_ZONE_FACTION_MEMBER::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwZoneID, 0, sizeof(dwZoneID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionCnt, 0, sizeof(byFactionCnt));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(adwFactionIDList) >= dwContextLen) && (wArrNum == byFactionCnt) && (wArrNum <= MAX_GVG_TOP_FACTION_CNT))
				{
					memcpy(&adwFactionIDList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&adwFactionIDList, 0, sizeof(adwFactionIDList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_ACTIVITY_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_ACTIVITY_DATA *pstIn = (DT_GVG_ACTIVITY_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSessionID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStartTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurStage))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDone))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byArenaCnt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_ACTIVITY_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_ACTIVITY_DATA *pstOut = (DT_GVG_ACTIVITY_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSessionID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStartTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurStage))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDone))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byArenaCnt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_ACTIVITY_DATA(DT_GVG_ACTIVITY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SessionID", (double)(data.wSessionID));
	cJSON_AddNumberToObject(root,"StartTime", (double)(data.qwStartTime));
	cJSON_AddNumberToObject(root,"CurStage", (double)(data.byCurStage));
	cJSON_AddNumberToObject(root,"Done", (double)(data.byDone));
	cJSON_AddNumberToObject(root,"ArenaCnt", (double)(data.byArenaCnt));

	return root;
}

INT32 DT_GVG_ACTIVITY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSessionID);
	memcpy(pDataBuff + dwOffset, &wSessionID, sizeof(wSessionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwStartTime);
	memcpy(pDataBuff + dwOffset, &qwStartTime, sizeof(qwStartTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byCurStage);
	memcpy(pDataBuff + dwOffset, &byCurStage, sizeof(byCurStage));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byDone);
	memcpy(pDataBuff + dwOffset, &byDone, sizeof(byDone));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byArenaCnt);
	memcpy(pDataBuff + dwOffset, &byArenaCnt, sizeof(byArenaCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_ACTIVITY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSessionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSessionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSessionID, 0, sizeof(wSessionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwStartTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStartTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStartTime, 0, sizeof(qwStartTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byCurStage) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurStage, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurStage, 0, sizeof(byCurStage));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byDone) >= pstIndex->dwContextLen)
				{
					memcpy(&byDone, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDone, 0, sizeof(byDone));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byArenaCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byArenaCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byArenaCnt, 0, sizeof(byArenaCnt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_LOCAL_ACTIVITY_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_LOCAL_ACTIVITY_DATA *pstIn = (DT_GVG_LOCAL_ACTIVITY_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSessionID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStartTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurStage))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDone))
		return -1;

	if(-1 == EncodeDT_GVG_ARENA_DATA(&pstIn->stArena, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_LOCAL_ACTIVITY_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_LOCAL_ACTIVITY_DATA *pstOut = (DT_GVG_LOCAL_ACTIVITY_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSessionID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStartTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurStage))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDone))
		return -1;

	if(-1 == DecodeDT_GVG_ARENA_DATA(&pstOut->stArena, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_LOCAL_ACTIVITY_DATA(DT_GVG_LOCAL_ACTIVITY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SessionID", (double)(data.wSessionID));
	cJSON_AddNumberToObject(root,"StartTime", (double)(data.qwStartTime));
	cJSON_AddNumberToObject(root,"CurStage", (double)(data.byCurStage));
	cJSON_AddNumberToObject(root,"Done", (double)(data.byDone));
	cJSON_AddItemToObject(root, "Arena", GetJsonDT_GVG_ARENA_DATA(data.stArena));

	return root;
}

INT32 DT_GVG_LOCAL_ACTIVITY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 5;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSessionID);
	memcpy(pDataBuff + dwOffset, &wSessionID, sizeof(wSessionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwStartTime);
	memcpy(pDataBuff + dwOffset, &qwStartTime, sizeof(qwStartTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byCurStage);
	memcpy(pDataBuff + dwOffset, &byCurStage, sizeof(byCurStage));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byDone);
	memcpy(pDataBuff + dwOffset, &byDone, sizeof(byDone));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stArena.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_LOCAL_ACTIVITY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSessionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSessionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSessionID, 0, sizeof(wSessionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwStartTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStartTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStartTime, 0, sizeof(qwStartTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byCurStage) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurStage, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurStage, 0, sizeof(byCurStage));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byDone) >= pstIndex->dwContextLen)
				{
					memcpy(&byDone, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDone, 0, sizeof(byDone));
				}
			}
			break;
		case 5:
			{
				stArena.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_TSTRING_MSG(void *pHost, CNetData* poNetData)
{
	DT_TSTRING_MSG *pstIn = (DT_TSTRING_MSG*)pHost;

	if(-1 == poNetData->AddTString(pstIn->aszTstringMsg, sizeof(pstIn->aszTstringMsg)))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_TSTRING_MSG(void *pHost, CNetData* poNetData)
{
	DT_TSTRING_MSG *pstOut = (DT_TSTRING_MSG*)pHost;

	if(-1 == poNetData->DelTString(pstOut->aszTstringMsg, sizeof(pstOut->aszTstringMsg)))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_TSTRING_MSG(DT_TSTRING_MSG &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddStringToObject(root,"TstringMsg", data.aszTstringMsg );

	return root;
}

INT32 DT_TSTRING_MSG::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(aszTstringMsg) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = NORMAL_MSG_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszTstringMsg, sizeof(aszTstringMsg));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_TSTRING_MSG::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszTstringMsg) >= dwContextLen) && (wArrNum <= NORMAL_MSG_LEN))
				{
					memcpy(&aszTstringMsg, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszTstringMsg, 0, sizeof(aszTstringMsg));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_LOG_MSG_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_LOG_MSG_DATA *pstIn = (DT_BATTLE_LOG_MSG_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLogBigType))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLogSmallType))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLogTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byParamNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_LOG_PARAM_NUM; i++)
	{
		if(i >= (INT32)pstIn->byParamNum)
			break;
		if(-1 == poNetData->AddUint64(pstIn->aqwParamLst[i]))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byStrNum))
		return -1;

	for(i = 0; i < MAX_BATTLE_LOG_PARAM_STR; i++)
	{
		if(i >= (INT32)pstIn->byStrNum)
			break;
		if(-1 == EncodeDT_TSTRING_MSG(&pstIn->astStrLst[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_LOG_MSG_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_LOG_MSG_DATA *pstOut = (DT_BATTLE_LOG_MSG_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLogBigType))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLogSmallType))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLogTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byParamNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_LOG_PARAM_NUM; i++)
	{
		if(i >= (INT32)pstOut->byParamNum)
			break;
		if(-1 == poNetData->DelUint64(pstOut->aqwParamLst[i]))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byStrNum))
		return -1;

	for(i = 0; i < MAX_BATTLE_LOG_PARAM_STR; i++)
	{
		if(i >= (INT32)pstOut->byStrNum)
			break;
		if(-1 == DecodeDT_TSTRING_MSG(&pstOut->astStrLst[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_LOG_MSG_DATA(DT_BATTLE_LOG_MSG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddNumberToObject(root,"LogBigType", (double)(data.byLogBigType));
	cJSON_AddNumberToObject(root,"LogSmallType", (double)(data.byLogSmallType));
	cJSON_AddNumberToObject(root,"LogTime", (double)(data.qwLogTime));
	cJSON_AddNumberToObject(root,"ParamNum", (double)(data.byParamNum));
	cJSON *ParamLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ParamLst", ParamLst);
	for( UINT32 dwIndex=0; dwIndex<data.byParamNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"ParamLst", (double)(data.aqwParamLst[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"StrNum", (double)(data.byStrNum));
	cJSON *StrLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "StrLst", StrLst);
	for( UINT32 dwIndex=0; dwIndex<data.byStrNum; ++dwIndex)
	{
		cJSON_AddItemToObject(StrLst, " ", GetJsonDT_TSTRING_MSG(data.astStrLst[dwIndex]));
	}

	return root;
}

INT32 DT_BATTLE_LOG_MSG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 8;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byLogBigType);
	memcpy(pDataBuff + dwOffset, &byLogBigType, sizeof(byLogBigType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byLogSmallType);
	memcpy(pDataBuff + dwOffset, &byLogSmallType, sizeof(byLogSmallType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwLogTime);
	memcpy(pDataBuff + dwOffset, &qwLogTime, sizeof(qwLogTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byParamNum);
	memcpy(pDataBuff + dwOffset, &byParamNum, sizeof(byParamNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	if(byParamNum > MAX_BATTLE_LOG_PARAM_NUM)
	{
		byParamNum = MAX_BATTLE_LOG_PARAM_NUM;
	}
	pstIndex->dwContextLen = byParamNum * sizeof(UINT64) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byParamNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aqwParamLst, byParamNum * sizeof(UINT64));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byStrNum);
	memcpy(pDataBuff + dwOffset, &byStrNum, sizeof(byStrNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	dwContextLenTmp = 0;
	if(byStrNum > MAX_BATTLE_LOG_PARAM_STR)
	{
		byStrNum = MAX_BATTLE_LOG_PARAM_STR;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byStrNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byStrNum; i++)
	{
		dwContextLenTmp += astStrLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_LOG_MSG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byLogBigType) >= pstIndex->dwContextLen)
				{
					memcpy(&byLogBigType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLogBigType, 0, sizeof(byLogBigType));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byLogSmallType) >= pstIndex->dwContextLen)
				{
					memcpy(&byLogSmallType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLogSmallType, 0, sizeof(byLogSmallType));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwLogTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLogTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLogTime, 0, sizeof(qwLogTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byParamNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byParamNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byParamNum, 0, sizeof(byParamNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aqwParamLst) >= dwContextLen) && (wArrNum == byParamNum) && (wArrNum <= MAX_BATTLE_LOG_PARAM_NUM))
				{
					memcpy(&aqwParamLst, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aqwParamLst, 0, sizeof(aqwParamLst));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byStrNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byStrNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStrNum, 0, sizeof(byStrNum));
				}
			}
			break;
		case 8:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byStrNum)
				{
					wArrNum = wArrNum <= MAX_BATTLE_LOG_PARAM_STR ? wArrNum : MAX_BATTLE_LOG_PARAM_STR;
					byStrNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astStrLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astStrLst, 0, sizeof(astStrLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astStrLst, 0, sizeof(astStrLst));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_BATTLE_LOG_MSG_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_LOG_MSG_LST_DATA *pstIn = (DT_BATTLE_LOG_MSG_LST_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_LOG_NUM; i++)
	{
		if(i >= (INT32)pstIn->byLogNum)
			break;
		if(-1 == EncodeDT_BATTLE_LOG_MSG_DATA(&pstIn->astLogData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_BATTLE_LOG_MSG_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_BATTLE_LOG_MSG_LST_DATA *pstOut = (DT_BATTLE_LOG_MSG_LST_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_BATTLE_LOG_NUM; i++)
	{
		if(i >= (INT32)pstOut->byLogNum)
			break;
		if(-1 == DecodeDT_BATTLE_LOG_MSG_DATA(&pstOut->astLogData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_BATTLE_LOG_MSG_LST_DATA(DT_BATTLE_LOG_MSG_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LogNum", (double)(data.byLogNum));
	cJSON *LogData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "LogData", LogData);
	for( UINT32 dwIndex=0; dwIndex<data.byLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(LogData, " ", GetJsonDT_BATTLE_LOG_MSG_DATA(data.astLogData[dwIndex]));
	}

	return root;
}

INT32 DT_BATTLE_LOG_MSG_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byLogNum);
	memcpy(pDataBuff + dwOffset, &byLogNum, sizeof(byLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byLogNum > MAX_BATTLE_LOG_NUM)
	{
		byLogNum = MAX_BATTLE_LOG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byLogNum; i++)
	{
		dwContextLenTmp += astLogData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_BATTLE_LOG_MSG_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLogNum, 0, sizeof(byLogNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byLogNum)
				{
					wArrNum = wArrNum <= MAX_BATTLE_LOG_NUM ? wArrNum : MAX_BATTLE_LOG_NUM;
					byLogNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astLogData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astLogData, 0, sizeof(astLogData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astLogData, 0, sizeof(astLogData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SOUL_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_LST_DATA *pstIn = (DT_SOUL_LST_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wSoulNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_BAG_NUM; i++)
	{
		if(i >= (INT32)pstIn->wSoulNum)
			break;
		if(-1 == EncodeDT_SOUL_DATA(&pstIn->astSoulLstData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SOUL_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_SOUL_LST_DATA *pstOut = (DT_SOUL_LST_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wSoulNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_BAG_NUM; i++)
	{
		if(i >= (INT32)pstOut->wSoulNum)
			break;
		if(-1 == DecodeDT_SOUL_DATA(&pstOut->astSoulLstData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SOUL_LST_DATA(DT_SOUL_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"SoulNum", (double)(data.wSoulNum));
	cJSON *SoulLstData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "SoulLstData", SoulLstData);
	for( UINT32 dwIndex=0; dwIndex<data.wSoulNum; ++dwIndex)
	{
		cJSON_AddItemToObject(SoulLstData, " ", GetJsonDT_SOUL_DATA(data.astSoulLstData[dwIndex]));
	}

	return root;
}

INT32 DT_SOUL_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wSoulNum);
	memcpy(pDataBuff + dwOffset, &wSoulNum, sizeof(wSoulNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wSoulNum > MAX_SOUL_BAG_NUM)
	{
		wSoulNum = MAX_SOUL_BAG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wSoulNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wSoulNum; i++)
	{
		dwContextLenTmp += astSoulLstData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SOUL_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wSoulNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wSoulNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSoulNum, 0, sizeof(wSoulNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wSoulNum)
				{
					wArrNum = wArrNum <= MAX_SOUL_BAG_NUM ? wArrNum : MAX_SOUL_BAG_NUM;
					wSoulNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astSoulLstData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astSoulLstData, 0, sizeof(astSoulLstData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astSoulLstData, 0, sizeof(astSoulLstData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_SOUL_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_SOUL_DATA *pstIn = (DT_PLAYER_SOUL_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == EncodeDT_SOUL_LST_DATA(&pstIn->stSoulBagData, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastTime))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_PRODUCT_TYPE; i++)
	{
		if(-1 == poNetData->AddByte(pstIn->abyTodayCoinCnt[i]))
			return -1;
	}

	if(-1 == poNetData->AddWord(pstIn->wFiveStarCnt))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSixStarCnt))
		return -1;

	if(-1 == EncodeDT_SOUL_POTENCY_LST_DATA(&pstIn->stSoulPotencyBagData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_SOUL_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_SOUL_DATA *pstOut = (DT_PLAYER_SOUL_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == DecodeDT_SOUL_LST_DATA(&pstOut->stSoulBagData, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastTime))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_SOUL_PRODUCT_TYPE; i++)
	{
		if(-1 == poNetData->DelByte(pstOut->abyTodayCoinCnt[i]))
			return -1;
	}

	if(-1 == poNetData->DelWord(pstOut->wFiveStarCnt))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSixStarCnt))
		return -1;

	if(-1 == DecodeDT_SOUL_POTENCY_LST_DATA(&pstOut->stSoulPotencyBagData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_SOUL_DATA(DT_PLAYER_SOUL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddItemToObject(root, "SoulBagData", GetJsonDT_SOUL_LST_DATA(data.stSoulBagData));
	cJSON_AddNumberToObject(root,"LastTime", (double)(data.qwLastTime));
	cJSON *TodayCoinCnt = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "TodayCoinCnt", TodayCoinCnt);
	for( UINT32 dwIndex=0; dwIndex<MAX_SOUL_PRODUCT_TYPE; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"TodayCoinCnt", (double)(data.abyTodayCoinCnt[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"FiveStarCnt", (double)(data.wFiveStarCnt));
	cJSON_AddNumberToObject(root,"SixStarCnt", (double)(data.wSixStarCnt));
	cJSON_AddItemToObject(root, "SoulPotencyBagData", GetJsonDT_SOUL_POTENCY_LST_DATA(data.stSoulPotencyBagData));

	return root;
}

INT32 DT_PLAYER_SOUL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stSoulBagData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastTime);
	memcpy(pDataBuff + dwOffset, &qwLastTime, sizeof(qwLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(abyTodayCoinCnt) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_SOUL_PRODUCT_TYPE;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyTodayCoinCnt, sizeof(abyTodayCoinCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wFiveStarCnt);
	memcpy(pDataBuff + dwOffset, &wFiveStarCnt, sizeof(wFiveStarCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wSixStarCnt);
	memcpy(pDataBuff + dwOffset, &wSixStarCnt, sizeof(wSixStarCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stSoulPotencyBagData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_SOUL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				stSoulBagData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(qwLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastTime, 0, sizeof(qwLastTime));
				}
			}
			break;
		case 4:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyTodayCoinCnt) >= dwContextLen) && (wArrNum <= MAX_SOUL_PRODUCT_TYPE))
				{
					memcpy(&abyTodayCoinCnt, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyTodayCoinCnt, 0, sizeof(abyTodayCoinCnt));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wFiveStarCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wFiveStarCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFiveStarCnt, 0, sizeof(wFiveStarCnt));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wSixStarCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wSixStarCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSixStarCnt, 0, sizeof(wSixStarCnt));
				}
			}
			break;
		case 7:
			{
				stSoulPotencyBagData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MEDAL_DATA(void *pHost, CNetData* poNetData)
{
	DT_MEDAL_DATA *pstIn = (DT_MEDAL_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wMedalID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwActivateTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byIsActivate))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MEDAL_DATA(void *pHost, CNetData* poNetData)
{
	DT_MEDAL_DATA *pstOut = (DT_MEDAL_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wMedalID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwActivateTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byIsActivate))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MEDAL_DATA(DT_MEDAL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MedalID", (double)(data.wMedalID));
	cJSON_AddNumberToObject(root,"ActivateTime", (double)(data.qwActivateTime));
	cJSON_AddNumberToObject(root,"IsActivate", (double)(data.byIsActivate));

	return root;
}

INT32 DT_MEDAL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wMedalID);
	memcpy(pDataBuff + dwOffset, &wMedalID, sizeof(wMedalID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwActivateTime);
	memcpy(pDataBuff + dwOffset, &qwActivateTime, sizeof(qwActivateTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byIsActivate);
	memcpy(pDataBuff + dwOffset, &byIsActivate, sizeof(byIsActivate));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MEDAL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wMedalID) >= pstIndex->dwContextLen)
				{
					memcpy(&wMedalID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMedalID, 0, sizeof(wMedalID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwActivateTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwActivateTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwActivateTime, 0, sizeof(qwActivateTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byIsActivate) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsActivate, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsActivate, 0, sizeof(byIsActivate));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MEDAL_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_MEDAL_LST_DATA *pstIn = (DT_MEDAL_LST_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wMedalNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_MEDAL_NUM; i++)
	{
		if(i >= (INT32)pstIn->wMedalNum)
			break;
		if(-1 == EncodeDT_MEDAL_DATA(&pstIn->astMedalLstData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MEDAL_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_MEDAL_LST_DATA *pstOut = (DT_MEDAL_LST_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wMedalNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_MEDAL_NUM; i++)
	{
		if(i >= (INT32)pstOut->wMedalNum)
			break;
		if(-1 == DecodeDT_MEDAL_DATA(&pstOut->astMedalLstData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MEDAL_LST_DATA(DT_MEDAL_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"MedalNum", (double)(data.wMedalNum));
	cJSON *MedalLstData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "MedalLstData", MedalLstData);
	for( UINT32 dwIndex=0; dwIndex<data.wMedalNum; ++dwIndex)
	{
		cJSON_AddItemToObject(MedalLstData, " ", GetJsonDT_MEDAL_DATA(data.astMedalLstData[dwIndex]));
	}

	return root;
}

INT32 DT_MEDAL_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wMedalNum);
	memcpy(pDataBuff + dwOffset, &wMedalNum, sizeof(wMedalNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wMedalNum > MAX_MEDAL_NUM)
	{
		wMedalNum = MAX_MEDAL_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wMedalNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wMedalNum; i++)
	{
		dwContextLenTmp += astMedalLstData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MEDAL_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wMedalNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wMedalNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMedalNum, 0, sizeof(wMedalNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wMedalNum)
				{
					wArrNum = wArrNum <= MAX_MEDAL_NUM ? wArrNum : MAX_MEDAL_NUM;
					wMedalNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astMedalLstData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astMedalLstData, 0, sizeof(astMedalLstData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astMedalLstData, 0, sizeof(astMedalLstData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_MEDAL_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_MEDAL_BASE_DATA *pstIn = (DT_MEDAL_BASE_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwLoginDayNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLoginTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwBuyPhystrength))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwInterceptNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEscortNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRockMoneyNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwNormalGatherNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGoldGatherNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwWorshipPlayer1Num))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwWorshipPlayer2Num))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwWorshipPlayer3Num))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwWorshipGod1Num))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwWorshipGod2Num))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwWorshipGod3Num))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwZTSNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSmileNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwArrestNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDriveNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwTowerResetNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwEliteInstanceResetNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGVEJoinNum))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRaceRank))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastRaceTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_MEDAL_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_MEDAL_BASE_DATA *pstOut = (DT_MEDAL_BASE_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwLoginDayNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLoginTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwBuyPhystrength))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwInterceptNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEscortNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRockMoneyNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwNormalGatherNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGoldGatherNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwWorshipPlayer1Num))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwWorshipPlayer2Num))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwWorshipPlayer3Num))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwWorshipGod1Num))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwWorshipGod2Num))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwWorshipGod3Num))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwZTSNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSmileNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwArrestNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDriveNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwTowerResetNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwEliteInstanceResetNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGVEJoinNum))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRaceRank))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastRaceTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_MEDAL_BASE_DATA(DT_MEDAL_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"LoginDayNum", (double)(data.dwLoginDayNum));
	cJSON_AddNumberToObject(root,"LoginTime", (double)(data.qwLoginTime));
	cJSON_AddNumberToObject(root,"BuyPhystrength", (double)(data.dwBuyPhystrength));
	cJSON_AddNumberToObject(root,"InterceptNum", (double)(data.dwInterceptNum));
	cJSON_AddNumberToObject(root,"EscortNum", (double)(data.dwEscortNum));
	cJSON_AddNumberToObject(root,"RockMoneyNum", (double)(data.dwRockMoneyNum));
	cJSON_AddNumberToObject(root,"NormalGatherNum", (double)(data.dwNormalGatherNum));
	cJSON_AddNumberToObject(root,"GoldGatherNum", (double)(data.dwGoldGatherNum));
	cJSON_AddNumberToObject(root,"WorshipPlayer1Num", (double)(data.dwWorshipPlayer1Num));
	cJSON_AddNumberToObject(root,"WorshipPlayer2Num", (double)(data.dwWorshipPlayer2Num));
	cJSON_AddNumberToObject(root,"WorshipPlayer3Num", (double)(data.dwWorshipPlayer3Num));
	cJSON_AddNumberToObject(root,"WorshipGod1Num", (double)(data.dwWorshipGod1Num));
	cJSON_AddNumberToObject(root,"WorshipGod2Num", (double)(data.dwWorshipGod2Num));
	cJSON_AddNumberToObject(root,"WorshipGod3Num", (double)(data.dwWorshipGod3Num));
	cJSON_AddNumberToObject(root,"ZTSNum", (double)(data.dwZTSNum));
	cJSON_AddNumberToObject(root,"SmileNum", (double)(data.dwSmileNum));
	cJSON_AddNumberToObject(root,"ArrestNum", (double)(data.dwArrestNum));
	cJSON_AddNumberToObject(root,"DriveNum", (double)(data.dwDriveNum));
	cJSON_AddNumberToObject(root,"TowerResetNum", (double)(data.dwTowerResetNum));
	cJSON_AddNumberToObject(root,"EliteInstanceResetNum", (double)(data.dwEliteInstanceResetNum));
	cJSON_AddNumberToObject(root,"GVEJoinNum", (double)(data.dwGVEJoinNum));
	cJSON_AddNumberToObject(root,"RaceRank", (double)(data.dwRaceRank));
	cJSON_AddNumberToObject(root,"LastRaceTime", (double)(data.qwLastRaceTime));

	return root;
}

INT32 DT_MEDAL_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 23;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwLoginDayNum);
	memcpy(pDataBuff + dwOffset, &dwLoginDayNum, sizeof(dwLoginDayNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwLoginTime);
	memcpy(pDataBuff + dwOffset, &qwLoginTime, sizeof(qwLoginTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwBuyPhystrength);
	memcpy(pDataBuff + dwOffset, &dwBuyPhystrength, sizeof(dwBuyPhystrength));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwInterceptNum);
	memcpy(pDataBuff + dwOffset, &dwInterceptNum, sizeof(dwInterceptNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwEscortNum);
	memcpy(pDataBuff + dwOffset, &dwEscortNum, sizeof(dwEscortNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwRockMoneyNum);
	memcpy(pDataBuff + dwOffset, &dwRockMoneyNum, sizeof(dwRockMoneyNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(dwNormalGatherNum);
	memcpy(pDataBuff + dwOffset, &dwNormalGatherNum, sizeof(dwNormalGatherNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwGoldGatherNum);
	memcpy(pDataBuff + dwOffset, &dwGoldGatherNum, sizeof(dwGoldGatherNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(dwWorshipPlayer1Num);
	memcpy(pDataBuff + dwOffset, &dwWorshipPlayer1Num, sizeof(dwWorshipPlayer1Num));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(dwWorshipPlayer2Num);
	memcpy(pDataBuff + dwOffset, &dwWorshipPlayer2Num, sizeof(dwWorshipPlayer2Num));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(dwWorshipPlayer3Num);
	memcpy(pDataBuff + dwOffset, &dwWorshipPlayer3Num, sizeof(dwWorshipPlayer3Num));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(dwWorshipGod1Num);
	memcpy(pDataBuff + dwOffset, &dwWorshipGod1Num, sizeof(dwWorshipGod1Num));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(dwWorshipGod2Num);
	memcpy(pDataBuff + dwOffset, &dwWorshipGod2Num, sizeof(dwWorshipGod2Num));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(dwWorshipGod3Num);
	memcpy(pDataBuff + dwOffset, &dwWorshipGod3Num, sizeof(dwWorshipGod3Num));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(dwZTSNum);
	memcpy(pDataBuff + dwOffset, &dwZTSNum, sizeof(dwZTSNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = sizeof(dwSmileNum);
	memcpy(pDataBuff + dwOffset, &dwSmileNum, sizeof(dwSmileNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(dwArrestNum);
	memcpy(pDataBuff + dwOffset, &dwArrestNum, sizeof(dwArrestNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(dwDriveNum);
	memcpy(pDataBuff + dwOffset, &dwDriveNum, sizeof(dwDriveNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 19;
	pstIndex->dwContextLen = sizeof(dwTowerResetNum);
	memcpy(pDataBuff + dwOffset, &dwTowerResetNum, sizeof(dwTowerResetNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 20;
	pstIndex->dwContextLen = sizeof(dwEliteInstanceResetNum);
	memcpy(pDataBuff + dwOffset, &dwEliteInstanceResetNum, sizeof(dwEliteInstanceResetNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 21;
	pstIndex->dwContextLen = sizeof(dwGVEJoinNum);
	memcpy(pDataBuff + dwOffset, &dwGVEJoinNum, sizeof(dwGVEJoinNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 22;
	pstIndex->dwContextLen = sizeof(dwRaceRank);
	memcpy(pDataBuff + dwOffset, &dwRaceRank, sizeof(dwRaceRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 23;
	pstIndex->dwContextLen = sizeof(qwLastRaceTime);
	memcpy(pDataBuff + dwOffset, &qwLastRaceTime, sizeof(qwLastRaceTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_MEDAL_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwLoginDayNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwLoginDayNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwLoginDayNum, 0, sizeof(dwLoginDayNum));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwLoginTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLoginTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLoginTime, 0, sizeof(qwLoginTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwBuyPhystrength) >= pstIndex->dwContextLen)
				{
					memcpy(&dwBuyPhystrength, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwBuyPhystrength, 0, sizeof(dwBuyPhystrength));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwInterceptNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwInterceptNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwInterceptNum, 0, sizeof(dwInterceptNum));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwEscortNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEscortNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEscortNum, 0, sizeof(dwEscortNum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwRockMoneyNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRockMoneyNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRockMoneyNum, 0, sizeof(dwRockMoneyNum));
				}
			}
			break;
		case 7:
			{
				if(sizeof(dwNormalGatherNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwNormalGatherNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwNormalGatherNum, 0, sizeof(dwNormalGatherNum));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwGoldGatherNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGoldGatherNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGoldGatherNum, 0, sizeof(dwGoldGatherNum));
				}
			}
			break;
		case 9:
			{
				if(sizeof(dwWorshipPlayer1Num) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWorshipPlayer1Num, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWorshipPlayer1Num, 0, sizeof(dwWorshipPlayer1Num));
				}
			}
			break;
		case 10:
			{
				if(sizeof(dwWorshipPlayer2Num) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWorshipPlayer2Num, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWorshipPlayer2Num, 0, sizeof(dwWorshipPlayer2Num));
				}
			}
			break;
		case 11:
			{
				if(sizeof(dwWorshipPlayer3Num) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWorshipPlayer3Num, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWorshipPlayer3Num, 0, sizeof(dwWorshipPlayer3Num));
				}
			}
			break;
		case 12:
			{
				if(sizeof(dwWorshipGod1Num) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWorshipGod1Num, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWorshipGod1Num, 0, sizeof(dwWorshipGod1Num));
				}
			}
			break;
		case 13:
			{
				if(sizeof(dwWorshipGod2Num) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWorshipGod2Num, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWorshipGod2Num, 0, sizeof(dwWorshipGod2Num));
				}
			}
			break;
		case 14:
			{
				if(sizeof(dwWorshipGod3Num) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWorshipGod3Num, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWorshipGod3Num, 0, sizeof(dwWorshipGod3Num));
				}
			}
			break;
		case 15:
			{
				if(sizeof(dwZTSNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwZTSNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwZTSNum, 0, sizeof(dwZTSNum));
				}
			}
			break;
		case 16:
			{
				if(sizeof(dwSmileNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSmileNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSmileNum, 0, sizeof(dwSmileNum));
				}
			}
			break;
		case 17:
			{
				if(sizeof(dwArrestNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwArrestNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwArrestNum, 0, sizeof(dwArrestNum));
				}
			}
			break;
		case 18:
			{
				if(sizeof(dwDriveNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDriveNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDriveNum, 0, sizeof(dwDriveNum));
				}
			}
			break;
		case 19:
			{
				if(sizeof(dwTowerResetNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwTowerResetNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwTowerResetNum, 0, sizeof(dwTowerResetNum));
				}
			}
			break;
		case 20:
			{
				if(sizeof(dwEliteInstanceResetNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwEliteInstanceResetNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwEliteInstanceResetNum, 0, sizeof(dwEliteInstanceResetNum));
				}
			}
			break;
		case 21:
			{
				if(sizeof(dwGVEJoinNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGVEJoinNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGVEJoinNum, 0, sizeof(dwGVEJoinNum));
				}
			}
			break;
		case 22:
			{
				if(sizeof(dwRaceRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRaceRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRaceRank, 0, sizeof(dwRaceRank));
				}
			}
			break;
		case 23:
			{
				if(sizeof(qwLastRaceTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastRaceTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastRaceTime, 0, sizeof(qwLastRaceTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_MEDAL_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_MEDAL_DATA *pstIn = (DT_PLAYER_MEDAL_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == EncodeDT_MEDAL_LST_DATA(&pstIn->stMealData, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastUpdateTime))
		return -1;

	if(-1 == EncodeDT_MEDAL_BASE_DATA(&pstIn->stMedalBaseData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_MEDAL_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_MEDAL_DATA *pstOut = (DT_PLAYER_MEDAL_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == DecodeDT_MEDAL_LST_DATA(&pstOut->stMealData, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastUpdateTime))
		return -1;

	if(-1 == DecodeDT_MEDAL_BASE_DATA(&pstOut->stMedalBaseData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_MEDAL_DATA(DT_PLAYER_MEDAL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddItemToObject(root, "MealData", GetJsonDT_MEDAL_LST_DATA(data.stMealData));
	cJSON_AddNumberToObject(root,"LastUpdateTime", (double)(data.qwLastUpdateTime));
	cJSON_AddItemToObject(root, "MedalBaseData", GetJsonDT_MEDAL_BASE_DATA(data.stMedalBaseData));

	return root;
}

INT32 DT_PLAYER_MEDAL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stMealData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwLastUpdateTime);
	memcpy(pDataBuff + dwOffset, &qwLastUpdateTime, sizeof(qwLastUpdateTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stMedalBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_MEDAL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				stMealData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(qwLastUpdateTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastUpdateTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastUpdateTime, 0, sizeof(qwLastUpdateTime));
				}
			}
			break;
		case 4:
			{
				stMedalBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PET_WASHQUALITY_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_WASHQUALITY_DATA *pstIn = (DT_PET_WASHQUALITY_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byIsCanWash))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurWashQuality))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPsychicVal))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwMaxPsychicVal))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PET_WASHQUALITY_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_WASHQUALITY_DATA *pstOut = (DT_PET_WASHQUALITY_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byIsCanWash))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurWashQuality))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPsychicVal))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwMaxPsychicVal))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PET_WASHQUALITY_DATA(DT_PET_WASHQUALITY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"IsCanWash", (double)(data.byIsCanWash));
	cJSON_AddNumberToObject(root,"CurWashQuality", (double)(data.byCurWashQuality));
	cJSON_AddNumberToObject(root,"PsychicVal", (double)(data.dwPsychicVal));
	cJSON_AddNumberToObject(root,"MaxPsychicVal", (double)(data.dwMaxPsychicVal));

	return root;
}

INT32 DT_PET_WASHQUALITY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byIsCanWash);
	memcpy(pDataBuff + dwOffset, &byIsCanWash, sizeof(byIsCanWash));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byCurWashQuality);
	memcpy(pDataBuff + dwOffset, &byCurWashQuality, sizeof(byCurWashQuality));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwPsychicVal);
	memcpy(pDataBuff + dwOffset, &dwPsychicVal, sizeof(dwPsychicVal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwMaxPsychicVal);
	memcpy(pDataBuff + dwOffset, &dwMaxPsychicVal, sizeof(dwMaxPsychicVal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PET_WASHQUALITY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byIsCanWash) >= pstIndex->dwContextLen)
				{
					memcpy(&byIsCanWash, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byIsCanWash, 0, sizeof(byIsCanWash));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byCurWashQuality) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurWashQuality, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurWashQuality, 0, sizeof(byCurWashQuality));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwPsychicVal) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPsychicVal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPsychicVal, 0, sizeof(dwPsychicVal));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwMaxPsychicVal) >= pstIndex->dwContextLen)
				{
					memcpy(&dwMaxPsychicVal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwMaxPsychicVal, 0, sizeof(dwMaxPsychicVal));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PET_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_DATA *pstIn = (DT_PET_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPetId))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPetCfgId))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byStarLv))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLv))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwLvExp))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszPetName, sizeof(pstIn->aszPetName)))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_FEED_FRUIT_CNT; i++)
	{
		if(-1 == poNetData->AddByte(pstIn->abyFeedFruit[i]))
			return -1;
	}

	if(-1 == poNetData->AddByte(pstIn->byPetState))
		return -1;

	for(i = 0; i < MAX_PET_WASH_PSYCHIC_CELL_CNT; i++)
	{
		if(-1 == EncodeDT_PET_WASHQUALITY_DATA(&pstIn->astWashQualityData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PET_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_DATA *pstOut = (DT_PET_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPetId))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPetCfgId))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byStarLv))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLv))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwLvExp))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszPetName, sizeof(pstOut->aszPetName)))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_FEED_FRUIT_CNT; i++)
	{
		if(-1 == poNetData->DelByte(pstOut->abyFeedFruit[i]))
			return -1;
	}

	if(-1 == poNetData->DelByte(pstOut->byPetState))
		return -1;

		for(i = 0; i < MAX_PET_WASH_PSYCHIC_CELL_CNT; i++)
		{
			if(-1 == DecodeDT_PET_WASHQUALITY_DATA(&pstOut->astWashQualityData[i], poNetData))
				return -1;
		}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PET_DATA(DT_PET_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PetId", (double)(data.wPetId));
	cJSON_AddNumberToObject(root,"PetCfgId", (double)(data.wPetCfgId));
	cJSON_AddNumberToObject(root,"StarLv", (double)(data.byStarLv));
	cJSON_AddNumberToObject(root,"Lv", (double)(data.wLv));
	cJSON_AddNumberToObject(root,"LvExp", (double)(data.dwLvExp));
	cJSON_AddStringToObject(root,"PetName", data.aszPetName );
	cJSON *FeedFruit = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FeedFruit", FeedFruit);
	for( UINT32 dwIndex=0; dwIndex<MAX_PET_FEED_FRUIT_CNT; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"FeedFruit", (double)(data.abyFeedFruit[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"PetState", (double)(data.byPetState));
	cJSON *WashQualityData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "WashQualityData", WashQualityData);
	for( UINT32 dwIndex=0; dwIndex<MAX_PET_WASH_PSYCHIC_CELL_CNT; ++dwIndex)
	{
		cJSON_AddItemToObject(WashQualityData, " ", GetJsonDT_PET_WASHQUALITY_DATA(data.astWashQualityData[dwIndex]));
	}

	return root;
}

INT32 DT_PET_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPetId);
	memcpy(pDataBuff + dwOffset, &wPetId, sizeof(wPetId));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wPetCfgId);
	memcpy(pDataBuff + dwOffset, &wPetCfgId, sizeof(wPetCfgId));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byStarLv);
	memcpy(pDataBuff + dwOffset, &byStarLv, sizeof(byStarLv));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wLv);
	memcpy(pDataBuff + dwOffset, &wLv, sizeof(wLv));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwLvExp);
	memcpy(pDataBuff + dwOffset, &dwLvExp, sizeof(dwLvExp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(aszPetName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_PET_NAME_LENGTH;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszPetName, sizeof(aszPetName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(abyFeedFruit) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_PET_FEED_FRUIT_CNT;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyFeedFruit, sizeof(abyFeedFruit));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byPetState);
	memcpy(pDataBuff + dwOffset, &byPetState, sizeof(byPetState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_PET_WASH_PSYCHIC_CELL_CNT;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_PET_WASH_PSYCHIC_CELL_CNT; i++)
	{
		dwContextLenTmp += astWashQualityData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PET_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPetId) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetId, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetId, 0, sizeof(wPetId));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wPetCfgId) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetCfgId, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetCfgId, 0, sizeof(wPetCfgId));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byStarLv) >= pstIndex->dwContextLen)
				{
					memcpy(&byStarLv, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byStarLv, 0, sizeof(byStarLv));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wLv) >= pstIndex->dwContextLen)
				{
					memcpy(&wLv, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLv, 0, sizeof(wLv));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwLvExp) >= pstIndex->dwContextLen)
				{
					memcpy(&dwLvExp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwLvExp, 0, sizeof(dwLvExp));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszPetName) >= dwContextLen) && (wArrNum <= MAX_PET_NAME_LENGTH))
				{
					memcpy(&aszPetName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszPetName, 0, sizeof(aszPetName));
				}
			}
			break;
		case 7:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyFeedFruit) >= dwContextLen) && (wArrNum <= MAX_PET_FEED_FRUIT_CNT))
				{
					memcpy(&abyFeedFruit, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyFeedFruit, 0, sizeof(abyFeedFruit));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byPetState) >= pstIndex->dwContextLen)
				{
					memcpy(&byPetState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPetState, 0, sizeof(byPetState));
				}
			}
			break;
		case 9:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_PET_WASH_PSYCHIC_CELL_CNT ? wArrNum : MAX_PET_WASH_PSYCHIC_CELL_CNT;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astWashQualityData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astWashQualityData, 0, sizeof(astWashQualityData));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NEIDAN_DATA(void *pHost, CNetData* poNetData)
{
	DT_NEIDAN_DATA *pstIn = (DT_NEIDAN_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNeiDanID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNeiDanIdx))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNeiDanLevel))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwNeiDanExcpetion))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NEIDAN_DATA(void *pHost, CNetData* poNetData)
{
	DT_NEIDAN_DATA *pstOut = (DT_NEIDAN_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNeiDanID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNeiDanIdx))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNeiDanLevel))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwNeiDanExcpetion))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NEIDAN_DATA(DT_NEIDAN_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"NeiDanID", (double)(data.wNeiDanID));
	cJSON_AddNumberToObject(root,"NeiDanIdx", (double)(data.wNeiDanIdx));
	cJSON_AddNumberToObject(root,"NeiDanLevel", (double)(data.wNeiDanLevel));
	cJSON_AddNumberToObject(root,"NeiDanExcpetion", (double)(data.qwNeiDanExcpetion));

	return root;
}

INT32 DT_NEIDAN_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNeiDanID);
	memcpy(pDataBuff + dwOffset, &wNeiDanID, sizeof(wNeiDanID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wNeiDanIdx);
	memcpy(pDataBuff + dwOffset, &wNeiDanIdx, sizeof(wNeiDanIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wNeiDanLevel);
	memcpy(pDataBuff + dwOffset, &wNeiDanLevel, sizeof(wNeiDanLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwNeiDanExcpetion);
	memcpy(pDataBuff + dwOffset, &qwNeiDanExcpetion, sizeof(qwNeiDanExcpetion));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NEIDAN_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNeiDanID) >= pstIndex->dwContextLen)
				{
					memcpy(&wNeiDanID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNeiDanID, 0, sizeof(wNeiDanID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wNeiDanIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&wNeiDanIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNeiDanIdx, 0, sizeof(wNeiDanIdx));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wNeiDanLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wNeiDanLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNeiDanLevel, 0, sizeof(wNeiDanLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwNeiDanExcpetion) >= pstIndex->dwContextLen)
				{
					memcpy(&qwNeiDanExcpetion, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwNeiDanExcpetion, 0, sizeof(qwNeiDanExcpetion));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PET_NEIDAN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_PET_NEIDAN_DATA_LST *pstIn = (DT_PET_NEIDAN_DATA_LST*)pHost;

	INT32 i;
	for(i = 0; i < MAX_PET_NEIDAN_NUM; i++)
	{
		if(-1 == EncodeDT_NEIDAN_DATA(&pstIn->astNeiDanInfoLst[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PET_NEIDAN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_PET_NEIDAN_DATA_LST *pstOut = (DT_PET_NEIDAN_DATA_LST*)pHost;

	INT32 i;
		for(i = 0; i < MAX_PET_NEIDAN_NUM; i++)
		{
			if(-1 == DecodeDT_NEIDAN_DATA(&pstOut->astNeiDanInfoLst[i], poNetData))
				return -1;
		}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PET_NEIDAN_DATA_LST(DT_PET_NEIDAN_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON *NeiDanInfoLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "NeiDanInfoLst", NeiDanInfoLst);
	for( UINT32 dwIndex=0; dwIndex<MAX_PET_NEIDAN_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(NeiDanInfoLst, " ", GetJsonDT_NEIDAN_DATA(data.astNeiDanInfoLst[dwIndex]));
	}

	return root;
}

INT32 DT_PET_NEIDAN_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 1;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_PET_NEIDAN_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_PET_NEIDAN_NUM; i++)
	{
		dwContextLenTmp += astNeiDanInfoLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PET_NEIDAN_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_PET_NEIDAN_NUM ? wArrNum : MAX_PET_NEIDAN_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astNeiDanInfoLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astNeiDanInfoLst, 0, sizeof(astNeiDanInfoLst));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_NEIDAN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_NEIDAN_DATA_LST *pstIn = (DT_PLAYER_NEIDAN_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPetNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_NUM; i++)
	{
		if(i >= (INT32)pstIn->wPetNum)
			break;
		if(-1 == EncodeDT_PET_NEIDAN_DATA_LST(&pstIn->astNeiDanInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_NEIDAN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_NEIDAN_DATA_LST *pstOut = (DT_PLAYER_NEIDAN_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPetNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_NUM; i++)
	{
		if(i >= (INT32)pstOut->wPetNum)
			break;
		if(-1 == DecodeDT_PET_NEIDAN_DATA_LST(&pstOut->astNeiDanInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_NEIDAN_DATA_LST(DT_PLAYER_NEIDAN_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PetNum", (double)(data.wPetNum));
	cJSON *NeiDanInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "NeiDanInfo", NeiDanInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wPetNum; ++dwIndex)
	{
		cJSON_AddItemToObject(NeiDanInfo, " ", GetJsonDT_PET_NEIDAN_DATA_LST(data.astNeiDanInfo[dwIndex]));
	}

	return root;
}

INT32 DT_PLAYER_NEIDAN_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPetNum);
	memcpy(pDataBuff + dwOffset, &wPetNum, sizeof(wPetNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wPetNum > MAX_PET_NUM)
	{
		wPetNum = MAX_PET_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wPetNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wPetNum; i++)
	{
		dwContextLenTmp += astNeiDanInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_NEIDAN_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPetNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetNum, 0, sizeof(wPetNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wPetNum)
				{
					wArrNum = wArrNum <= MAX_PET_NUM ? wArrNum : MAX_PET_NUM;
					wPetNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astNeiDanInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astNeiDanInfo, 0, sizeof(astNeiDanInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astNeiDanInfo, 0, sizeof(astNeiDanInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_NEIDAN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_NEIDAN_DATA_LST *pstIn = (DT_NEIDAN_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wNeiDanNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEI_DAN_BAG_NUM; i++)
	{
		if(i >= (INT32)pstIn->wNeiDanNum)
			break;
		if(-1 == EncodeDT_NEIDAN_DATA(&pstIn->astNeiDanInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_NEIDAN_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_NEIDAN_DATA_LST *pstOut = (DT_NEIDAN_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wNeiDanNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_NEI_DAN_BAG_NUM; i++)
	{
		if(i >= (INT32)pstOut->wNeiDanNum)
			break;
		if(-1 == DecodeDT_NEIDAN_DATA(&pstOut->astNeiDanInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_NEIDAN_DATA_LST(DT_NEIDAN_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"NeiDanNum", (double)(data.wNeiDanNum));
	cJSON *NeiDanInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "NeiDanInfo", NeiDanInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wNeiDanNum; ++dwIndex)
	{
		cJSON_AddItemToObject(NeiDanInfo, " ", GetJsonDT_NEIDAN_DATA(data.astNeiDanInfo[dwIndex]));
	}

	return root;
}

INT32 DT_NEIDAN_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wNeiDanNum);
	memcpy(pDataBuff + dwOffset, &wNeiDanNum, sizeof(wNeiDanNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wNeiDanNum > MAX_NEI_DAN_BAG_NUM)
	{
		wNeiDanNum = MAX_NEI_DAN_BAG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wNeiDanNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wNeiDanNum; i++)
	{
		dwContextLenTmp += astNeiDanInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_NEIDAN_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wNeiDanNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNeiDanNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNeiDanNum, 0, sizeof(wNeiDanNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wNeiDanNum)
				{
					wArrNum = wArrNum <= MAX_NEI_DAN_BAG_NUM ? wArrNum : MAX_NEI_DAN_BAG_NUM;
					wNeiDanNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astNeiDanInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astNeiDanInfo, 0, sizeof(astNeiDanInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astNeiDanInfo, 0, sizeof(astNeiDanInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PET_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_PET_DATA_LIST *pstIn = (DT_PET_DATA_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPetNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_NUM; i++)
	{
		if(i >= (INT32)pstIn->wPetNum)
			break;
		if(-1 == EncodeDT_PET_DATA(&pstIn->astPetData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PET_DATA_LIST(void *pHost, CNetData* poNetData)
{
	DT_PET_DATA_LIST *pstOut = (DT_PET_DATA_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPetNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_NUM; i++)
	{
		if(i >= (INT32)pstOut->wPetNum)
			break;
		if(-1 == DecodeDT_PET_DATA(&pstOut->astPetData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PET_DATA_LIST(DT_PET_DATA_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PetNum", (double)(data.wPetNum));
	cJSON *PetData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PetData", PetData);
	for( UINT32 dwIndex=0; dwIndex<data.wPetNum; ++dwIndex)
	{
		cJSON_AddItemToObject(PetData, " ", GetJsonDT_PET_DATA(data.astPetData[dwIndex]));
	}

	return root;
}

INT32 DT_PET_DATA_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPetNum);
	memcpy(pDataBuff + dwOffset, &wPetNum, sizeof(wPetNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wPetNum > MAX_PET_NUM)
	{
		wPetNum = MAX_PET_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wPetNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wPetNum; i++)
	{
		dwContextLenTmp += astPetData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PET_DATA_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPetNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetNum, 0, sizeof(wPetNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wPetNum)
				{
					wArrNum = wArrNum <= MAX_PET_NUM ? wArrNum : MAX_PET_NUM;
					wPetNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astPetData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astPetData, 0, sizeof(astPetData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astPetData, 0, sizeof(astPetData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PET_CALL_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_CALL_DATA *pstIn = (DT_PET_CALL_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPetCfgID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPetCallNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PET_CALL_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_CALL_DATA *pstOut = (DT_PET_CALL_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPetCfgID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPetCallNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PET_CALL_DATA(DT_PET_CALL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PetCfgID", (double)(data.wPetCfgID));
	cJSON_AddNumberToObject(root,"PetCallNum", (double)(data.dwPetCallNum));

	return root;
}

INT32 DT_PET_CALL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPetCfgID);
	memcpy(pDataBuff + dwOffset, &wPetCfgID, sizeof(wPetCfgID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwPetCallNum);
	memcpy(pDataBuff + dwOffset, &dwPetCallNum, sizeof(dwPetCallNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PET_CALL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPetCfgID) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetCfgID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetCfgID, 0, sizeof(wPetCfgID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwPetCallNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPetCallNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPetCallNum, 0, sizeof(dwPetCallNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PET_CALL_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_CALL_LST_DATA *pstIn = (DT_PET_CALL_LST_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wPetNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_NUM; i++)
	{
		if(i >= (INT32)pstIn->wPetNum)
			break;
		if(-1 == EncodeDT_PET_CALL_DATA(&pstIn->astCallInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PET_CALL_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_PET_CALL_LST_DATA *pstOut = (DT_PET_CALL_LST_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wPetNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_PET_NUM; i++)
	{
		if(i >= (INT32)pstOut->wPetNum)
			break;
		if(-1 == DecodeDT_PET_CALL_DATA(&pstOut->astCallInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PET_CALL_LST_DATA(DT_PET_CALL_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PetNum", (double)(data.wPetNum));
	cJSON *CallInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "CallInfo", CallInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wPetNum; ++dwIndex)
	{
		cJSON_AddItemToObject(CallInfo, " ", GetJsonDT_PET_CALL_DATA(data.astCallInfo[dwIndex]));
	}

	return root;
}

INT32 DT_PET_CALL_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wPetNum);
	memcpy(pDataBuff + dwOffset, &wPetNum, sizeof(wPetNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wPetNum > MAX_PET_NUM)
	{
		wPetNum = MAX_PET_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wPetNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wPetNum; i++)
	{
		dwContextLenTmp += astCallInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PET_CALL_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wPetNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPetNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPetNum, 0, sizeof(wPetNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wPetNum)
				{
					wArrNum = wArrNum <= MAX_PET_NUM ? wArrNum : MAX_PET_NUM;
					wPetNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astCallInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astCallInfo, 0, sizeof(astCallInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astCallInfo, 0, sizeof(astCallInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_HP_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_HP_DATA *pstIn = (DT_HERO_HP_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wHeroID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHeroHP))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFormationIdx))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_HP_DATA(void *pHost, CNetData* poNetData)
{
	DT_HERO_HP_DATA *pstOut = (DT_HERO_HP_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wHeroID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHeroHP))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFormationIdx))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_HP_DATA(DT_HERO_HP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroID", (double)(data.wHeroID));
	cJSON_AddNumberToObject(root,"HeroHP", (double)(data.dwHeroHP));
	cJSON_AddNumberToObject(root,"FormationIdx", (double)(data.byFormationIdx));

	return root;
}

INT32 DT_HERO_HP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wHeroID);
	memcpy(pDataBuff + dwOffset, &wHeroID, sizeof(wHeroID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwHeroHP);
	memcpy(pDataBuff + dwOffset, &dwHeroHP, sizeof(dwHeroHP));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byFormationIdx);
	memcpy(pDataBuff + dwOffset, &byFormationIdx, sizeof(byFormationIdx));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_HP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wHeroID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroID, 0, sizeof(wHeroID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwHeroHP) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHeroHP, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHeroHP, 0, sizeof(dwHeroHP));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byFormationIdx) >= pstIndex->dwContextLen)
				{
					memcpy(&byFormationIdx, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFormationIdx, 0, sizeof(byFormationIdx));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_HERO_HP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_HERO_HP_DATA_LST *pstIn = (DT_HERO_HP_DATA_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHeroNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstIn->byHeroNum)
			break;
		if(-1 == EncodeDT_HERO_HP_DATA(&pstIn->astHeroHPLst[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_HERO_HP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_HERO_HP_DATA_LST *pstOut = (DT_HERO_HP_DATA_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHeroNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FORMATION_IDX_NUM; i++)
	{
		if(i >= (INT32)pstOut->byHeroNum)
			break;
		if(-1 == DecodeDT_HERO_HP_DATA(&pstOut->astHeroHPLst[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_HERO_HP_DATA_LST(DT_HERO_HP_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HeroNum", (double)(data.byHeroNum));
	cJSON *HeroHPLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "HeroHPLst", HeroHPLst);
	for( UINT32 dwIndex=0; dwIndex<data.byHeroNum; ++dwIndex)
	{
		cJSON_AddItemToObject(HeroHPLst, " ", GetJsonDT_HERO_HP_DATA(data.astHeroHPLst[dwIndex]));
	}

	return root;
}

INT32 DT_HERO_HP_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHeroNum);
	memcpy(pDataBuff + dwOffset, &byHeroNum, sizeof(byHeroNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byHeroNum > MAX_FORMATION_IDX_NUM)
	{
		byHeroNum = MAX_FORMATION_IDX_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byHeroNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byHeroNum; i++)
	{
		dwContextLenTmp += astHeroHPLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_HERO_HP_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHeroNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byHeroNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHeroNum, 0, sizeof(byHeroNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byHeroNum)
				{
					wArrNum = wArrNum <= MAX_FORMATION_IDX_NUM ? wArrNum : MAX_FORMATION_IDX_NUM;
					byHeroNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astHeroHPLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astHeroHPLst, 0, sizeof(astHeroHPLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astHeroHPLst, 0, sizeof(astHeroHPLst));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_PET_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_PET_DATA *pstIn = (DT_PLAYER_PET_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byHaveDataFlag))
		return -1;

	if(-1 == EncodeDT_PET_DATA_LIST(&pstIn->stPetDataLst, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwNormalLastTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwGoodLastTime))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wNormalProductNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wGoodProductNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwProductLastTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPetScore))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastFeedTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwLeftFreeFeedCnt))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwVIPFeedCnt))
		return -1;

	if(-1 == EncodeDT_PET_CALL_LST_DATA(&pstIn->stPetCallData, poNetData))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wFreeNormalProductCnt))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCallFlag))
		return -1;

	if(-1 == EncodeDT_PLAYER_NEIDAN_DATA_LST(&pstIn->stPetNeiDan, poNetData))
		return -1;

	if(-1 == EncodeDT_NEIDAN_DATA_LST(&pstIn->stPetNeiDanBag, poNetData))
		return -1;

	if(-1 == EncodeDT_HERO_HP_DATA_LST(&pstIn->stHeroLstInfo, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_PET_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_PET_DATA *pstOut = (DT_PLAYER_PET_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byHaveDataFlag))
		return -1;

	if(-1 == DecodeDT_PET_DATA_LIST(&pstOut->stPetDataLst, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwNormalLastTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwGoodLastTime))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wNormalProductNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wGoodProductNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwProductLastTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPetScore))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastFeedTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwLeftFreeFeedCnt))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwVIPFeedCnt))
		return -1;

	if(-1 == DecodeDT_PET_CALL_LST_DATA(&pstOut->stPetCallData, poNetData))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wFreeNormalProductCnt))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCallFlag))
		return -1;

	if(-1 == DecodeDT_PLAYER_NEIDAN_DATA_LST(&pstOut->stPetNeiDan, poNetData))
		return -1;

	if(-1 == DecodeDT_NEIDAN_DATA_LST(&pstOut->stPetNeiDanBag, poNetData))
		return -1;

	if(-1 == DecodeDT_HERO_HP_DATA_LST(&pstOut->stHeroLstInfo, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_PET_DATA(DT_PLAYER_PET_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"HaveDataFlag", (double)(data.byHaveDataFlag));
	cJSON_AddItemToObject(root, "PetDataLst", GetJsonDT_PET_DATA_LIST(data.stPetDataLst));
	cJSON_AddNumberToObject(root,"NormalLastTime", (double)(data.qwNormalLastTime));
	cJSON_AddNumberToObject(root,"GoodLastTime", (double)(data.qwGoodLastTime));
	cJSON_AddNumberToObject(root,"NormalProductNum", (double)(data.wNormalProductNum));
	cJSON_AddNumberToObject(root,"GoodProductNum", (double)(data.wGoodProductNum));
	cJSON_AddNumberToObject(root,"ProductLastTime", (double)(data.qwProductLastTime));
	cJSON_AddNumberToObject(root,"PetScore", (double)(data.dwPetScore));
	cJSON_AddNumberToObject(root,"LastFeedTime", (double)(data.qwLastFeedTime));
	cJSON_AddNumberToObject(root,"LeftFreeFeedCnt", (double)(data.dwLeftFreeFeedCnt));
	cJSON_AddNumberToObject(root,"VIPFeedCnt", (double)(data.dwVIPFeedCnt));
	cJSON_AddItemToObject(root, "PetCallData", GetJsonDT_PET_CALL_LST_DATA(data.stPetCallData));
	cJSON_AddNumberToObject(root,"FreeNormalProductCnt", (double)(data.wFreeNormalProductCnt));
	cJSON_AddNumberToObject(root,"CallFlag", (double)(data.byCallFlag));
	cJSON_AddItemToObject(root, "PetNeiDan", GetJsonDT_PLAYER_NEIDAN_DATA_LST(data.stPetNeiDan));
	cJSON_AddItemToObject(root, "PetNeiDanBag", GetJsonDT_NEIDAN_DATA_LST(data.stPetNeiDanBag));
	cJSON_AddItemToObject(root, "HeroLstInfo", GetJsonDT_HERO_HP_DATA_LST(data.stHeroLstInfo));

	return root;
}

INT32 DT_PLAYER_PET_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 17;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byHaveDataFlag);
	memcpy(pDataBuff + dwOffset, &byHaveDataFlag, sizeof(byHaveDataFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stPetDataLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwNormalLastTime);
	memcpy(pDataBuff + dwOffset, &qwNormalLastTime, sizeof(qwNormalLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(qwGoodLastTime);
	memcpy(pDataBuff + dwOffset, &qwGoodLastTime, sizeof(qwGoodLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wNormalProductNum);
	memcpy(pDataBuff + dwOffset, &wNormalProductNum, sizeof(wNormalProductNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(wGoodProductNum);
	memcpy(pDataBuff + dwOffset, &wGoodProductNum, sizeof(wGoodProductNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwProductLastTime);
	memcpy(pDataBuff + dwOffset, &qwProductLastTime, sizeof(qwProductLastTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(dwPetScore);
	memcpy(pDataBuff + dwOffset, &dwPetScore, sizeof(dwPetScore));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(qwLastFeedTime);
	memcpy(pDataBuff + dwOffset, &qwLastFeedTime, sizeof(qwLastFeedTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(dwLeftFreeFeedCnt);
	memcpy(pDataBuff + dwOffset, &dwLeftFreeFeedCnt, sizeof(dwLeftFreeFeedCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(dwVIPFeedCnt);
	memcpy(pDataBuff + dwOffset, &dwVIPFeedCnt, sizeof(dwVIPFeedCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = stPetCallData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(wFreeNormalProductCnt);
	memcpy(pDataBuff + dwOffset, &wFreeNormalProductCnt, sizeof(wFreeNormalProductCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(byCallFlag);
	memcpy(pDataBuff + dwOffset, &byCallFlag, sizeof(byCallFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = stPetNeiDan.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = stPetNeiDanBag.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = stHeroLstInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_PET_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byHaveDataFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byHaveDataFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byHaveDataFlag, 0, sizeof(byHaveDataFlag));
				}
			}
			break;
		case 2:
			{
				stPetDataLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(qwNormalLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwNormalLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwNormalLastTime, 0, sizeof(qwNormalLastTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(qwGoodLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwGoodLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwGoodLastTime, 0, sizeof(qwGoodLastTime));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wNormalProductNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wNormalProductNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wNormalProductNum, 0, sizeof(wNormalProductNum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(wGoodProductNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wGoodProductNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wGoodProductNum, 0, sizeof(wGoodProductNum));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwProductLastTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwProductLastTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwProductLastTime, 0, sizeof(qwProductLastTime));
				}
			}
			break;
		case 8:
			{
				if(sizeof(dwPetScore) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPetScore, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPetScore, 0, sizeof(dwPetScore));
				}
			}
			break;
		case 9:
			{
				if(sizeof(qwLastFeedTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastFeedTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastFeedTime, 0, sizeof(qwLastFeedTime));
				}
			}
			break;
		case 10:
			{
				if(sizeof(dwLeftFreeFeedCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&dwLeftFreeFeedCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwLeftFreeFeedCnt, 0, sizeof(dwLeftFreeFeedCnt));
				}
			}
			break;
		case 11:
			{
				if(sizeof(dwVIPFeedCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&dwVIPFeedCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwVIPFeedCnt, 0, sizeof(dwVIPFeedCnt));
				}
			}
			break;
		case 12:
			{
				stPetCallData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 13:
			{
				if(sizeof(wFreeNormalProductCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wFreeNormalProductCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFreeNormalProductCnt, 0, sizeof(wFreeNormalProductCnt));
				}
			}
			break;
		case 14:
			{
				if(sizeof(byCallFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byCallFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCallFlag, 0, sizeof(byCallFlag));
				}
			}
			break;
		case 15:
			{
				stPetNeiDan.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 16:
			{
				stPetNeiDanBag.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 17:
			{
				stHeroLstInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_NOPVP_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_NOPVP_DATA *pstIn = (DT_PLAYER_NOPVP_DATA*)pHost;

	if(-1 == EncodeDT_PLAYER_BASE_DATA(&pstIn->stBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_HERO_DATA_LIST(&pstIn->stHeroData, poNetData))
		return -1;

	if(-1 == EncodeDT_BAG_EQUIP_DATA_LST(&pstIn->stBagEquipData, poNetData))
		return -1;

	if(-1 == EncodeDT_BAG_GOODS_DATA_LST(&pstIn->stBagGoodsData, poNetData))
		return -1;

	if(-1 == EncodeDT_BUILD_DATA_LIST(&pstIn->stBuildData, poNetData))
		return -1;

	if(-1 == EncodeDT_TASK_DATA_LIST(&pstIn->stTaskData, poNetData))
		return -1;

	if(-1 == EncodeDT_LOCALE_DATA(&pstIn->stLocaleData, poNetData))
		return -1;

	if(-1 == EncodeDT_STATE_DATA(&pstIn->stCurState, poNetData))
		return -1;

	if(-1 == EncodeDT_ONLINE_ENCOURAGE_RECORD_DATA(&pstIn->stOnlineEncRecdData, poNetData))
		return -1;

	if(-1 == EncodeDT_LOGIN_ENCOURAGE_RECORD_DATA(&pstIn->stLoginEncRecdData, poNetData))
		return -1;

	if(-1 == EncodeDT_INSTANCE_DB_DATA(&pstIn->stInstanceData, poNetData))
		return -1;

	if(-1 == EncodeDT_MONEY_TREE_DATA(&pstIn->stMoneyTreeData, poNetData))
		return -1;

	if(-1 == EncodeDT_ONHOOK_RCD_DATA(&pstIn->stOnhookRcdData, poNetData))
		return -1;

	if(-1 == EncodeDT_JINGJIE_DATA(&pstIn->stJingJieData, poNetData))
		return -1;

	if(-1 == EncodeDT_PHYSTRENGTH_DATA(&pstIn->stPhystrengthData, poNetData))
		return -1;

	if(-1 == EncodeDT_FEW_PARAM_DATA(&pstIn->stFewParamData, poNetData))
		return -1;

	if(-1 == EncodeDT_CROP_DATA(&pstIn->stCropData, poNetData))
		return -1;

	if(-1 == EncodeDT_SCIENCE_TREE_DATA(&pstIn->stScienceTree, poNetData))
		return -1;

	if(-1 == EncodeDT_NEW_FORMATION_DATA(&pstIn->stFormationInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddString(pstIn->szLastOrderID, sizeof(pstIn->szLastOrderID)))
		return -1;

	if(-1 == EncodeDT_EAT_BREAD_DATA(&pstIn->stEatBreadInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_YABIAO_DATA(&pstIn->stYabiaoInfo, poNetData))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_TOKEN_NUM; i++)
	{
		if(-1 == poNetData->AddByte(pstIn->abyNoticeID[i]))
			return -1;
	}

	if(-1 == poNetData->AddUint64(pstIn->qwLoginTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLogoffTime))
		return -1;

	if(-1 == EncodeDT_CLIMB_TOWER_DATA(&pstIn->stClimbTowerData, poNetData))
		return -1;

	if(-1 == EncodeDT_AWAKEN_DATA(&pstIn->stAwakenData, poNetData))
		return -1;

	if(-1 == EncodeDT_VIP_EXT_DATA(&pstIn->stVipExtData, poNetData))
		return -1;

	if(-1 == EncodeDT_LUAACTIVITY_RECORD_LIST_DATA(&pstIn->stLuaActivityRecordData, poNetData))
		return -1;

	if(-1 == EncodeDT_COLLECT_GAS_DATA(&pstIn->stGasCollectData, poNetData))
		return -1;

	if(-1 == EncodeDT_BOSS_BATTLE_PLAYER_DATA_INFO(&pstIn->stBossBattlePlayerDataInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_ACTIVITY_ENCOURAGE_DATA(&pstIn->stActivityEncourageData, poNetData))
		return -1;

	if(-1 == EncodeDT_RANDOM_CHALLENGE_DATA(&pstIn->stRdChallengeData, poNetData))
		return -1;

	if(-1 == EncodeDT_WORSHIP_DATA_LST(&pstIn->stWorshipData, poNetData))
		return -1;

	if(-1 == EncodeDT_SCORE_DATA_LST(&pstIn->stScoreData, poNetData))
		return -1;

	if(-1 == EncodeDT_EQUIP_COMPOSE_DATA(&pstIn->stEquipComposeData, poNetData))
		return -1;

	if(-1 == EncodeDT_GATHER_SCIENCE_DATA(&pstIn->stGatherScienceData, poNetData))
		return -1;

	if(-1 == EncodeDT_BEGBLUE_DATA(&pstIn->stBegBlueData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_TODAY_CONSUME_DATA(&pstIn->stTodayConsume, poNetData))
		return -1;

	if(-1 == EncodeDT_FRIENDS_DATA(&pstIn->stFriendsData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_FACTION_DATA(&pstIn->stPlayerFactionData, poNetData))
		return -1;

	if(-1 == EncodeDT_COURAGE_DATA(&pstIn->stCourageData, poNetData))
		return -1;

	if(-1 == EncodeDT_EQUIP_MASTER(&pstIn->stEquipMasterData, poNetData))
		return -1;

	if(-1 == EncodeDT_EXCHANGE_RESULT_LOG(&pstIn->stExchangeResultLog, poNetData))
		return -1;

	if(-1 == EncodeDT_BAG_JEWELRY_DATA_LST(&pstIn->stBagJewelryInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_GVG_DATA(&pstIn->stGvGData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_SOUL_DATA(&pstIn->stSoulData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_MEDAL_DATA(&pstIn->stMedalData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_PET_DATA(&pstIn->stPetData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_NOPVP_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_NOPVP_DATA *pstOut = (DT_PLAYER_NOPVP_DATA*)pHost;

	if(-1 == DecodeDT_PLAYER_BASE_DATA(&pstOut->stBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_HERO_DATA_LIST(&pstOut->stHeroData, poNetData))
		return -1;

	if(-1 == DecodeDT_BAG_EQUIP_DATA_LST(&pstOut->stBagEquipData, poNetData))
		return -1;

	if(-1 == DecodeDT_BAG_GOODS_DATA_LST(&pstOut->stBagGoodsData, poNetData))
		return -1;

	if(-1 == DecodeDT_BUILD_DATA_LIST(&pstOut->stBuildData, poNetData))
		return -1;

	if(-1 == DecodeDT_TASK_DATA_LIST(&pstOut->stTaskData, poNetData))
		return -1;

	if(-1 == DecodeDT_LOCALE_DATA(&pstOut->stLocaleData, poNetData))
		return -1;

	if(-1 == DecodeDT_STATE_DATA(&pstOut->stCurState, poNetData))
		return -1;

	if(-1 == DecodeDT_ONLINE_ENCOURAGE_RECORD_DATA(&pstOut->stOnlineEncRecdData, poNetData))
		return -1;

	if(-1 == DecodeDT_LOGIN_ENCOURAGE_RECORD_DATA(&pstOut->stLoginEncRecdData, poNetData))
		return -1;

	if(-1 == DecodeDT_INSTANCE_DB_DATA(&pstOut->stInstanceData, poNetData))
		return -1;

	if(-1 == DecodeDT_MONEY_TREE_DATA(&pstOut->stMoneyTreeData, poNetData))
		return -1;

	if(-1 == DecodeDT_ONHOOK_RCD_DATA(&pstOut->stOnhookRcdData, poNetData))
		return -1;

	if(-1 == DecodeDT_JINGJIE_DATA(&pstOut->stJingJieData, poNetData))
		return -1;

	if(-1 == DecodeDT_PHYSTRENGTH_DATA(&pstOut->stPhystrengthData, poNetData))
		return -1;

	if(-1 == DecodeDT_FEW_PARAM_DATA(&pstOut->stFewParamData, poNetData))
		return -1;

	if(-1 == DecodeDT_CROP_DATA(&pstOut->stCropData, poNetData))
		return -1;

	if(-1 == DecodeDT_SCIENCE_TREE_DATA(&pstOut->stScienceTree, poNetData))
		return -1;

	if(-1 == DecodeDT_NEW_FORMATION_DATA(&pstOut->stFormationInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelString(pstOut->szLastOrderID, sizeof(pstOut->szLastOrderID)))
		return -1;

	if(-1 == DecodeDT_EAT_BREAD_DATA(&pstOut->stEatBreadInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_YABIAO_DATA(&pstOut->stYabiaoInfo, poNetData))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_TOKEN_NUM; i++)
	{
		if(-1 == poNetData->DelByte(pstOut->abyNoticeID[i]))
			return -1;
	}

	if(-1 == poNetData->DelUint64(pstOut->qwLoginTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLogoffTime))
		return -1;

	if(-1 == DecodeDT_CLIMB_TOWER_DATA(&pstOut->stClimbTowerData, poNetData))
		return -1;

	if(-1 == DecodeDT_AWAKEN_DATA(&pstOut->stAwakenData, poNetData))
		return -1;

	if(-1 == DecodeDT_VIP_EXT_DATA(&pstOut->stVipExtData, poNetData))
		return -1;

	if(-1 == DecodeDT_LUAACTIVITY_RECORD_LIST_DATA(&pstOut->stLuaActivityRecordData, poNetData))
		return -1;

	if(-1 == DecodeDT_COLLECT_GAS_DATA(&pstOut->stGasCollectData, poNetData))
		return -1;

	if(-1 == DecodeDT_BOSS_BATTLE_PLAYER_DATA_INFO(&pstOut->stBossBattlePlayerDataInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_ACTIVITY_ENCOURAGE_DATA(&pstOut->stActivityEncourageData, poNetData))
		return -1;

	if(-1 == DecodeDT_RANDOM_CHALLENGE_DATA(&pstOut->stRdChallengeData, poNetData))
		return -1;

	if(-1 == DecodeDT_WORSHIP_DATA_LST(&pstOut->stWorshipData, poNetData))
		return -1;

	if(-1 == DecodeDT_SCORE_DATA_LST(&pstOut->stScoreData, poNetData))
		return -1;

	if(-1 == DecodeDT_EQUIP_COMPOSE_DATA(&pstOut->stEquipComposeData, poNetData))
		return -1;

	if(-1 == DecodeDT_GATHER_SCIENCE_DATA(&pstOut->stGatherScienceData, poNetData))
		return -1;

	if(-1 == DecodeDT_BEGBLUE_DATA(&pstOut->stBegBlueData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_TODAY_CONSUME_DATA(&pstOut->stTodayConsume, poNetData))
		return -1;

	if(-1 == DecodeDT_FRIENDS_DATA(&pstOut->stFriendsData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_FACTION_DATA(&pstOut->stPlayerFactionData, poNetData))
		return -1;

	if(-1 == DecodeDT_COURAGE_DATA(&pstOut->stCourageData, poNetData))
		return -1;

	if(-1 == DecodeDT_EQUIP_MASTER(&pstOut->stEquipMasterData, poNetData))
		return -1;

	if(-1 == DecodeDT_EXCHANGE_RESULT_LOG(&pstOut->stExchangeResultLog, poNetData))
		return -1;

	if(-1 == DecodeDT_BAG_JEWELRY_DATA_LST(&pstOut->stBagJewelryInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_GVG_DATA(&pstOut->stGvGData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_SOUL_DATA(&pstOut->stSoulData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_MEDAL_DATA(&pstOut->stMedalData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_PET_DATA(&pstOut->stPetData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_NOPVP_DATA(DT_PLAYER_NOPVP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "BaseData", GetJsonDT_PLAYER_BASE_DATA(data.stBaseData));
	cJSON_AddItemToObject(root, "HeroData", GetJsonDT_HERO_DATA_LIST(data.stHeroData));
	cJSON_AddItemToObject(root, "BagEquipData", GetJsonDT_BAG_EQUIP_DATA_LST(data.stBagEquipData));
	cJSON_AddItemToObject(root, "BagGoodsData", GetJsonDT_BAG_GOODS_DATA_LST(data.stBagGoodsData));
	cJSON_AddItemToObject(root, "BuildData", GetJsonDT_BUILD_DATA_LIST(data.stBuildData));
	cJSON_AddItemToObject(root, "TaskData", GetJsonDT_TASK_DATA_LIST(data.stTaskData));
	cJSON_AddItemToObject(root, "LocaleData", GetJsonDT_LOCALE_DATA(data.stLocaleData));
	cJSON_AddItemToObject(root, "CurState", GetJsonDT_STATE_DATA(data.stCurState));
	cJSON_AddItemToObject(root, "OnlineEncRecdData", GetJsonDT_ONLINE_ENCOURAGE_RECORD_DATA(data.stOnlineEncRecdData));
	cJSON_AddItemToObject(root, "LoginEncRecdData", GetJsonDT_LOGIN_ENCOURAGE_RECORD_DATA(data.stLoginEncRecdData));
	cJSON_AddItemToObject(root, "InstanceData", GetJsonDT_INSTANCE_DB_DATA(data.stInstanceData));
	cJSON_AddItemToObject(root, "MoneyTreeData", GetJsonDT_MONEY_TREE_DATA(data.stMoneyTreeData));
	cJSON_AddItemToObject(root, "OnhookRcdData", GetJsonDT_ONHOOK_RCD_DATA(data.stOnhookRcdData));
	cJSON_AddItemToObject(root, "JingJieData", GetJsonDT_JINGJIE_DATA(data.stJingJieData));
	cJSON_AddItemToObject(root, "PhystrengthData", GetJsonDT_PHYSTRENGTH_DATA(data.stPhystrengthData));
	cJSON_AddItemToObject(root, "FewParamData", GetJsonDT_FEW_PARAM_DATA(data.stFewParamData));
	cJSON_AddItemToObject(root, "CropData", GetJsonDT_CROP_DATA(data.stCropData));
	cJSON_AddItemToObject(root, "ScienceTree", GetJsonDT_SCIENCE_TREE_DATA(data.stScienceTree));
	cJSON_AddItemToObject(root, "FormationInfo", GetJsonDT_NEW_FORMATION_DATA(data.stFormationInfo));
	cJSON_AddStringToObject(root,"LastOrderID", data.szLastOrderID );
	cJSON_AddItemToObject(root, "EatBreadInfo", GetJsonDT_EAT_BREAD_DATA(data.stEatBreadInfo));
	cJSON_AddItemToObject(root, "YabiaoInfo", GetJsonDT_YABIAO_DATA(data.stYabiaoInfo));
	cJSON *NoticeID = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "NoticeID", NoticeID);
	for( UINT32 dwIndex=0; dwIndex<MAX_TOKEN_NUM; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"NoticeID", (double)(data.abyNoticeID[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"LoginTime", (double)(data.qwLoginTime));
	cJSON_AddNumberToObject(root,"LogoffTime", (double)(data.qwLogoffTime));
	cJSON_AddItemToObject(root, "ClimbTowerData", GetJsonDT_CLIMB_TOWER_DATA(data.stClimbTowerData));
	cJSON_AddItemToObject(root, "AwakenData", GetJsonDT_AWAKEN_DATA(data.stAwakenData));
	cJSON_AddItemToObject(root, "VipExtData", GetJsonDT_VIP_EXT_DATA(data.stVipExtData));
	cJSON_AddItemToObject(root, "LuaActivityRecordData", GetJsonDT_LUAACTIVITY_RECORD_LIST_DATA(data.stLuaActivityRecordData));
	cJSON_AddItemToObject(root, "GasCollectData", GetJsonDT_COLLECT_GAS_DATA(data.stGasCollectData));
	cJSON_AddItemToObject(root, "BossBattlePlayerDataInfo", GetJsonDT_BOSS_BATTLE_PLAYER_DATA_INFO(data.stBossBattlePlayerDataInfo));
	cJSON_AddItemToObject(root, "ActivityEncourageData", GetJsonDT_ACTIVITY_ENCOURAGE_DATA(data.stActivityEncourageData));
	cJSON_AddItemToObject(root, "RdChallengeData", GetJsonDT_RANDOM_CHALLENGE_DATA(data.stRdChallengeData));
	cJSON_AddItemToObject(root, "WorshipData", GetJsonDT_WORSHIP_DATA_LST(data.stWorshipData));
	cJSON_AddItemToObject(root, "ScoreData", GetJsonDT_SCORE_DATA_LST(data.stScoreData));
	cJSON_AddItemToObject(root, "EquipComposeData", GetJsonDT_EQUIP_COMPOSE_DATA(data.stEquipComposeData));
	cJSON_AddItemToObject(root, "GatherScienceData", GetJsonDT_GATHER_SCIENCE_DATA(data.stGatherScienceData));
	cJSON_AddItemToObject(root, "BegBlueData", GetJsonDT_BEGBLUE_DATA(data.stBegBlueData));
	cJSON_AddItemToObject(root, "TodayConsume", GetJsonDT_PLAYER_TODAY_CONSUME_DATA(data.stTodayConsume));
	cJSON_AddItemToObject(root, "FriendsData", GetJsonDT_FRIENDS_DATA(data.stFriendsData));
	cJSON_AddItemToObject(root, "PlayerFactionData", GetJsonDT_PLAYER_FACTION_DATA(data.stPlayerFactionData));
	cJSON_AddItemToObject(root, "CourageData", GetJsonDT_COURAGE_DATA(data.stCourageData));
	cJSON_AddItemToObject(root, "EquipMasterData", GetJsonDT_EQUIP_MASTER(data.stEquipMasterData));
	cJSON_AddItemToObject(root, "ExchangeResultLog", GetJsonDT_EXCHANGE_RESULT_LOG(data.stExchangeResultLog));
	cJSON_AddItemToObject(root, "BagJewelryInfo", GetJsonDT_BAG_JEWELRY_DATA_LST(data.stBagJewelryInfo));
	cJSON_AddItemToObject(root, "GvGData", GetJsonDT_PLAYER_GVG_DATA(data.stGvGData));
	cJSON_AddItemToObject(root, "SoulData", GetJsonDT_PLAYER_SOUL_DATA(data.stSoulData));
	cJSON_AddItemToObject(root, "MedalData", GetJsonDT_PLAYER_MEDAL_DATA(data.stMedalData));
	cJSON_AddItemToObject(root, "PetData", GetJsonDT_PLAYER_PET_DATA(data.stPetData));

	return root;
}

INT32 DT_PLAYER_NOPVP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 49;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stHeroData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stBagEquipData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stBagGoodsData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stBuildData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stTaskData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stLocaleData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = stCurState.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = stOnlineEncRecdData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = stLoginEncRecdData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = stInstanceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 19;
	pstIndex->dwContextLen = stMoneyTreeData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 20;
	pstIndex->dwContextLen = stOnhookRcdData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 23;
	pstIndex->dwContextLen = stJingJieData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 24;
	pstIndex->dwContextLen = stPhystrengthData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 25;
	pstIndex->dwContextLen = stFewParamData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 26;
	pstIndex->dwContextLen = stCropData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 27;
	pstIndex->dwContextLen = stScienceTree.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 28;
	pstIndex->dwContextLen = stFormationInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 29;
	pstIndex->dwContextLen = sizeof(szLastOrderID) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_ORDER_ID_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &szLastOrderID, sizeof(szLastOrderID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 30;
	pstIndex->dwContextLen = stEatBreadInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 31;
	pstIndex->dwContextLen = stYabiaoInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 36;
	pstIndex->dwContextLen = sizeof(abyNoticeID) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_TOKEN_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &abyNoticeID, sizeof(abyNoticeID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 37;
	pstIndex->dwContextLen = sizeof(qwLoginTime);
	memcpy(pDataBuff + dwOffset, &qwLoginTime, sizeof(qwLoginTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 38;
	pstIndex->dwContextLen = sizeof(qwLogoffTime);
	memcpy(pDataBuff + dwOffset, &qwLogoffTime, sizeof(qwLogoffTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 39;
	pstIndex->dwContextLen = stClimbTowerData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 40;
	pstIndex->dwContextLen = stAwakenData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 41;
	pstIndex->dwContextLen = stVipExtData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 42;
	pstIndex->dwContextLen = stLuaActivityRecordData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 43;
	pstIndex->dwContextLen = stGasCollectData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 44;
	pstIndex->dwContextLen = stBossBattlePlayerDataInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 45;
	pstIndex->dwContextLen = stActivityEncourageData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 47;
	pstIndex->dwContextLen = stRdChallengeData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 48;
	pstIndex->dwContextLen = stWorshipData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 49;
	pstIndex->dwContextLen = stScoreData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 50;
	pstIndex->dwContextLen = stEquipComposeData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 51;
	pstIndex->dwContextLen = stGatherScienceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 52;
	pstIndex->dwContextLen = stBegBlueData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 53;
	pstIndex->dwContextLen = stTodayConsume.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 54;
	pstIndex->dwContextLen = stFriendsData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 55;
	pstIndex->dwContextLen = stPlayerFactionData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 56;
	pstIndex->dwContextLen = stCourageData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 57;
	pstIndex->dwContextLen = stEquipMasterData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 58;
	pstIndex->dwContextLen = stExchangeResultLog.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 59;
	pstIndex->dwContextLen = stBagJewelryInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 60;
	pstIndex->dwContextLen = stGvGData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 61;
	pstIndex->dwContextLen = stSoulData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 62;
	pstIndex->dwContextLen = stMedalData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 63;
	pstIndex->dwContextLen = stPetData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_NOPVP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stHeroData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stBagEquipData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stBagGoodsData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stBuildData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stTaskData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stLocaleData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 10:
			{
				stCurState.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 11:
			{
				stOnlineEncRecdData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 12:
			{
				stLoginEncRecdData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 13:
			{
				stInstanceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 19:
			{
				stMoneyTreeData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 20:
			{
				stOnhookRcdData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 23:
			{
				stJingJieData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 24:
			{
				stPhystrengthData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 25:
			{
				stFewParamData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 26:
			{
				stCropData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 27:
			{
				stScienceTree.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 28:
			{
				stFormationInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 29:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(szLastOrderID) >= dwContextLen) && (wArrNum <= MAX_ORDER_ID_LEN))
				{
					memcpy(&szLastOrderID, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&szLastOrderID, 0, sizeof(szLastOrderID));
				}
			}
			break;
		case 30:
			{
				stEatBreadInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 31:
			{
				stYabiaoInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 36:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(abyNoticeID) >= dwContextLen) && (wArrNum <= MAX_TOKEN_NUM))
				{
					memcpy(&abyNoticeID, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&abyNoticeID, 0, sizeof(abyNoticeID));
				}
			}
			break;
		case 37:
			{
				if(sizeof(qwLoginTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLoginTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLoginTime, 0, sizeof(qwLoginTime));
				}
			}
			break;
		case 38:
			{
				if(sizeof(qwLogoffTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLogoffTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLogoffTime, 0, sizeof(qwLogoffTime));
				}
			}
			break;
		case 39:
			{
				stClimbTowerData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 40:
			{
				stAwakenData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 41:
			{
				stVipExtData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 42:
			{
				stLuaActivityRecordData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 43:
			{
				stGasCollectData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 44:
			{
				stBossBattlePlayerDataInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 45:
			{
				stActivityEncourageData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 47:
			{
				stRdChallengeData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 48:
			{
				stWorshipData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 49:
			{
				stScoreData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 50:
			{
				stEquipComposeData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 51:
			{
				stGatherScienceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 52:
			{
				stBegBlueData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 53:
			{
				stTodayConsume.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 54:
			{
				stFriendsData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 55:
			{
				stPlayerFactionData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 56:
			{
				stCourageData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 57:
			{
				stEquipMasterData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 58:
			{
				stExchangeResultLog.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 59:
			{
				stBagJewelryInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 60:
			{
				stGvGData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 61:
			{
				stSoulData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 62:
			{
				stMedalData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 63:
			{
				stPetData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_PVP_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_PVP_DATA *pstIn = (DT_PLAYER_PVP_DATA*)pHost;

	if(-1 == EncodeDT_RACE_DATA(&pstIn->stRaceData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLUNDER_DATA(&pstIn->stPlunderData, poNetData))
		return -1;

	if(-1 == EncodeDT_ENEMY_DATA_LIST(&pstIn->stEnemyData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_PVP_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_PVP_DATA *pstOut = (DT_PLAYER_PVP_DATA*)pHost;

	if(-1 == DecodeDT_RACE_DATA(&pstOut->stRaceData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLUNDER_DATA(&pstOut->stPlunderData, poNetData))
		return -1;

	if(-1 == DecodeDT_ENEMY_DATA_LIST(&pstOut->stEnemyData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_PVP_DATA(DT_PLAYER_PVP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "RaceData", GetJsonDT_RACE_DATA(data.stRaceData));
	cJSON_AddItemToObject(root, "PlunderData", GetJsonDT_PLUNDER_DATA(data.stPlunderData));
	cJSON_AddItemToObject(root, "EnemyData", GetJsonDT_ENEMY_DATA_LIST(data.stEnemyData));

	return root;
}

INT32 DT_PLAYER_PVP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stRaceData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stPlunderData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stEnemyData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_PVP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stRaceData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stPlunderData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stEnemyData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_DATA *pstIn = (DT_PLAYER_DATA*)pHost;

	if(-1 == EncodeDT_PLAYER_NOPVP_DATA(&pstIn->stPlayerNoPvpData, poNetData))
		return -1;

	if(-1 == EncodeDT_PLAYER_PVP_DATA(&pstIn->stPlayerPvpData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_PLAYER_DATA *pstOut = (DT_PLAYER_DATA*)pHost;

	if(-1 == DecodeDT_PLAYER_NOPVP_DATA(&pstOut->stPlayerNoPvpData, poNetData))
		return -1;

	if(-1 == DecodeDT_PLAYER_PVP_DATA(&pstOut->stPlayerPvpData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_PLAYER_DATA(DT_PLAYER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "PlayerNoPvpData", GetJsonDT_PLAYER_NOPVP_DATA(data.stPlayerNoPvpData));
	cJSON_AddItemToObject(root, "PlayerPvpData", GetJsonDT_PLAYER_PVP_DATA(data.stPlayerPvpData));

	return root;
}

INT32 DT_PLAYER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stPlayerNoPvpData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stPlayerPvpData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_PLAYER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stPlayerNoPvpData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stPlayerPvpData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EXT_FUNC_PARAM(void *pHost, CNetData* poNetData)
{
	DT_EXT_FUNC_PARAM *pstIn = (DT_EXT_FUNC_PARAM*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byParam1))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wParam2))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwParam3))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EXT_FUNC_PARAM(void *pHost, CNetData* poNetData)
{
	DT_EXT_FUNC_PARAM *pstOut = (DT_EXT_FUNC_PARAM*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byParam1))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wParam2))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwParam3))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EXT_FUNC_PARAM(DT_EXT_FUNC_PARAM &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Param1", (double)(data.byParam1));
	cJSON_AddNumberToObject(root,"Param2", (double)(data.wParam2));
	cJSON_AddNumberToObject(root,"Param3", (double)(data.dwParam3));

	return root;
}

INT32 DT_EXT_FUNC_PARAM::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byParam1);
	memcpy(pDataBuff + dwOffset, &byParam1, sizeof(byParam1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wParam2);
	memcpy(pDataBuff + dwOffset, &wParam2, sizeof(wParam2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwParam3);
	memcpy(pDataBuff + dwOffset, &dwParam3, sizeof(dwParam3));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EXT_FUNC_PARAM::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byParam1) >= pstIndex->dwContextLen)
				{
					memcpy(&byParam1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byParam1, 0, sizeof(byParam1));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wParam2) >= pstIndex->dwContextLen)
				{
					memcpy(&wParam2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wParam2, 0, sizeof(wParam2));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwParam3) >= pstIndex->dwContextLen)
				{
					memcpy(&dwParam3, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwParam3, 0, sizeof(dwParam3));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_EXT_FUNC_PARAM_LST(void *pHost, CNetData* poNetData)
{
	DT_EXT_FUNC_PARAM_LST *pstIn = (DT_EXT_FUNC_PARAM_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFuncNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_EXT_FUN_NUM; i++)
	{
		if(i >= (INT32)pstIn->byFuncNum)
			break;
		if(-1 == EncodeDT_EXT_FUNC_PARAM(&pstIn->astExtFuncParaInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_EXT_FUNC_PARAM_LST(void *pHost, CNetData* poNetData)
{
	DT_EXT_FUNC_PARAM_LST *pstOut = (DT_EXT_FUNC_PARAM_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFuncNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_EXT_FUN_NUM; i++)
	{
		if(i >= (INT32)pstOut->byFuncNum)
			break;
		if(-1 == DecodeDT_EXT_FUNC_PARAM(&pstOut->astExtFuncParaInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_EXT_FUNC_PARAM_LST(DT_EXT_FUNC_PARAM_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FuncNum", (double)(data.byFuncNum));
	cJSON *ExtFuncParaInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ExtFuncParaInfo", ExtFuncParaInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byFuncNum; ++dwIndex)
	{
		cJSON_AddItemToObject(ExtFuncParaInfo, " ", GetJsonDT_EXT_FUNC_PARAM(data.astExtFuncParaInfo[dwIndex]));
	}

	return root;
}

INT32 DT_EXT_FUNC_PARAM_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFuncNum);
	memcpy(pDataBuff + dwOffset, &byFuncNum, sizeof(byFuncNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byFuncNum > MAX_EXT_FUN_NUM)
	{
		byFuncNum = MAX_EXT_FUN_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFuncNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFuncNum; i++)
	{
		dwContextLenTmp += astExtFuncParaInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_EXT_FUNC_PARAM_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFuncNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byFuncNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFuncNum, 0, sizeof(byFuncNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFuncNum)
				{
					wArrNum = wArrNum <= MAX_EXT_FUN_NUM ? wArrNum : MAX_EXT_FUN_NUM;
					byFuncNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astExtFuncParaInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astExtFuncParaInfo, 0, sizeof(astExtFuncParaInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astExtFuncParaInfo, 0, sizeof(astExtFuncParaInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CONTINUE_KILL_DATA(void *pHost, CNetData* poNetData)
{
	DT_CONTINUE_KILL_DATA *pstIn = (DT_CONTINUE_KILL_DATA*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_BATTLE_NUM; i++)
	{
		if(i >= (INT32)pstIn->byNum)
			break;
		if(-1 == poNetData->AddUint64(pstIn->aqwKeyLst[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CONTINUE_KILL_DATA(void *pHost, CNetData* poNetData)
{
	DT_CONTINUE_KILL_DATA *pstOut = (DT_CONTINUE_KILL_DATA*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_BATTLE_NUM; i++)
	{
		if(i >= (INT32)pstOut->byNum)
			break;
		if(-1 == poNetData->DelUint64(pstOut->aqwKeyLst[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CONTINUE_KILL_DATA(DT_CONTINUE_KILL_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Num", (double)(data.byNum));
	cJSON *KeyLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "KeyLst", KeyLst);
	for( UINT32 dwIndex=0; dwIndex<data.byNum; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"KeyLst", (double)(data.aqwKeyLst[dwIndex]));
	}

	return root;
}

INT32 DT_CONTINUE_KILL_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byNum);
	memcpy(pDataBuff + dwOffset, &byNum, sizeof(byNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(byNum > MAX_FACTION_BATTLE_NUM)
	{
		byNum = MAX_FACTION_BATTLE_NUM;
	}
	pstIndex->dwContextLen = byNum * sizeof(UINT64) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = byNum;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aqwKeyLst, byNum * sizeof(UINT64));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CONTINUE_KILL_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNum, 0, sizeof(byNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aqwKeyLst) >= dwContextLen) && (wArrNum == byNum) && (wArrNum <= MAX_FACTION_BATTLE_NUM))
				{
					memcpy(&aqwKeyLst, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aqwKeyLst, 0, sizeof(aqwKeyLst));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_PLAYER_DATA *pstIn = (DT_FACTION_PLAYER_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwJoinPlayerID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byJoinState))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byJobType))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwDoorsTribute))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwDoorsTributeSum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDrinkFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNewGoodFlag))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byNewSkillFlag))
		return -1;

	if(-1 == EncodeDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(&pstIn->stUnLoginBattleLogList, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwJoinTime))
		return -1;

	if(-1 == EncodeDT_CONTINUE_KILL_DATA(&pstIn->stContinueKillKey, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_PLAYER_DATA *pstOut = (DT_FACTION_PLAYER_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwJoinPlayerID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byJoinState))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byJobType))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwDoorsTribute))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwDoorsTributeSum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDrinkFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNewGoodFlag))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byNewSkillFlag))
		return -1;

	if(-1 == DecodeDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(&pstOut->stUnLoginBattleLogList, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwJoinTime))
		return -1;

	if(-1 == DecodeDT_CONTINUE_KILL_DATA(&pstOut->stContinueKillKey, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_PLAYER_DATA(DT_FACTION_PLAYER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"JoinPlayerID", (double)(data.dwJoinPlayerID));
	cJSON_AddNumberToObject(root,"JoinState", (double)(data.byJoinState));
	cJSON_AddNumberToObject(root,"JobType", (double)(data.byJobType));
	cJSON_AddNumberToObject(root,"DoorsTribute", (double)(data.dwDoorsTribute));
	cJSON_AddNumberToObject(root,"DoorsTributeSum", (double)(data.qwDoorsTributeSum));
	cJSON_AddNumberToObject(root,"DrinkFlag", (double)(data.byDrinkFlag));
	cJSON_AddNumberToObject(root,"NewGoodFlag", (double)(data.byNewGoodFlag));
	cJSON_AddNumberToObject(root,"NewSkillFlag", (double)(data.byNewSkillFlag));
	cJSON_AddItemToObject(root, "UnLoginBattleLogList", GetJsonDT_PLAYER_FACTION_BATTLELOG_DATA_LIST(data.stUnLoginBattleLogList));
	cJSON_AddNumberToObject(root,"JoinTime", (double)(data.qwJoinTime));
	cJSON_AddItemToObject(root, "ContinueKillKey", GetJsonDT_CONTINUE_KILL_DATA(data.stContinueKillKey));

	return root;
}

INT32 DT_FACTION_PLAYER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 11;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwJoinPlayerID);
	memcpy(pDataBuff + dwOffset, &dwJoinPlayerID, sizeof(dwJoinPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byJoinState);
	memcpy(pDataBuff + dwOffset, &byJoinState, sizeof(byJoinState));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byJobType);
	memcpy(pDataBuff + dwOffset, &byJobType, sizeof(byJobType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwDoorsTribute);
	memcpy(pDataBuff + dwOffset, &dwDoorsTribute, sizeof(dwDoorsTribute));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(qwDoorsTributeSum);
	memcpy(pDataBuff + dwOffset, &qwDoorsTributeSum, sizeof(qwDoorsTributeSum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byDrinkFlag);
	memcpy(pDataBuff + dwOffset, &byDrinkFlag, sizeof(byDrinkFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(byNewGoodFlag);
	memcpy(pDataBuff + dwOffset, &byNewGoodFlag, sizeof(byNewGoodFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byNewSkillFlag);
	memcpy(pDataBuff + dwOffset, &byNewSkillFlag, sizeof(byNewSkillFlag));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stUnLoginBattleLogList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(qwJoinTime);
	memcpy(pDataBuff + dwOffset, &qwJoinTime, sizeof(qwJoinTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = stContinueKillKey.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_PLAYER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwJoinPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwJoinPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwJoinPlayerID, 0, sizeof(dwJoinPlayerID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byJoinState) >= pstIndex->dwContextLen)
				{
					memcpy(&byJoinState, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byJoinState, 0, sizeof(byJoinState));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byJobType) >= pstIndex->dwContextLen)
				{
					memcpy(&byJobType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byJobType, 0, sizeof(byJobType));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwDoorsTribute) >= pstIndex->dwContextLen)
				{
					memcpy(&dwDoorsTribute, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwDoorsTribute, 0, sizeof(dwDoorsTribute));
				}
			}
			break;
		case 5:
			{
				if(sizeof(qwDoorsTributeSum) >= pstIndex->dwContextLen)
				{
					memcpy(&qwDoorsTributeSum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwDoorsTributeSum, 0, sizeof(qwDoorsTributeSum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byDrinkFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byDrinkFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDrinkFlag, 0, sizeof(byDrinkFlag));
				}
			}
			break;
		case 7:
			{
				if(sizeof(byNewGoodFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byNewGoodFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNewGoodFlag, 0, sizeof(byNewGoodFlag));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byNewSkillFlag) >= pstIndex->dwContextLen)
				{
					memcpy(&byNewSkillFlag, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byNewSkillFlag, 0, sizeof(byNewSkillFlag));
				}
			}
			break;
		case 9:
			{
				stUnLoginBattleLogList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 10:
			{
				if(sizeof(qwJoinTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwJoinTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwJoinTime, 0, sizeof(qwJoinTime));
				}
			}
			break;
		case 11:
			{
				stContinueKillKey.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_PLAYER_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_PLAYER_DATA_LST *pstIn = (DT_FACTION_PLAYER_DATA_LST*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionNum))
		return -1;

	INT32 i;
	for(i = 0; i < DT_FACTION_PLAYER_NUM; i++)
	{
		if(i >= (INT32)pstIn->dwFactionNum)
			break;
		if(-1 == EncodeDT_FACTION_PLAYER_DATA(&pstIn->astFactionPlayerData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_PLAYER_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_PLAYER_DATA_LST *pstOut = (DT_FACTION_PLAYER_DATA_LST*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionNum))
		return -1;

	INT32 i;
	for(i = 0; i < DT_FACTION_PLAYER_NUM; i++)
	{
		if(i >= (INT32)pstOut->dwFactionNum)
			break;
		if(-1 == DecodeDT_FACTION_PLAYER_DATA(&pstOut->astFactionPlayerData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_PLAYER_DATA_LST(DT_FACTION_PLAYER_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionNum", (double)(data.dwFactionNum));
	cJSON *FactionPlayerData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionPlayerData", FactionPlayerData);
	for( UINT32 dwIndex=0; dwIndex<data.dwFactionNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionPlayerData, " ", GetJsonDT_FACTION_PLAYER_DATA(data.astFactionPlayerData[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_PLAYER_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionNum);
	memcpy(pDataBuff + dwOffset, &dwFactionNum, sizeof(dwFactionNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(dwFactionNum > DT_FACTION_PLAYER_NUM)
	{
		dwFactionNum = DT_FACTION_PLAYER_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = dwFactionNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < dwFactionNum; i++)
	{
		dwContextLenTmp += astFactionPlayerData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_PLAYER_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionNum) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionNum, 0, sizeof(dwFactionNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == dwFactionNum)
				{
					wArrNum = wArrNum <= DT_FACTION_PLAYER_NUM ? wArrNum : DT_FACTION_PLAYER_NUM;
					dwFactionNum = (UINT32)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionPlayerData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionPlayerData, 0, sizeof(astFactionPlayerData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionPlayerData, 0, sizeof(astFactionPlayerData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_LOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LOG_DATA *pstIn = (DT_FACTION_LOG_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID1))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPlayerJobType1))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID2))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPlayerJobType2))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAction))
		return -1;

	INT32 i;
	for(i = 0; i < FACTION_LOG_LIST_MAX_NUM; i++)
	{
		if(-1 == poNetData->AddDword(pstIn->adwParamList[i]))
			return -1;
	}

	if(-1 == poNetData->AddUint64(pstIn->qwLogTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_LOG_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LOG_DATA *pstOut = (DT_FACTION_LOG_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID1))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPlayerJobType1))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID2))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPlayerJobType2))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAction))
		return -1;

	INT32 i;
	for(i = 0; i < FACTION_LOG_LIST_MAX_NUM; i++)
	{
		if(-1 == poNetData->DelDword(pstOut->adwParamList[i]))
			return -1;
	}

	if(-1 == poNetData->DelUint64(pstOut->qwLogTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_LOG_DATA(DT_FACTION_LOG_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"PlayerID1", (double)(data.dwPlayerID1));
	cJSON_AddNumberToObject(root,"PlayerJobType1", (double)(data.byPlayerJobType1));
	cJSON_AddNumberToObject(root,"PlayerID2", (double)(data.dwPlayerID2));
	cJSON_AddNumberToObject(root,"PlayerJobType2", (double)(data.byPlayerJobType2));
	cJSON_AddNumberToObject(root,"Action", (double)(data.byAction));
	cJSON *ParamList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "ParamList", ParamList);
	for( UINT32 dwIndex=0; dwIndex<FACTION_LOG_LIST_MAX_NUM; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"ParamList", (double)(data.adwParamList[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"LogTime", (double)(data.qwLogTime));

	return root;
}

INT32 DT_FACTION_LOG_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwPlayerID1);
	memcpy(pDataBuff + dwOffset, &dwPlayerID1, sizeof(dwPlayerID1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byPlayerJobType1);
	memcpy(pDataBuff + dwOffset, &byPlayerJobType1, sizeof(byPlayerJobType1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwPlayerID2);
	memcpy(pDataBuff + dwOffset, &dwPlayerID2, sizeof(dwPlayerID2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byPlayerJobType2);
	memcpy(pDataBuff + dwOffset, &byPlayerJobType2, sizeof(byPlayerJobType2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byAction);
	memcpy(pDataBuff + dwOffset, &byAction, sizeof(byAction));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(adwParamList) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = FACTION_LOG_LIST_MAX_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &adwParamList, sizeof(adwParamList));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwLogTime);
	memcpy(pDataBuff + dwOffset, &qwLogTime, sizeof(qwLogTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_LOG_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwPlayerID1) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID1, 0, sizeof(dwPlayerID1));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byPlayerJobType1) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerJobType1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerJobType1, 0, sizeof(byPlayerJobType1));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwPlayerID2) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID2, 0, sizeof(dwPlayerID2));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byPlayerJobType2) >= pstIndex->dwContextLen)
				{
					memcpy(&byPlayerJobType2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPlayerJobType2, 0, sizeof(byPlayerJobType2));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byAction) >= pstIndex->dwContextLen)
				{
					memcpy(&byAction, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAction, 0, sizeof(byAction));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(adwParamList) >= dwContextLen) && (wArrNum <= FACTION_LOG_LIST_MAX_NUM))
				{
					memcpy(&adwParamList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&adwParamList, 0, sizeof(adwParamList));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwLogTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLogTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLogTime, 0, sizeof(qwLogTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_LOG_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LOG_DATA_LST *pstIn = (DT_FACTION_LOG_DATA_LST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wFactionLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_LOG_NUM; i++)
	{
		if(i >= (INT32)pstIn->wFactionLogNum)
			break;
		if(-1 == EncodeDT_FACTION_LOG_DATA(&pstIn->astFactionLogData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_LOG_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_LOG_DATA_LST *pstOut = (DT_FACTION_LOG_DATA_LST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wFactionLogNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_LOG_NUM; i++)
	{
		if(i >= (INT32)pstOut->wFactionLogNum)
			break;
		if(-1 == DecodeDT_FACTION_LOG_DATA(&pstOut->astFactionLogData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_LOG_DATA_LST(DT_FACTION_LOG_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionLogNum", (double)(data.wFactionLogNum));
	cJSON *FactionLogData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionLogData", FactionLogData);
	for( UINT32 dwIndex=0; dwIndex<data.wFactionLogNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionLogData, " ", GetJsonDT_FACTION_LOG_DATA(data.astFactionLogData[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_LOG_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wFactionLogNum);
	memcpy(pDataBuff + dwOffset, &wFactionLogNum, sizeof(wFactionLogNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wFactionLogNum > MAX_FACTION_LOG_NUM)
	{
		wFactionLogNum = MAX_FACTION_LOG_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wFactionLogNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wFactionLogNum; i++)
	{
		dwContextLenTmp += astFactionLogData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_LOG_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wFactionLogNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wFactionLogNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFactionLogNum, 0, sizeof(wFactionLogNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wFactionLogNum)
				{
					wArrNum = wArrNum <= MAX_FACTION_LOG_NUM ? wArrNum : MAX_FACTION_LOG_NUM;
					wFactionLogNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionLogData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionLogData, 0, sizeof(astFactionLogData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionLogData, 0, sizeof(astFactionLogData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BASE_DATA *pstIn = (DT_FACTION_BASE_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionPlayerID))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionName, sizeof(pstIn->aszFactionName)))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionRank))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionLevel))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionNotice, sizeof(pstIn->aszFactionNotice)))
		return -1;

	if(-1 == poNetData->AddTString(pstIn->aszFactionAnnouncement, sizeof(pstIn->aszFactionAnnouncement)))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwFactionCreateTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwRareItemRoomGrade))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwGymnasiumLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwShadeLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionFunds))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwHotSpringLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwColdPrisonLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionTowerLevel))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwFactionFundsSum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_BASE_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BASE_DATA *pstOut = (DT_FACTION_BASE_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionPlayerID))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionName, sizeof(pstOut->aszFactionName)))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionRank))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionLevel))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionNotice, sizeof(pstOut->aszFactionNotice)))
		return -1;

	if(-1 == poNetData->DelTString(pstOut->aszFactionAnnouncement, sizeof(pstOut->aszFactionAnnouncement)))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwFactionCreateTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwRareItemRoomGrade))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwGymnasiumLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwShadeLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionFunds))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwHotSpringLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwColdPrisonLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionTowerLevel))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwFactionFundsSum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_BASE_DATA(DT_FACTION_BASE_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));
	cJSON_AddNumberToObject(root,"FactionPlayerID", (double)(data.dwFactionPlayerID));
	cJSON_AddStringToObject(root,"FactionName", data.aszFactionName );
	cJSON_AddNumberToObject(root,"FactionRank", (double)(data.dwFactionRank));
	cJSON_AddNumberToObject(root,"FactionLevel", (double)(data.dwFactionLevel));
	cJSON_AddStringToObject(root,"FactionNotice", data.aszFactionNotice );
	cJSON_AddStringToObject(root,"FactionAnnouncement", data.aszFactionAnnouncement );
	cJSON_AddNumberToObject(root,"FactionCreateTime", (double)(data.qwFactionCreateTime));
	cJSON_AddNumberToObject(root,"RareItemRoomGrade", (double)(data.dwRareItemRoomGrade));
	cJSON_AddNumberToObject(root,"GymnasiumLevel", (double)(data.dwGymnasiumLevel));
	cJSON_AddNumberToObject(root,"ShadeLevel", (double)(data.dwShadeLevel));
	cJSON_AddNumberToObject(root,"FactionFunds", (double)(data.dwFactionFunds));
	cJSON_AddNumberToObject(root,"HotSpringLevel", (double)(data.dwHotSpringLevel));
	cJSON_AddNumberToObject(root,"ColdPrisonLevel", (double)(data.dwColdPrisonLevel));
	cJSON_AddNumberToObject(root,"FactionTowerLevel", (double)(data.dwFactionTowerLevel));
	cJSON_AddNumberToObject(root,"FactionFundsSum", (double)(data.qwFactionFundsSum));

	return root;
}

INT32 DT_FACTION_BASE_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 16;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwFactionPlayerID);
	memcpy(pDataBuff + dwOffset, &dwFactionPlayerID, sizeof(dwFactionPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(aszFactionName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionName, sizeof(aszFactionName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwFactionRank);
	memcpy(pDataBuff + dwOffset, &dwFactionRank, sizeof(dwFactionRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(dwFactionLevel);
	memcpy(pDataBuff + dwOffset, &dwFactionLevel, sizeof(dwFactionLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(aszFactionNotice) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_DESC_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionNotice, sizeof(aszFactionNotice));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(aszFactionAnnouncement) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_FACTION_DESC_NUM;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszFactionAnnouncement, sizeof(aszFactionAnnouncement));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(qwFactionCreateTime);
	memcpy(pDataBuff + dwOffset, &qwFactionCreateTime, sizeof(qwFactionCreateTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(dwRareItemRoomGrade);
	memcpy(pDataBuff + dwOffset, &dwRareItemRoomGrade, sizeof(dwRareItemRoomGrade));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 14;
	pstIndex->dwContextLen = sizeof(dwGymnasiumLevel);
	memcpy(pDataBuff + dwOffset, &dwGymnasiumLevel, sizeof(dwGymnasiumLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 15;
	pstIndex->dwContextLen = sizeof(dwShadeLevel);
	memcpy(pDataBuff + dwOffset, &dwShadeLevel, sizeof(dwShadeLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 16;
	pstIndex->dwContextLen = sizeof(dwFactionFunds);
	memcpy(pDataBuff + dwOffset, &dwFactionFunds, sizeof(dwFactionFunds));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 17;
	pstIndex->dwContextLen = sizeof(dwHotSpringLevel);
	memcpy(pDataBuff + dwOffset, &dwHotSpringLevel, sizeof(dwHotSpringLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 18;
	pstIndex->dwContextLen = sizeof(dwColdPrisonLevel);
	memcpy(pDataBuff + dwOffset, &dwColdPrisonLevel, sizeof(dwColdPrisonLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 19;
	pstIndex->dwContextLen = sizeof(dwFactionTowerLevel);
	memcpy(pDataBuff + dwOffset, &dwFactionTowerLevel, sizeof(dwFactionTowerLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 20;
	pstIndex->dwContextLen = sizeof(qwFactionFundsSum);
	memcpy(pDataBuff + dwOffset, &qwFactionFundsSum, sizeof(qwFactionFundsSum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_BASE_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwFactionPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionPlayerID, 0, sizeof(dwFactionPlayerID));
				}
			}
			break;
		case 3:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionName) >= dwContextLen) && (wArrNum <= MAX_FACTION_NUM))
				{
					memcpy(&aszFactionName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionName, 0, sizeof(aszFactionName));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwFactionRank) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionRank, 0, sizeof(dwFactionRank));
				}
			}
			break;
		case 5:
			{
				if(sizeof(dwFactionLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionLevel, 0, sizeof(dwFactionLevel));
				}
			}
			break;
		case 10:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionNotice) >= dwContextLen) && (wArrNum <= MAX_FACTION_DESC_NUM))
				{
					memcpy(&aszFactionNotice, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionNotice, 0, sizeof(aszFactionNotice));
				}
			}
			break;
		case 11:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszFactionAnnouncement) >= dwContextLen) && (wArrNum <= MAX_FACTION_DESC_NUM))
				{
					memcpy(&aszFactionAnnouncement, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszFactionAnnouncement, 0, sizeof(aszFactionAnnouncement));
				}
			}
			break;
		case 12:
			{
				if(sizeof(qwFactionCreateTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwFactionCreateTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwFactionCreateTime, 0, sizeof(qwFactionCreateTime));
				}
			}
			break;
		case 13:
			{
				if(sizeof(dwRareItemRoomGrade) >= pstIndex->dwContextLen)
				{
					memcpy(&dwRareItemRoomGrade, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwRareItemRoomGrade, 0, sizeof(dwRareItemRoomGrade));
				}
			}
			break;
		case 14:
			{
				if(sizeof(dwGymnasiumLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGymnasiumLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGymnasiumLevel, 0, sizeof(dwGymnasiumLevel));
				}
			}
			break;
		case 15:
			{
				if(sizeof(dwShadeLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&dwShadeLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwShadeLevel, 0, sizeof(dwShadeLevel));
				}
			}
			break;
		case 16:
			{
				if(sizeof(dwFactionFunds) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionFunds, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionFunds, 0, sizeof(dwFactionFunds));
				}
			}
			break;
		case 17:
			{
				if(sizeof(dwHotSpringLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&dwHotSpringLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwHotSpringLevel, 0, sizeof(dwHotSpringLevel));
				}
			}
			break;
		case 18:
			{
				if(sizeof(dwColdPrisonLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&dwColdPrisonLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwColdPrisonLevel, 0, sizeof(dwColdPrisonLevel));
				}
			}
			break;
		case 19:
			{
				if(sizeof(dwFactionTowerLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionTowerLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionTowerLevel, 0, sizeof(dwFactionTowerLevel));
				}
			}
			break;
		case 20:
			{
				if(sizeof(qwFactionFundsSum) >= pstIndex->dwContextLen)
				{
					memcpy(&qwFactionFundsSum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwFactionFundsSum, 0, sizeof(qwFactionFundsSum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_DATA *pstIn = (DT_FACTION_DATA*)pHost;

	if(-1 == EncodeDT_FACTION_BASE_DATA(&pstIn->stFactionBaseData, poNetData))
		return -1;

	if(-1 == EncodeDT_FACTION_PLAYER_DATA_LST(&pstIn->stFactionPlayerDataLst, poNetData))
		return -1;

	if(-1 == EncodeDT_FACTION_LOG_DATA_LST(&pstIn->stFactionLogDataLst, poNetData))
		return -1;

	if(-1 == EncodeDT_FACTION_COMMON_DATA(&pstIn->stFactionCommonData, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byFactionException))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byTodayPassNum))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwLastAuditTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byExt))
		return -1;

	if(-1 == EncodeDT_FACTION_GVG_DATA(&pstIn->stGvGData, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_DATA *pstOut = (DT_FACTION_DATA*)pHost;

	if(-1 == DecodeDT_FACTION_BASE_DATA(&pstOut->stFactionBaseData, poNetData))
		return -1;

	if(-1 == DecodeDT_FACTION_PLAYER_DATA_LST(&pstOut->stFactionPlayerDataLst, poNetData))
		return -1;

	if(-1 == DecodeDT_FACTION_LOG_DATA_LST(&pstOut->stFactionLogDataLst, poNetData))
		return -1;

	if(-1 == DecodeDT_FACTION_COMMON_DATA(&pstOut->stFactionCommonData, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byFactionException))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byTodayPassNum))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwLastAuditTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byExt))
		return -1;

	if(-1 == DecodeDT_FACTION_GVG_DATA(&pstOut->stGvGData, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_DATA(DT_FACTION_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "FactionBaseData", GetJsonDT_FACTION_BASE_DATA(data.stFactionBaseData));
	cJSON_AddItemToObject(root, "FactionPlayerDataLst", GetJsonDT_FACTION_PLAYER_DATA_LST(data.stFactionPlayerDataLst));
	cJSON_AddItemToObject(root, "FactionLogDataLst", GetJsonDT_FACTION_LOG_DATA_LST(data.stFactionLogDataLst));
	cJSON_AddItemToObject(root, "FactionCommonData", GetJsonDT_FACTION_COMMON_DATA(data.stFactionCommonData));
	cJSON_AddNumberToObject(root,"FactionException", (double)(data.byFactionException));
	cJSON_AddNumberToObject(root,"TodayPassNum", (double)(data.byTodayPassNum));
	cJSON_AddNumberToObject(root,"LastAuditTime", (double)(data.qwLastAuditTime));
	cJSON_AddNumberToObject(root,"Ext", (double)(data.byExt));
	cJSON_AddItemToObject(root, "GvGData", GetJsonDT_FACTION_GVG_DATA(data.stGvGData));

	return root;
}

INT32 DT_FACTION_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stFactionBaseData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stFactionPlayerDataLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stFactionLogDataLst.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stFactionCommonData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byFactionException);
	memcpy(pDataBuff + dwOffset, &byFactionException, sizeof(byFactionException));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byTodayPassNum);
	memcpy(pDataBuff + dwOffset, &byTodayPassNum, sizeof(byTodayPassNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(qwLastAuditTime);
	memcpy(pDataBuff + dwOffset, &qwLastAuditTime, sizeof(qwLastAuditTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byExt);
	memcpy(pDataBuff + dwOffset, &byExt, sizeof(byExt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stGvGData.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stFactionBaseData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stFactionPlayerDataLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stFactionLogDataLst.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stFactionCommonData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				if(sizeof(byFactionException) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionException, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionException, 0, sizeof(byFactionException));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byTodayPassNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byTodayPassNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byTodayPassNum, 0, sizeof(byTodayPassNum));
				}
			}
			break;
		case 7:
			{
				if(sizeof(qwLastAuditTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwLastAuditTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwLastAuditTime, 0, sizeof(qwLastAuditTime));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byExt) >= pstIndex->dwContextLen)
				{
					memcpy(&byExt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byExt, 0, sizeof(byExt));
				}
			}
			break;
		case 9:
			{
				stGvGData.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_AUTHORITY(void *pHost, CNetData* poNetData)
{
	DT_FACTION_AUTHORITY *pstIn = (DT_FACTION_AUTHORITY*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byKickedNormal))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKickedElite))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPromotion))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDemotion))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBuild))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivity))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySignUp))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAudit))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byEditSetting))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byShowLog))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byChangeOther))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBecomeHead))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_AUTHORITY(void *pHost, CNetData* poNetData)
{
	DT_FACTION_AUTHORITY *pstOut = (DT_FACTION_AUTHORITY*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byKickedNormal))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKickedElite))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPromotion))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDemotion))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBuild))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivity))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySignUp))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAudit))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byEditSetting))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byShowLog))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byChangeOther))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBecomeHead))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_AUTHORITY(DT_FACTION_AUTHORITY &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KickedNormal", (double)(data.byKickedNormal));
	cJSON_AddNumberToObject(root,"KickedElite", (double)(data.byKickedElite));
	cJSON_AddNumberToObject(root,"Promotion", (double)(data.byPromotion));
	cJSON_AddNumberToObject(root,"Demotion", (double)(data.byDemotion));
	cJSON_AddNumberToObject(root,"Build", (double)(data.byBuild));
	cJSON_AddNumberToObject(root,"Activity", (double)(data.byActivity));
	cJSON_AddNumberToObject(root,"SignUp", (double)(data.bySignUp));
	cJSON_AddNumberToObject(root,"Audit", (double)(data.byAudit));
	cJSON_AddNumberToObject(root,"EditSetting", (double)(data.byEditSetting));
	cJSON_AddNumberToObject(root,"ShowLog", (double)(data.byShowLog));
	cJSON_AddNumberToObject(root,"ChangeOther", (double)(data.byChangeOther));
	cJSON_AddNumberToObject(root,"BecomeHead", (double)(data.byBecomeHead));

	return root;
}

INT32 DT_FACTION_AUTHORITY::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 12;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byKickedNormal);
	memcpy(pDataBuff + dwOffset, &byKickedNormal, sizeof(byKickedNormal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byKickedElite);
	memcpy(pDataBuff + dwOffset, &byKickedElite, sizeof(byKickedElite));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byPromotion);
	memcpy(pDataBuff + dwOffset, &byPromotion, sizeof(byPromotion));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byDemotion);
	memcpy(pDataBuff + dwOffset, &byDemotion, sizeof(byDemotion));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBuild);
	memcpy(pDataBuff + dwOffset, &byBuild, sizeof(byBuild));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byActivity);
	memcpy(pDataBuff + dwOffset, &byActivity, sizeof(byActivity));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(bySignUp);
	memcpy(pDataBuff + dwOffset, &bySignUp, sizeof(bySignUp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byAudit);
	memcpy(pDataBuff + dwOffset, &byAudit, sizeof(byAudit));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byEditSetting);
	memcpy(pDataBuff + dwOffset, &byEditSetting, sizeof(byEditSetting));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byShowLog);
	memcpy(pDataBuff + dwOffset, &byShowLog, sizeof(byShowLog));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byChangeOther);
	memcpy(pDataBuff + dwOffset, &byChangeOther, sizeof(byChangeOther));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(byBecomeHead);
	memcpy(pDataBuff + dwOffset, &byBecomeHead, sizeof(byBecomeHead));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_AUTHORITY::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byKickedNormal) >= pstIndex->dwContextLen)
				{
					memcpy(&byKickedNormal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKickedNormal, 0, sizeof(byKickedNormal));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byKickedElite) >= pstIndex->dwContextLen)
				{
					memcpy(&byKickedElite, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKickedElite, 0, sizeof(byKickedElite));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byPromotion) >= pstIndex->dwContextLen)
				{
					memcpy(&byPromotion, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPromotion, 0, sizeof(byPromotion));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byDemotion) >= pstIndex->dwContextLen)
				{
					memcpy(&byDemotion, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDemotion, 0, sizeof(byDemotion));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBuild) >= pstIndex->dwContextLen)
				{
					memcpy(&byBuild, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBuild, 0, sizeof(byBuild));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byActivity) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivity, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivity, 0, sizeof(byActivity));
				}
			}
			break;
		case 7:
			{
				if(sizeof(bySignUp) >= pstIndex->dwContextLen)
				{
					memcpy(&bySignUp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySignUp, 0, sizeof(bySignUp));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byAudit) >= pstIndex->dwContextLen)
				{
					memcpy(&byAudit, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAudit, 0, sizeof(byAudit));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byEditSetting) >= pstIndex->dwContextLen)
				{
					memcpy(&byEditSetting, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEditSetting, 0, sizeof(byEditSetting));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byShowLog) >= pstIndex->dwContextLen)
				{
					memcpy(&byShowLog, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byShowLog, 0, sizeof(byShowLog));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byChangeOther) >= pstIndex->dwContextLen)
				{
					memcpy(&byChangeOther, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChangeOther, 0, sizeof(byChangeOther));
				}
			}
			break;
		case 12:
			{
				if(sizeof(byBecomeHead) >= pstIndex->dwContextLen)
				{
					memcpy(&byBecomeHead, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBecomeHead, 0, sizeof(byBecomeHead));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_AUTHORITY_EX(void *pHost, CNetData* poNetData)
{
	DT_FACTION_AUTHORITY_EX *pstIn = (DT_FACTION_AUTHORITY_EX*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byKickedNormal))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byKickedElite))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPromotion))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byDemotion))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBuild))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivity))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->bySignUp))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byAudit))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byEditSetting))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byShowLog))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byChangeOther))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBecomeHead))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byChangeIcon))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_AUTHORITY_EX(void *pHost, CNetData* poNetData)
{
	DT_FACTION_AUTHORITY_EX *pstOut = (DT_FACTION_AUTHORITY_EX*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byKickedNormal))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byKickedElite))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPromotion))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byDemotion))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBuild))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivity))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->bySignUp))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byAudit))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byEditSetting))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byShowLog))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byChangeOther))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBecomeHead))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byChangeIcon))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_AUTHORITY_EX(DT_FACTION_AUTHORITY_EX &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"KickedNormal", (double)(data.byKickedNormal));
	cJSON_AddNumberToObject(root,"KickedElite", (double)(data.byKickedElite));
	cJSON_AddNumberToObject(root,"Promotion", (double)(data.byPromotion));
	cJSON_AddNumberToObject(root,"Demotion", (double)(data.byDemotion));
	cJSON_AddNumberToObject(root,"Build", (double)(data.byBuild));
	cJSON_AddNumberToObject(root,"Activity", (double)(data.byActivity));
	cJSON_AddNumberToObject(root,"SignUp", (double)(data.bySignUp));
	cJSON_AddNumberToObject(root,"Audit", (double)(data.byAudit));
	cJSON_AddNumberToObject(root,"EditSetting", (double)(data.byEditSetting));
	cJSON_AddNumberToObject(root,"ShowLog", (double)(data.byShowLog));
	cJSON_AddNumberToObject(root,"ChangeOther", (double)(data.byChangeOther));
	cJSON_AddNumberToObject(root,"BecomeHead", (double)(data.byBecomeHead));
	cJSON_AddNumberToObject(root,"ChangeIcon", (double)(data.byChangeIcon));

	return root;
}

INT32 DT_FACTION_AUTHORITY_EX::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 13;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byKickedNormal);
	memcpy(pDataBuff + dwOffset, &byKickedNormal, sizeof(byKickedNormal));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byKickedElite);
	memcpy(pDataBuff + dwOffset, &byKickedElite, sizeof(byKickedElite));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byPromotion);
	memcpy(pDataBuff + dwOffset, &byPromotion, sizeof(byPromotion));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byDemotion);
	memcpy(pDataBuff + dwOffset, &byDemotion, sizeof(byDemotion));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBuild);
	memcpy(pDataBuff + dwOffset, &byBuild, sizeof(byBuild));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byActivity);
	memcpy(pDataBuff + dwOffset, &byActivity, sizeof(byActivity));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(bySignUp);
	memcpy(pDataBuff + dwOffset, &bySignUp, sizeof(bySignUp));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(byAudit);
	memcpy(pDataBuff + dwOffset, &byAudit, sizeof(byAudit));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(byEditSetting);
	memcpy(pDataBuff + dwOffset, &byEditSetting, sizeof(byEditSetting));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byShowLog);
	memcpy(pDataBuff + dwOffset, &byShowLog, sizeof(byShowLog));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(byChangeOther);
	memcpy(pDataBuff + dwOffset, &byChangeOther, sizeof(byChangeOther));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(byBecomeHead);
	memcpy(pDataBuff + dwOffset, &byBecomeHead, sizeof(byBecomeHead));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(byChangeIcon);
	memcpy(pDataBuff + dwOffset, &byChangeIcon, sizeof(byChangeIcon));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_AUTHORITY_EX::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byKickedNormal) >= pstIndex->dwContextLen)
				{
					memcpy(&byKickedNormal, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKickedNormal, 0, sizeof(byKickedNormal));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byKickedElite) >= pstIndex->dwContextLen)
				{
					memcpy(&byKickedElite, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byKickedElite, 0, sizeof(byKickedElite));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byPromotion) >= pstIndex->dwContextLen)
				{
					memcpy(&byPromotion, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPromotion, 0, sizeof(byPromotion));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byDemotion) >= pstIndex->dwContextLen)
				{
					memcpy(&byDemotion, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byDemotion, 0, sizeof(byDemotion));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBuild) >= pstIndex->dwContextLen)
				{
					memcpy(&byBuild, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBuild, 0, sizeof(byBuild));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byActivity) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivity, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivity, 0, sizeof(byActivity));
				}
			}
			break;
		case 7:
			{
				if(sizeof(bySignUp) >= pstIndex->dwContextLen)
				{
					memcpy(&bySignUp, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&bySignUp, 0, sizeof(bySignUp));
				}
			}
			break;
		case 8:
			{
				if(sizeof(byAudit) >= pstIndex->dwContextLen)
				{
					memcpy(&byAudit, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byAudit, 0, sizeof(byAudit));
				}
			}
			break;
		case 9:
			{
				if(sizeof(byEditSetting) >= pstIndex->dwContextLen)
				{
					memcpy(&byEditSetting, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byEditSetting, 0, sizeof(byEditSetting));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byShowLog) >= pstIndex->dwContextLen)
				{
					memcpy(&byShowLog, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byShowLog, 0, sizeof(byShowLog));
				}
			}
			break;
		case 11:
			{
				if(sizeof(byChangeOther) >= pstIndex->dwContextLen)
				{
					memcpy(&byChangeOther, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChangeOther, 0, sizeof(byChangeOther));
				}
			}
			break;
		case 12:
			{
				if(sizeof(byBecomeHead) >= pstIndex->dwContextLen)
				{
					memcpy(&byBecomeHead, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBecomeHead, 0, sizeof(byBecomeHead));
				}
			}
			break;
		case 13:
			{
				if(sizeof(byChangeIcon) >= pstIndex->dwContextLen)
				{
					memcpy(&byChangeIcon, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChangeIcon, 0, sizeof(byChangeIcon));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_PLAYER_DATA *pstIn = (DT_COURAGE_PLAYER_DATA*)pHost;

	if(-1 == poNetData->AddTString(pstIn->aszDispPlayerName, sizeof(pstIn->aszDispPlayerName)))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wLevel))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwPlayerID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byMemberType))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byBattleType))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byReadyType))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wKindID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wHeroLevel))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byColor))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_PLAYER_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_PLAYER_DATA *pstOut = (DT_COURAGE_PLAYER_DATA*)pHost;

	if(-1 == poNetData->DelTString(pstOut->aszDispPlayerName, sizeof(pstOut->aszDispPlayerName)))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wLevel))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwPlayerID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byMemberType))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byBattleType))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byReadyType))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wKindID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wHeroLevel))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byColor))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_PLAYER_DATA(DT_COURAGE_PLAYER_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddStringToObject(root,"DispPlayerName", data.aszDispPlayerName );
	cJSON_AddNumberToObject(root,"Level", (double)(data.wLevel));
	cJSON_AddNumberToObject(root,"PlayerID", (double)(data.dwPlayerID));
	cJSON_AddNumberToObject(root,"MemberType", (double)(data.byMemberType));
	cJSON_AddNumberToObject(root,"BattleType", (double)(data.byBattleType));
	cJSON_AddNumberToObject(root,"ReadyType", (double)(data.byReadyType));
	cJSON_AddNumberToObject(root,"HeroID", (double)(data.wHeroID));
	cJSON_AddNumberToObject(root,"KindID", (double)(data.wKindID));
	cJSON_AddNumberToObject(root,"HeroLevel", (double)(data.wHeroLevel));
	cJSON_AddNumberToObject(root,"Color", (double)(data.byColor));

	return root;
}

INT32 DT_COURAGE_PLAYER_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 10;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(aszDispPlayerName) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = USERNAME_LEN;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &aszDispPlayerName, sizeof(aszDispPlayerName));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(wLevel);
	memcpy(pDataBuff + dwOffset, &wLevel, sizeof(wLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwPlayerID);
	memcpy(pDataBuff + dwOffset, &dwPlayerID, sizeof(dwPlayerID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byMemberType);
	memcpy(pDataBuff + dwOffset, &byMemberType, sizeof(byMemberType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byBattleType);
	memcpy(pDataBuff + dwOffset, &byBattleType, sizeof(byBattleType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byReadyType);
	memcpy(pDataBuff + dwOffset, &byReadyType, sizeof(byReadyType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wHeroID);
	memcpy(pDataBuff + dwOffset, &wHeroID, sizeof(wHeroID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = sizeof(wKindID);
	memcpy(pDataBuff + dwOffset, &wKindID, sizeof(wKindID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wHeroLevel);
	memcpy(pDataBuff + dwOffset, &wHeroLevel, sizeof(wHeroLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byColor);
	memcpy(pDataBuff + dwOffset, &byColor, sizeof(byColor));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_PLAYER_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(aszDispPlayerName) >= dwContextLen) && (wArrNum <= USERNAME_LEN))
				{
					memcpy(&aszDispPlayerName, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&aszDispPlayerName, 0, sizeof(aszDispPlayerName));
				}
			}
			break;
		case 2:
			{
				if(sizeof(wLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wLevel, 0, sizeof(wLevel));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwPlayerID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwPlayerID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwPlayerID, 0, sizeof(dwPlayerID));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byMemberType) >= pstIndex->dwContextLen)
				{
					memcpy(&byMemberType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byMemberType, 0, sizeof(byMemberType));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byBattleType) >= pstIndex->dwContextLen)
				{
					memcpy(&byBattleType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byBattleType, 0, sizeof(byBattleType));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byReadyType) >= pstIndex->dwContextLen)
				{
					memcpy(&byReadyType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byReadyType, 0, sizeof(byReadyType));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wHeroID) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroID, 0, sizeof(wHeroID));
				}
			}
			break;
		case 8:
			{
				if(sizeof(wKindID) >= pstIndex->dwContextLen)
				{
					memcpy(&wKindID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wKindID, 0, sizeof(wKindID));
				}
			}
			break;
		case 9:
			{
				if(sizeof(wHeroLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wHeroLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wHeroLevel, 0, sizeof(wHeroLevel));
				}
			}
			break;
		case 10:
			{
				if(sizeof(byColor) >= pstIndex->dwContextLen)
				{
					memcpy(&byColor, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byColor, 0, sizeof(byColor));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_GROUP_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_GROUP_DATA *pstIn = (DT_COURAGE_GROUP_DATA*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwGroupID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byJoinType))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wMinLevel))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPlayerNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_COURAGE_GROUP_PLAYER_NUM; i++)
	{
		if(-1 == EncodeDT_COURAGE_PLAYER_DATA(&pstIn->astPlayerData[i], poNetData))
			return -1;
	}

	if(-1 == poNetData->AddDword(pstIn->dwLeaderID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wAverageLevel))
		return -1;

	if(-1 == EncodeDT_INSTANCE_ID(&pstIn->stInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wPlayerMaxNum))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_GROUP_DATA(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_GROUP_DATA *pstOut = (DT_COURAGE_GROUP_DATA*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwGroupID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byJoinType))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wMinLevel))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPlayerNum))
		return -1;

	INT32 i;
		for(i = 0; i < MAX_COURAGE_GROUP_PLAYER_NUM; i++)
		{
			if(-1 == DecodeDT_COURAGE_PLAYER_DATA(&pstOut->astPlayerData[i], poNetData))
				return -1;
		}

	if(-1 == poNetData->DelDword(pstOut->dwLeaderID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wAverageLevel))
		return -1;

	if(-1 == DecodeDT_INSTANCE_ID(&pstOut->stInstanceID, poNetData))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wPlayerMaxNum))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_GROUP_DATA(DT_COURAGE_GROUP_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"GroupID", (double)(data.dwGroupID));
	cJSON_AddNumberToObject(root,"JoinType", (double)(data.byJoinType));
	cJSON_AddNumberToObject(root,"MinLevel", (double)(data.wMinLevel));
	cJSON_AddNumberToObject(root,"PlayerNum", (double)(data.wPlayerNum));
	cJSON *PlayerData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "PlayerData", PlayerData);
	for( UINT32 dwIndex=0; dwIndex<MAX_COURAGE_GROUP_PLAYER_NUM; ++dwIndex)
	{
		cJSON_AddItemToObject(PlayerData, " ", GetJsonDT_COURAGE_PLAYER_DATA(data.astPlayerData[dwIndex]));
	}
	cJSON_AddNumberToObject(root,"LeaderID", (double)(data.dwLeaderID));
	cJSON_AddNumberToObject(root,"AverageLevel", (double)(data.wAverageLevel));
	cJSON_AddItemToObject(root, "InstanceID", GetJsonDT_INSTANCE_ID(data.stInstanceID));
	cJSON_AddNumberToObject(root,"PlayerMaxNum", (double)(data.wPlayerMaxNum));

	return root;
}

INT32 DT_COURAGE_GROUP_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 9;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwGroupID);
	memcpy(pDataBuff + dwOffset, &dwGroupID, sizeof(dwGroupID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byJoinType);
	memcpy(pDataBuff + dwOffset, &byJoinType, sizeof(byJoinType));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wMinLevel);
	memcpy(pDataBuff + dwOffset, &wMinLevel, sizeof(wMinLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(wPlayerNum);
	memcpy(pDataBuff + dwOffset, &wPlayerNum, sizeof(wPlayerNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	dwContextLenTmp = 0;
	*(UINT16*)(pDataBuff + dwOffset) = MAX_COURAGE_GROUP_PLAYER_NUM;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < MAX_COURAGE_GROUP_PLAYER_NUM; i++)
	{
		dwContextLenTmp += astPlayerData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(dwLeaderID);
	memcpy(pDataBuff + dwOffset, &dwLeaderID, sizeof(dwLeaderID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wAverageLevel);
	memcpy(pDataBuff + dwOffset, &wAverageLevel, sizeof(wAverageLevel));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stInstanceID.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = sizeof(wPlayerMaxNum);
	memcpy(pDataBuff + dwOffset, &wPlayerMaxNum, sizeof(wPlayerMaxNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_GROUP_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwGroupID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwGroupID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwGroupID, 0, sizeof(dwGroupID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byJoinType) >= pstIndex->dwContextLen)
				{
					memcpy(&byJoinType, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byJoinType, 0, sizeof(byJoinType));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wMinLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wMinLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wMinLevel, 0, sizeof(wMinLevel));
				}
			}
			break;
		case 4:
			{
				if(sizeof(wPlayerNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPlayerNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPlayerNum, 0, sizeof(wPlayerNum));
				}
			}
			break;
		case 5:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				wArrNum = wArrNum <= MAX_COURAGE_GROUP_PLAYER_NUM ? wArrNum : MAX_COURAGE_GROUP_PLAYER_NUM;
					for(UINT16 i = 0; i < wArrNum; i++)
				{
					dwPassContextLen += astPlayerData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
					if(dwPassContextLen >= pstIndex->dwContextLen)
					{
						memset(astPlayerData, 0, sizeof(astPlayerData));
						break;
					}
					dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
				}
			}
			break;
		case 6:
			{
				if(sizeof(dwLeaderID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwLeaderID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwLeaderID, 0, sizeof(dwLeaderID));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wAverageLevel) >= pstIndex->dwContextLen)
				{
					memcpy(&wAverageLevel, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wAverageLevel, 0, sizeof(wAverageLevel));
				}
			}
			break;
		case 8:
			{
				stInstanceID.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				if(sizeof(wPlayerMaxNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wPlayerMaxNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wPlayerMaxNum, 0, sizeof(wPlayerMaxNum));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_COURAGE_GROUP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_GROUP_DATA_LST *pstIn = (DT_COURAGE_GROUP_DATA_LST*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwOverTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStartTime))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSaveTime))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byActivityID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wGroupNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_COURAGE_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstIn->wGroupNum)
			break;
		if(-1 == EncodeDT_COURAGE_GROUP_DATA(&pstIn->astGroupData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_COURAGE_GROUP_DATA_LST(void *pHost, CNetData* poNetData)
{
	DT_COURAGE_GROUP_DATA_LST *pstOut = (DT_COURAGE_GROUP_DATA_LST*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwOverTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStartTime))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSaveTime))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byActivityID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wGroupNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_COURAGE_GROUP_NUM; i++)
	{
		if(i >= (INT32)pstOut->wGroupNum)
			break;
		if(-1 == DecodeDT_COURAGE_GROUP_DATA(&pstOut->astGroupData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_COURAGE_GROUP_DATA_LST(DT_COURAGE_GROUP_DATA_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"OverTime", (double)(data.qwOverTime));
	cJSON_AddNumberToObject(root,"StartTime", (double)(data.qwStartTime));
	cJSON_AddNumberToObject(root,"SaveTime", (double)(data.qwSaveTime));
	cJSON_AddNumberToObject(root,"ActivityID", (double)(data.byActivityID));
	cJSON_AddNumberToObject(root,"GroupNum", (double)(data.wGroupNum));
	cJSON *GroupData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "GroupData", GroupData);
	for( UINT32 dwIndex=0; dwIndex<data.wGroupNum; ++dwIndex)
	{
		cJSON_AddItemToObject(GroupData, " ", GetJsonDT_COURAGE_GROUP_DATA(data.astGroupData[dwIndex]));
	}

	return root;
}

INT32 DT_COURAGE_GROUP_DATA_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 6;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwOverTime);
	memcpy(pDataBuff + dwOffset, &qwOverTime, sizeof(qwOverTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(qwStartTime);
	memcpy(pDataBuff + dwOffset, &qwStartTime, sizeof(qwStartTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwSaveTime);
	memcpy(pDataBuff + dwOffset, &qwSaveTime, sizeof(qwSaveTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byActivityID);
	memcpy(pDataBuff + dwOffset, &byActivityID, sizeof(byActivityID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(wGroupNum);
	memcpy(pDataBuff + dwOffset, &wGroupNum, sizeof(wGroupNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	dwContextLenTmp = 0;
	if(wGroupNum > MAX_COURAGE_GROUP_NUM)
	{
		wGroupNum = MAX_COURAGE_GROUP_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wGroupNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wGroupNum; i++)
	{
		dwContextLenTmp += astGroupData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_COURAGE_GROUP_DATA_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwOverTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwOverTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwOverTime, 0, sizeof(qwOverTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(qwStartTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStartTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStartTime, 0, sizeof(qwStartTime));
				}
			}
			break;
		case 3:
			{
				if(sizeof(qwSaveTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSaveTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSaveTime, 0, sizeof(qwSaveTime));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byActivityID) >= pstIndex->dwContextLen)
				{
					memcpy(&byActivityID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byActivityID, 0, sizeof(byActivityID));
				}
			}
			break;
		case 5:
			{
				if(sizeof(wGroupNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wGroupNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wGroupNum, 0, sizeof(wGroupNum));
				}
			}
			break;
		case 6:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wGroupNum)
				{
					wArrNum = wArrNum <= MAX_COURAGE_GROUP_NUM ? wArrNum : MAX_COURAGE_GROUP_NUM;
					wGroupNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astGroupData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astGroupData, 0, sizeof(astGroupData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astGroupData, 0, sizeof(astGroupData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_APPLAY_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_APPLAY_DATA *pstIn = (DT_FACTION_APPLAY_DATA*)pHost;

	if(-1 == poNetData->AddUint64(pstIn->qwApplayTime))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byWinCnt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_APPLAY_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_APPLAY_DATA *pstOut = (DT_FACTION_APPLAY_DATA*)pHost;

	if(-1 == poNetData->DelUint64(pstOut->qwApplayTime))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byWinCnt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_APPLAY_DATA(DT_FACTION_APPLAY_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ApplayTime", (double)(data.qwApplayTime));
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));
	cJSON_AddNumberToObject(root,"WinCnt", (double)(data.byWinCnt));

	return root;
}

INT32 DT_FACTION_APPLAY_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(qwApplayTime);
	memcpy(pDataBuff + dwOffset, &qwApplayTime, sizeof(qwApplayTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(byWinCnt);
	memcpy(pDataBuff + dwOffset, &byWinCnt, sizeof(byWinCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_APPLAY_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(qwApplayTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwApplayTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwApplayTime, 0, sizeof(qwApplayTime));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(byWinCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byWinCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWinCnt, 0, sizeof(byWinCnt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_APPLAY_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_APPLAY_LST_DATA *pstIn = (DT_FACTION_APPLAY_LST_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wApplayNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_APPLAY_NUM; i++)
	{
		if(i >= (INT32)pstIn->wApplayNum)
			break;
		if(-1 == EncodeDT_FACTION_APPLAY_DATA(&pstIn->astFactionApplayLst[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_APPLAY_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_FACTION_APPLAY_LST_DATA *pstOut = (DT_FACTION_APPLAY_LST_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wApplayNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_APPLAY_NUM; i++)
	{
		if(i >= (INT32)pstOut->wApplayNum)
			break;
		if(-1 == DecodeDT_FACTION_APPLAY_DATA(&pstOut->astFactionApplayLst[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_APPLAY_LST_DATA(DT_FACTION_APPLAY_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ApplayNum", (double)(data.wApplayNum));
	cJSON *FactionApplayLst = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionApplayLst", FactionApplayLst);
	for( UINT32 dwIndex=0; dwIndex<data.wApplayNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionApplayLst, " ", GetJsonDT_FACTION_APPLAY_DATA(data.astFactionApplayLst[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_APPLAY_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wApplayNum);
	memcpy(pDataBuff + dwOffset, &wApplayNum, sizeof(wApplayNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wApplayNum > MAX_FACTION_APPLAY_NUM)
	{
		wApplayNum = MAX_FACTION_APPLAY_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wApplayNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wApplayNum; i++)
	{
		dwContextLenTmp += astFactionApplayLst[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_APPLAY_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wApplayNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wApplayNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wApplayNum, 0, sizeof(wApplayNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wApplayNum)
				{
					wArrNum = wArrNum <= MAX_FACTION_APPLAY_NUM ? wArrNum : MAX_FACTION_APPLAY_NUM;
					wApplayNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionApplayLst[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionApplayLst, 0, sizeof(astFactionApplayLst));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionApplayLst, 0, sizeof(astFactionApplayLst));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SIMPLE_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_SIMPLE_FACTION_INFO *pstIn = (DT_SIMPLE_FACTION_INFO*)pHost;

	if(-1 == EncodeDT_FACTION_BASE_DATA_CLI2(&pstIn->stFactionBaseInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwZoneID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wRank))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byPosID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SIMPLE_FACTION_INFO(void *pHost, CNetData* poNetData)
{
	DT_SIMPLE_FACTION_INFO *pstOut = (DT_SIMPLE_FACTION_INFO*)pHost;

	if(-1 == DecodeDT_FACTION_BASE_DATA_CLI2(&pstOut->stFactionBaseInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwZoneID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wRank))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byPosID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SIMPLE_FACTION_INFO(DT_SIMPLE_FACTION_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "FactionBaseInfo", GetJsonDT_FACTION_BASE_DATA_CLI2(data.stFactionBaseInfo));
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.dwZoneID));
	cJSON_AddNumberToObject(root,"Rank", (double)(data.wRank));
	cJSON_AddNumberToObject(root,"PosID", (double)(data.byPosID));

	return root;
}

INT32 DT_SIMPLE_FACTION_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 4;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stFactionBaseInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwZoneID);
	memcpy(pDataBuff + dwOffset, &dwZoneID, sizeof(dwZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(wRank);
	memcpy(pDataBuff + dwOffset, &wRank, sizeof(wRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(byPosID);
	memcpy(pDataBuff + dwOffset, &byPosID, sizeof(byPosID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SIMPLE_FACTION_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stFactionBaseInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				if(sizeof(dwZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwZoneID, 0, sizeof(dwZoneID));
				}
			}
			break;
		case 3:
			{
				if(sizeof(wRank) >= pstIndex->dwContextLen)
				{
					memcpy(&wRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRank, 0, sizeof(wRank));
				}
			}
			break;
		case 4:
			{
				if(sizeof(byPosID) >= pstIndex->dwContextLen)
				{
					memcpy(&byPosID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byPosID, 0, sizeof(byPosID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_SIMPLE_FACTION_LST_INFO(void *pHost, CNetData* poNetData)
{
	DT_SIMPLE_FACTION_LST_INFO *pstIn = (DT_SIMPLE_FACTION_LST_INFO*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wFactionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RANK_DISPLAY; i++)
	{
		if(i >= (INT32)pstIn->wFactionNum)
			break;
		if(-1 == EncodeDT_SIMPLE_FACTION_INFO(&pstIn->astFactionInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_SIMPLE_FACTION_LST_INFO(void *pHost, CNetData* poNetData)
{
	DT_SIMPLE_FACTION_LST_INFO *pstOut = (DT_SIMPLE_FACTION_LST_INFO*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wFactionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RANK_DISPLAY; i++)
	{
		if(i >= (INT32)pstOut->wFactionNum)
			break;
		if(-1 == DecodeDT_SIMPLE_FACTION_INFO(&pstOut->astFactionInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_SIMPLE_FACTION_LST_INFO(DT_SIMPLE_FACTION_LST_INFO &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionNum", (double)(data.wFactionNum));
	cJSON *FactionInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionInfo", FactionInfo);
	for( UINT32 dwIndex=0; dwIndex<data.wFactionNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionInfo, " ", GetJsonDT_SIMPLE_FACTION_INFO(data.astFactionInfo[dwIndex]));
	}

	return root;
}

INT32 DT_SIMPLE_FACTION_LST_INFO::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wFactionNum);
	memcpy(pDataBuff + dwOffset, &wFactionNum, sizeof(wFactionNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wFactionNum > MAX_RANK_DISPLAY)
	{
		wFactionNum = MAX_RANK_DISPLAY;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wFactionNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wFactionNum; i++)
	{
		dwContextLenTmp += astFactionInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_SIMPLE_FACTION_LST_INFO::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wFactionNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wFactionNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFactionNum, 0, sizeof(wFactionNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wFactionNum)
				{
					wArrNum = wArrNum <= MAX_RANK_DISPLAY ? wArrNum : MAX_RANK_DISPLAY;
					wFactionNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionInfo, 0, sizeof(astFactionInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionInfo, 0, sizeof(astFactionInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_FACTION_RANK_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION_RANK_DATA *pstIn = (DT_GVG_FACTION_RANK_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wRank))
		return -1;

	if(-1 == EncodeDT_FACTION_BASE_DATA_CLI2(&pstIn->stFactionBaseInfo, poNetData))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwSumPower))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwSumIntegral))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byWinNum))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byLostNum))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wZoneID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_FACTION_RANK_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION_RANK_DATA *pstOut = (DT_GVG_FACTION_RANK_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wRank))
		return -1;

	if(-1 == DecodeDT_FACTION_BASE_DATA_CLI2(&pstOut->stFactionBaseInfo, poNetData))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwSumPower))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwSumIntegral))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byWinNum))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byLostNum))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wZoneID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_FACTION_RANK_DATA(DT_GVG_FACTION_RANK_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"Rank", (double)(data.wRank));
	cJSON_AddItemToObject(root, "FactionBaseInfo", GetJsonDT_FACTION_BASE_DATA_CLI2(data.stFactionBaseInfo));
	cJSON_AddNumberToObject(root,"SumPower", (double)(data.qwSumPower));
	cJSON_AddNumberToObject(root,"SumIntegral", (double)(data.dwSumIntegral));
	cJSON_AddNumberToObject(root,"WinNum", (double)(data.byWinNum));
	cJSON_AddNumberToObject(root,"LostNum", (double)(data.byLostNum));
	cJSON_AddNumberToObject(root,"ZoneID", (double)(data.wZoneID));

	return root;
}

INT32 DT_GVG_FACTION_RANK_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 7;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wRank);
	memcpy(pDataBuff + dwOffset, &wRank, sizeof(wRank));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stFactionBaseInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(qwSumPower);
	memcpy(pDataBuff + dwOffset, &qwSumPower, sizeof(qwSumPower));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = sizeof(dwSumIntegral);
	memcpy(pDataBuff + dwOffset, &dwSumIntegral, sizeof(dwSumIntegral));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = sizeof(byWinNum);
	memcpy(pDataBuff + dwOffset, &byWinNum, sizeof(byWinNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = sizeof(byLostNum);
	memcpy(pDataBuff + dwOffset, &byLostNum, sizeof(byLostNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = sizeof(wZoneID);
	memcpy(pDataBuff + dwOffset, &wZoneID, sizeof(wZoneID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_FACTION_RANK_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wRank) >= pstIndex->dwContextLen)
				{
					memcpy(&wRank, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRank, 0, sizeof(wRank));
				}
			}
			break;
		case 2:
			{
				stFactionBaseInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				if(sizeof(qwSumPower) >= pstIndex->dwContextLen)
				{
					memcpy(&qwSumPower, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwSumPower, 0, sizeof(qwSumPower));
				}
			}
			break;
		case 4:
			{
				if(sizeof(dwSumIntegral) >= pstIndex->dwContextLen)
				{
					memcpy(&dwSumIntegral, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwSumIntegral, 0, sizeof(dwSumIntegral));
				}
			}
			break;
		case 5:
			{
				if(sizeof(byWinNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byWinNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWinNum, 0, sizeof(byWinNum));
				}
			}
			break;
		case 6:
			{
				if(sizeof(byLostNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byLostNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byLostNum, 0, sizeof(byLostNum));
				}
			}
			break;
		case 7:
			{
				if(sizeof(wZoneID) >= pstIndex->dwContextLen)
				{
					memcpy(&wZoneID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wZoneID, 0, sizeof(wZoneID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_FACTION_RANK_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION_RANK_LST_DATA *pstIn = (DT_GVG_FACTION_RANK_LST_DATA*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wRankNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RANK_DISPLAY; i++)
	{
		if(i >= (INT32)pstIn->wRankNum)
			break;
		if(-1 == EncodeDT_GVG_FACTION_RANK_DATA(&pstIn->astFactionRank[i], poNetData))
			return -1;
	}

	if(-1 == EncodeDT_GVG_FACTION(&pstIn->stNo1, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_FACTION_RANK_LST_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION_RANK_LST_DATA *pstOut = (DT_GVG_FACTION_RANK_LST_DATA*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wRankNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_RANK_DISPLAY; i++)
	{
		if(i >= (INT32)pstOut->wRankNum)
			break;
		if(-1 == DecodeDT_GVG_FACTION_RANK_DATA(&pstOut->astFactionRank[i], poNetData))
			return -1;
	}

	if(-1 == DecodeDT_GVG_FACTION(&pstOut->stNo1, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_FACTION_RANK_LST_DATA(DT_GVG_FACTION_RANK_LST_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"RankNum", (double)(data.wRankNum));
	cJSON *FactionRank = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionRank", FactionRank);
	for( UINT32 dwIndex=0; dwIndex<data.wRankNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionRank, " ", GetJsonDT_GVG_FACTION_RANK_DATA(data.astFactionRank[dwIndex]));
	}
	cJSON_AddItemToObject(root, "No1", GetJsonDT_GVG_FACTION(data.stNo1));

	return root;
}

INT32 DT_GVG_FACTION_RANK_LST_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wRankNum);
	memcpy(pDataBuff + dwOffset, &wRankNum, sizeof(wRankNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(wRankNum > MAX_RANK_DISPLAY)
	{
		wRankNum = MAX_RANK_DISPLAY;
	}
	*(UINT16*)(pDataBuff + dwOffset) = wRankNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < wRankNum; i++)
	{
		dwContextLenTmp += astFactionRank[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stNo1.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_FACTION_RANK_LST_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wRankNum) >= pstIndex->dwContextLen)
				{
					memcpy(&wRankNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wRankNum, 0, sizeof(wRankNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == wRankNum)
				{
					wArrNum = wArrNum <= MAX_RANK_DISPLAY ? wArrNum : MAX_RANK_DISPLAY;
					wRankNum = (UINT16)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionRank[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionRank, 0, sizeof(astFactionRank));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionRank, 0, sizeof(astFactionRank));
				}
			}
			break;
		case 3:
			{
				stNo1.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_BATTLE_RESULT(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BATTLE_RESULT *pstIn = (DT_FACTION_BATTLE_RESULT*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID1))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID2))
		return -1;

	if(-1 == poNetData->AddDword(pstIn->dwWinFactionID))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_BATTLE_RESULT(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BATTLE_RESULT *pstOut = (DT_FACTION_BATTLE_RESULT*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID1))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID2))
		return -1;

	if(-1 == poNetData->DelDword(pstOut->dwWinFactionID))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_BATTLE_RESULT(DT_FACTION_BATTLE_RESULT &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionID1", (double)(data.dwFactionID1));
	cJSON_AddNumberToObject(root,"FactionID2", (double)(data.dwFactionID2));
	cJSON_AddNumberToObject(root,"WinFactionID", (double)(data.dwWinFactionID));

	return root;
}

INT32 DT_FACTION_BATTLE_RESULT::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionID1);
	memcpy(pDataBuff + dwOffset, &dwFactionID1, sizeof(dwFactionID1));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(dwFactionID2);
	memcpy(pDataBuff + dwOffset, &dwFactionID2, sizeof(dwFactionID2));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = sizeof(dwWinFactionID);
	memcpy(pDataBuff + dwOffset, &dwWinFactionID, sizeof(dwWinFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_BATTLE_RESULT::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionID1) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID1, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID1, 0, sizeof(dwFactionID1));
				}
			}
			break;
		case 2:
			{
				if(sizeof(dwFactionID2) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID2, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID2, 0, sizeof(dwFactionID2));
				}
			}
			break;
		case 3:
			{
				if(sizeof(dwWinFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwWinFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwWinFactionID, 0, sizeof(dwWinFactionID));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_FACTION_BATTLE_RESULT_LST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BATTLE_RESULT_LST *pstIn = (DT_FACTION_BATTLE_RESULT_LST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byResultNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_BATTLE_NUM; i++)
	{
		if(i >= (INT32)pstIn->byResultNum)
			break;
		if(-1 == EncodeDT_FACTION_BATTLE_RESULT(&pstIn->astBattleInfo[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_FACTION_BATTLE_RESULT_LST(void *pHost, CNetData* poNetData)
{
	DT_FACTION_BATTLE_RESULT_LST *pstOut = (DT_FACTION_BATTLE_RESULT_LST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byResultNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_BATTLE_NUM; i++)
	{
		if(i >= (INT32)pstOut->byResultNum)
			break;
		if(-1 == DecodeDT_FACTION_BATTLE_RESULT(&pstOut->astBattleInfo[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_FACTION_BATTLE_RESULT_LST(DT_FACTION_BATTLE_RESULT_LST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ResultNum", (double)(data.byResultNum));
	cJSON *BattleInfo = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "BattleInfo", BattleInfo);
	for( UINT32 dwIndex=0; dwIndex<data.byResultNum; ++dwIndex)
	{
		cJSON_AddItemToObject(BattleInfo, " ", GetJsonDT_FACTION_BATTLE_RESULT(data.astBattleInfo[dwIndex]));
	}

	return root;
}

INT32 DT_FACTION_BATTLE_RESULT_LST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byResultNum);
	memcpy(pDataBuff + dwOffset, &byResultNum, sizeof(byResultNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byResultNum > MAX_FACTION_BATTLE_NUM)
	{
		byResultNum = MAX_FACTION_BATTLE_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byResultNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byResultNum; i++)
	{
		dwContextLenTmp += astBattleInfo[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_FACTION_BATTLE_RESULT_LST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byResultNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byResultNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byResultNum, 0, sizeof(byResultNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byResultNum)
				{
					wArrNum = wArrNum <= MAX_FACTION_BATTLE_NUM ? wArrNum : MAX_FACTION_BATTLE_NUM;
					byResultNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astBattleInfo[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astBattleInfo, 0, sizeof(astBattleInfo));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astBattleInfo, 0, sizeof(astBattleInfo));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LOCAL_WAR_FACTION_SEED(void *pHost, CNetData* poNetData)
{
	DT_LOCAL_WAR_FACTION_SEED *pstIn = (DT_LOCAL_WAR_FACTION_SEED*)pHost;

	if(-1 == poNetData->AddDword(pstIn->dwFactionID))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byWinCnt))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOCAL_WAR_FACTION_SEED(void *pHost, CNetData* poNetData)
{
	DT_LOCAL_WAR_FACTION_SEED *pstOut = (DT_LOCAL_WAR_FACTION_SEED*)pHost;

	if(-1 == poNetData->DelDword(pstOut->dwFactionID))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byWinCnt))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOCAL_WAR_FACTION_SEED(DT_LOCAL_WAR_FACTION_SEED &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionID", (double)(data.dwFactionID));
	cJSON_AddNumberToObject(root,"WinCnt", (double)(data.byWinCnt));

	return root;
}

INT32 DT_LOCAL_WAR_FACTION_SEED::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(dwFactionID);
	memcpy(pDataBuff + dwOffset, &dwFactionID, sizeof(dwFactionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = sizeof(byWinCnt);
	memcpy(pDataBuff + dwOffset, &byWinCnt, sizeof(byWinCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOCAL_WAR_FACTION_SEED::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(dwFactionID) >= pstIndex->dwContextLen)
				{
					memcpy(&dwFactionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&dwFactionID, 0, sizeof(dwFactionID));
				}
			}
			break;
		case 2:
			{
				if(sizeof(byWinCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&byWinCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byWinCnt, 0, sizeof(byWinCnt));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_LOCAL_WAR_FACTION_SEED_LIST(void *pHost, CNetData* poNetData)
{
	DT_LOCAL_WAR_FACTION_SEED_LIST *pstIn = (DT_LOCAL_WAR_FACTION_SEED_LIST*)pHost;

	if(-1 == poNetData->AddWord(pstIn->wFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_APPLAY_NUM; i++)
	{
		if(i >= (INT32)pstIn->wFactionCnt)
			break;
		if(-1 == poNetData->AddDword(pstIn->adwFactionIDList[i]))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_LOCAL_WAR_FACTION_SEED_LIST(void *pHost, CNetData* poNetData)
{
	DT_LOCAL_WAR_FACTION_SEED_LIST *pstOut = (DT_LOCAL_WAR_FACTION_SEED_LIST*)pHost;

	if(-1 == poNetData->DelWord(pstOut->wFactionCnt))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_FACTION_APPLAY_NUM; i++)
	{
		if(i >= (INT32)pstOut->wFactionCnt)
			break;
		if(-1 == poNetData->DelDword(pstOut->adwFactionIDList[i]))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_LOCAL_WAR_FACTION_SEED_LIST(DT_LOCAL_WAR_FACTION_SEED_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionCnt", (double)(data.wFactionCnt));
	cJSON *FactionIDList = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionIDList", FactionIDList);
	for( UINT32 dwIndex=0; dwIndex<data.wFactionCnt; ++dwIndex)
	{
		cJSON_AddNumberToObject(root,"FactionIDList", (double)(data.adwFactionIDList[dwIndex]));
	}

	return root;
}

INT32 DT_LOCAL_WAR_FACTION_SEED_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(wFactionCnt);
	memcpy(pDataBuff + dwOffset, &wFactionCnt, sizeof(wFactionCnt));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	if(wFactionCnt > MAX_FACTION_APPLAY_NUM)
	{
		wFactionCnt = MAX_FACTION_APPLAY_NUM;
	}
	pstIndex->dwContextLen = wFactionCnt * sizeof(UINT32) + ARRAY_NUM_HEAD_SIZE;
	*(UINT16*)(pDataBuff + dwOffset) = wFactionCnt;
	memcpy(pDataBuff + dwOffset + ARRAY_NUM_HEAD_SIZE, &adwFactionIDList, wFactionCnt * sizeof(UINT32));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_LOCAL_WAR_FACTION_SEED_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(wFactionCnt) >= pstIndex->dwContextLen)
				{
					memcpy(&wFactionCnt, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wFactionCnt, 0, sizeof(wFactionCnt));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwContextLen = pstIndex->dwContextLen - ARRAY_NUM_HEAD_SIZE;
				if((sizeof(adwFactionIDList) >= dwContextLen) && (wArrNum == wFactionCnt) && (wArrNum <= MAX_FACTION_APPLAY_NUM))
				{
					memcpy(&adwFactionIDList, (pDataBuff + dwOffsetTmp), dwContextLen);
				}
				else
				{
					memset(&adwFactionIDList, 0, sizeof(adwFactionIDList));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_CHAOS_WAR(void *pHost, CNetData* poNetData)
{
	DT_CHAOS_WAR *pstIn = (DT_CHAOS_WAR*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byChaosRound))
		return -1;

	if(-1 == EncodeDT_SIMPLE_FACTION_LST_INFO(&pstIn->stChaosResult, poNetData))
		return -1;

	if(-1 == EncodeDT_LOCAL_WAR_FACTION_SEED_LIST(&pstIn->stFactionSeedList, poNetData))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_CHAOS_WAR(void *pHost, CNetData* poNetData)
{
	DT_CHAOS_WAR *pstOut = (DT_CHAOS_WAR*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byChaosRound))
		return -1;

	if(-1 == DecodeDT_SIMPLE_FACTION_LST_INFO(&pstOut->stChaosResult, poNetData))
		return -1;

	if(-1 == DecodeDT_LOCAL_WAR_FACTION_SEED_LIST(&pstOut->stFactionSeedList, poNetData))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_CHAOS_WAR(DT_CHAOS_WAR &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"ChaosRound", (double)(data.byChaosRound));
	cJSON_AddItemToObject(root, "ChaosResult", GetJsonDT_SIMPLE_FACTION_LST_INFO(data.stChaosResult));
	cJSON_AddItemToObject(root, "FactionSeedList", GetJsonDT_LOCAL_WAR_FACTION_SEED_LIST(data.stFactionSeedList));

	return root;
}

INT32 DT_CHAOS_WAR::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 3;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byChaosRound);
	memcpy(pDataBuff + dwOffset, &byChaosRound, sizeof(byChaosRound));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stChaosResult.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stFactionSeedList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_CHAOS_WAR::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byChaosRound) >= pstIndex->dwContextLen)
				{
					memcpy(&byChaosRound, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byChaosRound, 0, sizeof(byChaosRound));
				}
			}
			break;
		case 2:
			{
				stChaosResult.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stFactionSeedList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_BUILD_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_BUILD_DATA *pstIn = (DT_GVG_BUILD_DATA*)pHost;

	if(-1 == EncodeDT_FACTION_APPLAY_LST_DATA(&pstIn->stApplayInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_FACTION_RANK_LST_DATA(&pstIn->stLastResult, poNetData))
		return -1;

	if(-1 == EncodeDT_SIMPLE_FACTION_LST_INFO(&pstIn->stMoneyResult, poNetData))
		return -1;

	if(-1 == EncodeDT_CHAOS_WAR(&pstIn->stChaosWar, poNetData))
		return -1;

	if(-1 == EncodeDT_16_TO_8_TO_4_WAR_INFO(&pstIn->stWar16To8To4Info, poNetData))
		return -1;

	if(-1 == EncodeDT_WAR_16_TO_8_LIST(&pstIn->stWar16To8List, poNetData))
		return -1;

	if(-1 == EncodeDT_FINAL_WAR_INFO(&pstIn->stFinalWarInfo, poNetData))
		return -1;

	if(-1 == EncodeDT_FACTION_LIST_SIMPLE_GVG_LOG(&pstIn->stFactionsLog, poNetData))
		return -1;

	if(-1 == EncodeDT_GVG_STAGE_FINISH_FLAG_LIST(&pstIn->stStageFlagList, poNetData))
		return -1;

	if(-1 == poNetData->AddByte(pstIn->byCurStage))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wSessionID))
		return -1;

	if(-1 == poNetData->AddWord(pstIn->wArenaID))
		return -1;

	if(-1 == poNetData->AddUint64(pstIn->qwStartTime))
		return -1;

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_BUILD_DATA(void *pHost, CNetData* poNetData)
{
	DT_GVG_BUILD_DATA *pstOut = (DT_GVG_BUILD_DATA*)pHost;

	if(-1 == DecodeDT_FACTION_APPLAY_LST_DATA(&pstOut->stApplayInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_FACTION_RANK_LST_DATA(&pstOut->stLastResult, poNetData))
		return -1;

	if(-1 == DecodeDT_SIMPLE_FACTION_LST_INFO(&pstOut->stMoneyResult, poNetData))
		return -1;

	if(-1 == DecodeDT_CHAOS_WAR(&pstOut->stChaosWar, poNetData))
		return -1;

	if(-1 == DecodeDT_16_TO_8_TO_4_WAR_INFO(&pstOut->stWar16To8To4Info, poNetData))
		return -1;

	if(-1 == DecodeDT_WAR_16_TO_8_LIST(&pstOut->stWar16To8List, poNetData))
		return -1;

	if(-1 == DecodeDT_FINAL_WAR_INFO(&pstOut->stFinalWarInfo, poNetData))
		return -1;

	if(-1 == DecodeDT_FACTION_LIST_SIMPLE_GVG_LOG(&pstOut->stFactionsLog, poNetData))
		return -1;

	if(-1 == DecodeDT_GVG_STAGE_FINISH_FLAG_LIST(&pstOut->stStageFlagList, poNetData))
		return -1;

	if(-1 == poNetData->DelByte(pstOut->byCurStage))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wSessionID))
		return -1;

	if(-1 == poNetData->DelWord(pstOut->wArenaID))
		return -1;

	if(-1 == poNetData->DelUint64(pstOut->qwStartTime))
		return -1;

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_BUILD_DATA(DT_GVG_BUILD_DATA &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddItemToObject(root, "ApplayInfo", GetJsonDT_FACTION_APPLAY_LST_DATA(data.stApplayInfo));
	cJSON_AddItemToObject(root, "LastResult", GetJsonDT_GVG_FACTION_RANK_LST_DATA(data.stLastResult));
	cJSON_AddItemToObject(root, "MoneyResult", GetJsonDT_SIMPLE_FACTION_LST_INFO(data.stMoneyResult));
	cJSON_AddItemToObject(root, "ChaosWar", GetJsonDT_CHAOS_WAR(data.stChaosWar));
	cJSON_AddItemToObject(root, "War16To8To4Info", GetJsonDT_16_TO_8_TO_4_WAR_INFO(data.stWar16To8To4Info));
	cJSON_AddItemToObject(root, "War16To8List", GetJsonDT_WAR_16_TO_8_LIST(data.stWar16To8List));
	cJSON_AddItemToObject(root, "FinalWarInfo", GetJsonDT_FINAL_WAR_INFO(data.stFinalWarInfo));
	cJSON_AddItemToObject(root, "FactionsLog", GetJsonDT_FACTION_LIST_SIMPLE_GVG_LOG(data.stFactionsLog));
	cJSON_AddItemToObject(root, "StageFlagList", GetJsonDT_GVG_STAGE_FINISH_FLAG_LIST(data.stStageFlagList));
	cJSON_AddNumberToObject(root,"CurStage", (double)(data.byCurStage));
	cJSON_AddNumberToObject(root,"SessionID", (double)(data.wSessionID));
	cJSON_AddNumberToObject(root,"ArenaID", (double)(data.wArenaID));
	cJSON_AddNumberToObject(root,"StartTime", (double)(data.qwStartTime));

	return root;
}

INT32 DT_GVG_BUILD_DATA::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 13;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = stApplayInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	pstIndex->dwContextLen = stLastResult.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 3;
	pstIndex->dwContextLen = stMoneyResult.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 4;
	pstIndex->dwContextLen = stChaosWar.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 5;
	pstIndex->dwContextLen = stWar16To8To4Info.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 6;
	pstIndex->dwContextLen = stWar16To8List.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 7;
	pstIndex->dwContextLen = stFinalWarInfo.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 8;
	pstIndex->dwContextLen = stFactionsLog.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 9;
	pstIndex->dwContextLen = stStageFlagList.EncodeSaveData(pDataBuff + dwOffset, dwBuffLen-wIndexAddrLen-dwOffset);
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 10;
	pstIndex->dwContextLen = sizeof(byCurStage);
	memcpy(pDataBuff + dwOffset, &byCurStage, sizeof(byCurStage));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 11;
	pstIndex->dwContextLen = sizeof(wSessionID);
	memcpy(pDataBuff + dwOffset, &wSessionID, sizeof(wSessionID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 12;
	pstIndex->dwContextLen = sizeof(wArenaID);
	memcpy(pDataBuff + dwOffset, &wArenaID, sizeof(wArenaID));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 13;
	pstIndex->dwContextLen = sizeof(qwStartTime);
	memcpy(pDataBuff + dwOffset, &qwStartTime, sizeof(qwStartTime));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_BUILD_DATA::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				stApplayInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 2:
			{
				stLastResult.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 3:
			{
				stMoneyResult.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 4:
			{
				stChaosWar.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 5:
			{
				stWar16To8To4Info.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 6:
			{
				stWar16To8List.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 7:
			{
				stFinalWarInfo.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 8:
			{
				stFactionsLog.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 9:
			{
				stStageFlagList.DecodeSaveData(pDataBuff + dwOffset, pstIndex->dwContextLen);
			}
			break;
		case 10:
			{
				if(sizeof(byCurStage) >= pstIndex->dwContextLen)
				{
					memcpy(&byCurStage, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byCurStage, 0, sizeof(byCurStage));
				}
			}
			break;
		case 11:
			{
				if(sizeof(wSessionID) >= pstIndex->dwContextLen)
				{
					memcpy(&wSessionID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wSessionID, 0, sizeof(wSessionID));
				}
			}
			break;
		case 12:
			{
				if(sizeof(wArenaID) >= pstIndex->dwContextLen)
				{
					memcpy(&wArenaID, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&wArenaID, 0, sizeof(wArenaID));
				}
			}
			break;
		case 13:
			{
				if(sizeof(qwStartTime) >= pstIndex->dwContextLen)
				{
					memcpy(&qwStartTime, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&qwStartTime, 0, sizeof(qwStartTime));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

INT32 EncodeDT_GVG_FACTION_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION_LIST *pstIn = (DT_GVG_FACTION_LIST*)pHost;

	if(-1 == poNetData->AddByte(pstIn->byFactionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_FACTION_NUM; i++)
	{
		if(i >= (INT32)pstIn->byFactionNum)
			break;
		if(-1 == EncodeDT_GVG_FACTION(&pstIn->astFactionLstData[i], poNetData))
			return -1;
	}

	return poNetData->GetDataLen();
}

INT32 DecodeDT_GVG_FACTION_LIST(void *pHost, CNetData* poNetData)
{
	DT_GVG_FACTION_LIST *pstOut = (DT_GVG_FACTION_LIST*)pHost;

	if(-1 == poNetData->DelByte(pstOut->byFactionNum))
		return -1;

	INT32 i;
	for(i = 0; i < MAX_GVG_FACTION_NUM; i++)
	{
		if(i >= (INT32)pstOut->byFactionNum)
			break;
		if(-1 == DecodeDT_GVG_FACTION(&pstOut->astFactionLstData[i], poNetData))
			return -1;
	}

	return sizeof(*pstOut);
}

cJSON* GetJsonDT_GVG_FACTION_LIST(DT_GVG_FACTION_LIST &data)
{
	cJSON *root = cJSON_CreateObject();
	cJSON_AddNumberToObject(root,"FactionNum", (double)(data.byFactionNum));
	cJSON *FactionLstData = cJSON_CreateArray();
	cJSON_AddItemToObject(root, "FactionLstData", FactionLstData);
	for( UINT32 dwIndex=0; dwIndex<data.byFactionNum; ++dwIndex)
	{
		cJSON_AddItemToObject(FactionLstData, " ", GetJsonDT_GVG_FACTION(data.astFactionLstData[dwIndex]));
	}

	return root;
}

INT32 DT_GVG_FACTION_LIST::EncodeSaveData(CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = 2;
	*pBuff = byIdxNum;
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	CHAR *pDataBuff = pBuff + wIndexAddrLen;
	UINT32 dwOffset = 0;
	UINT32 dwContextLenTmp = 0;
	UINT32 dwOffsetTmp = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);

	pstIndex->byIdx = 1;
	pstIndex->dwContextLen = sizeof(byFactionNum);
	memcpy(pDataBuff + dwOffset, &byFactionNum, sizeof(byFactionNum));
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;

	pstIndex->byIdx = 2;
	dwContextLenTmp = 0;
	if(byFactionNum > MAX_GVG_FACTION_NUM)
	{
		byFactionNum = MAX_GVG_FACTION_NUM;
	}
	*(UINT16*)(pDataBuff + dwOffset) = byFactionNum;
	dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
	for(UINT16 i = 0; i < byFactionNum; i++)
	{
		dwContextLenTmp += astFactionLstData[i].EncodeSaveData(pDataBuff + dwOffsetTmp, dwBuffLen-wIndexAddrLen-dwOffsetTmp);
		dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE+ dwContextLenTmp;
	}
	pstIndex->dwContextLen = dwContextLenTmp + ARRAY_NUM_HEAD_SIZE;
	dwOffset += pstIndex->dwContextLen;
	pstIndex++;
	return wIndexAddrLen + dwOffset;
}

INT32 DT_GVG_FACTION_LIST::DecodeSaveData(const CHAR *pBuff, const UINT32 dwBuffLen)
{
	if(NULL == pBuff)
	{
		return -1;
	}
	UINT8 byIdxNum = (UINT8)(*pBuff);
	UINT16 wIndexAddrLen = byIdxNum * sizeof(SIndex) + INDEX_NUM_HEAD_SIZE;
	if(wIndexAddrLen >= dwBuffLen)
	{
		return -1;
	}
	CHAR *pDataBuff = (CHAR*)pBuff + wIndexAddrLen;

	UINT32 dwOffset = 0;
	SIndex* pstIndex = (SIndex*)(pBuff + INDEX_NUM_HEAD_SIZE);
	while(byIdxNum-- > 0)
	{
		switch(pstIndex->byIdx)
		{
		case 1:
			{
				if(sizeof(byFactionNum) >= pstIndex->dwContextLen)
				{
					memcpy(&byFactionNum, (pDataBuff + dwOffset), pstIndex->dwContextLen);
				}
				else
				{
					memset(&byFactionNum, 0, sizeof(byFactionNum));
				}
			}
			break;
		case 2:
			{
				UINT16 wArrNum = *(UINT16*)(pDataBuff + dwOffset);
				UINT32 dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE;
				UINT32 dwPassContextLen = 0;
				if(wArrNum == byFactionNum)
				{
					wArrNum = wArrNum <= MAX_GVG_FACTION_NUM ? wArrNum : MAX_GVG_FACTION_NUM;
					byFactionNum = (UINT8)wArrNum;
					for(UINT16 i = 0; i < wArrNum; i++)
					{
						dwPassContextLen += astFactionLstData[i].DecodeSaveData(pDataBuff + dwOffsetTmp, pstIndex->dwContextLen - dwPassContextLen);
						if(dwPassContextLen >= pstIndex->dwContextLen)
						{
							memset(astFactionLstData, 0, sizeof(astFactionLstData));
							break;
						}
						dwOffsetTmp = dwOffset + ARRAY_NUM_HEAD_SIZE + dwPassContextLen;
					}
				}
				else
				{
					memset(&astFactionLstData, 0, sizeof(astFactionLstData));
				}
			}
			break;
		default:
			break;
		}

		dwOffset += pstIndex->dwContextLen;
		pstIndex++;
	}

	return wIndexAddrLen + dwOffset;
}

