/**
 **	File:	gclass.cpp
 **
 **	Published / author: 2004-04-14 / grymse@alhem.net
 **/

/*
Copyright (C) 2004  Anders Hedstrom

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
*/
#ifdef _WIN32
#pragma warning(disable:4786)
#endif

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#include "sql2class.h"
#include "utils.h"

#include "gclass.h"

void generate_class(TBLS *table, short overwrite, char *dbname, short global, char *defdir)
{
    FILE *fil;
    time_t ti = time(NULL);
    struct tm *tp = localtime(&ti);
    char *ptrtotable;
    int i;
    short first;
    char c;
    char classname[200];
    char filename[200];
    char define[200];
    char slask[200];
    char cclassname[200];	// container class name
    char cstruct[200];	// container struct
    char lwrclassname[200];
    char slask2[200];

    strcpy(classname, table -> name.c_str());
    strlwr(classname);
    strcpy(lwrclassname, classname);
    if (*classname >= 'a' && *classname <= 'z')
        *classname -= 32;

    if (global)
        sprintf(filename, "%s/", defdir);
    else
        *filename = 0;
    if (*dbname)
    {
        sprintf(filename + strlen(filename), "sqlTbl%s%s.h", dbname, classname);
        sprintf(define, "_sqltbl%s%s_H", dbname, table -> name.c_str());
        strupr(define);
    }
    else
    {
        sprintf(filename + strlen(filename), "sqlTbl%s.h", classname);
        sprintf(define, "_sqltbl%s_H", table -> name.c_str());
        strupr(define);
    }
//    if ((fil = fopen(filename, "rt")) != NULL)
//    {
//        fclose(fil);
//        if (!overwrite)
//        {
//            printf("'%s' already exists - not replaced\n", filename);
//            return;
//        }
////		printf("'%s' already exists - replacing\n",filename);
//    }
    if ((fil = fopen(filename, "wt")) == NULL)
    {
        printf("Couldn't create '%s'...\n", filename);
        return;
    }

    fprintf(fil, "/*\n");
    fprintf(fil, " *\t %s\n", filename);
    fprintf(fil, " *\t Generated by sql2class by (C) AH 2013-2014\n");
    fprintf(fil, " *\t %s", asctime(tp));
    fprintf(fil, " */\n");
    fprintf(fil, "\n");

    fprintf(fil, "\n");

    fprintf(fil, "#ifndef %s\n", define);
    fprintf(fil, "#define %s\n", define);
    fprintf(fil, "\n");
//	fprintf(fil,"#include <Query.h>\n");
    fprintf(fil, "#include \"protocol/server/protocommondata.h\"\n");
    fprintf(fil, "#include \"db/autosqlbuf.h\"\n");
    fprintf(fil, "\n");
    fprintf(fil, "\n");

    fprintf(fil, "class %s {\n", classname);
    fprintf(fil, "public:\n");

// empty constructor
    /*
    	fprintf(fil,"\t%s::%s(void) {\n",classname,classname);
    	fprintf(fil,"\t\tm_poDBConn = NULL;\n");
    	fprintf(fil,"\t\tnew_object = 0;\n");
    	fprintf(fil,"\t\tclear();\n");
    	fprintf(fil,"\t}\n");
    */

// empty constructor + database
    fprintf(fil, "\t%s::%s(SGDP::ISDDBConnection* poDBConn) {\n", classname, classname);
    fprintf(fil, "\t\tm_poDBConn = poDBConn;\n");
    fprintf(fil, "\t\tnew_object = 1;\n");
    fprintf(fil, "\t\tclear();\n");
    fprintf(fil, "\t}\n");

// data fetch constructor + database
    fprintf(fil, "\t%s::%s(SGDP::ISDDBConnection* poDBConn,long ix) {\n", classname, classname);
    fprintf(fil, "\t\tchar sql[256];\n");
    fprintf(fil, "\t\tm_poDBConn = poDBConn;\n");
    fprintf(fil, "\t\tnew_object = 1;\n");
    {
        fields_l::iterator it = table -> fieldsbase.begin();
        FIELDS *f = *it;
        fprintf(fil, "\t\tsprintf(sql,\"select * from %s where %s=%%ld\",ix);\n", table -> name.c_str(), f -> column);
    }
    // call spawn here
    fprintf(fil, "\t\tspawn(sql);\n");
    fprintf(fil, "\t}\n");

// data fetch constructor + database
    fprintf(fil, "\t%s::%s(SGDP::ISDDBConnection* poDBConn,char *sql) {\n", classname, classname);
    fprintf(fil, "\t\tm_poDBConn = poDBConn;\n");
    fprintf(fil, "\t\tnew_object = 1;\n");
    // call spawn here
    fprintf(fil, "\t\tspawn(sql);\n");
    fprintf(fil, "\t}\n");


// destructor
    fprintf(fil, "\t%s::~%s(void) {\n", classname, classname);
    for (fields_l::iterator it = table -> fieldsbase.begin(); it != table -> fieldsbase.end(); it++)
    {
        FIELDS *t = *it;
        if (!strcmp(t -> ctype, "text"))
        {
            fprintf(fil, "\t\tif (%s)\n", t -> column);
            fprintf(fil, "\t\t\tdelete %s;\n", t -> column);
        }
    }
    fprintf(fil, "\t}\n");
    fprintf(fil, "\n");


// void Class::select(char *) 'spawn_wrapper'
//	numera ersatt av Class::Class(db,sql)...
    fprintf(fil, "\tvoid %s::select(char *sql) {\n", classname);
    fprintf(fil, "\t\tspawn(sql);\n");
    fprintf(fil, "\t}\n");
    fprintf(fil, "\n");


// long Class::insert(void)
//	'insert into ...(...) values(...)'
    fprintf(fil, "\tlong %s::insert(void) {\n", classname);

    fprintf(fil, "\t\tCAutoSqlBuf oAutoSql;\n");
    fprintf(fil, "\t\tCAutoSqlBuf oAutoBuf;\n");
    fprintf(fil, "\t\tCAutoSqlBuf oAutoTmp;\n");
    fprintf(fil, "\t\tCAutoSqlBuf oAutoSafeTmp;\n");

    fprintf(fil, "\t\tCHAR *pszSql = oAutoSql.GetSqlBuf();\n");
    fprintf(fil, "\t\tCHAR *pszBuff = oAutoBuf.GetSqlBuf();\n");
    fprintf(fil, "\t\tCHAR *pszTmp = oAutoTmp.GetSqlBuf();\n");
    fprintf(fil, "\t\tCHAR *pszSafeTmp = oAutoSafeTmp.GetSqlBuf();\n");


    fprintf(fil, "\n");
    fprintf(fil, "\t\tif((NULL == pszSql) || (NULL == pszBuff) || (NULL == pszTmp) || (NULL == pszSafeTmp))\n");
    fprintf(fil, "\t\t{\n");
    fprintf(fil, "\t\t\treturn FALSE;\n");
    fprintf(fil, "\t\t}\n");


    fprintf(fil, "\t\tsprintf(pszSql,\"insert into %s(\");\n", table -> name.c_str());
    fprintf(fil, "\t\tsprintf(pszBuff,\"values (\");\n");
    *slask = 0;
    {
        fprintf(fil, "\t\tUINT32 dwRet = 0;\n");

        for (fields_l::iterator it = table -> fieldsbase.begin(); it != table -> fieldsbase.end(); it++)
        {
            FIELDS *t = *it;
            fprintf(fil, "\t\tSDStrcat(pszSql,\"%s%s\");\n", slask, t -> column);

            if (!strcmp(t -> ctype, "double"))
            {
                fprintf(fil, "\t\tSDSprintf(pszSafeTmp, \"%s%%f\", %s);\n", slask, t -> column);
            }
            else if (!strcmp(t -> ctype, "long"))
            {
                fprintf(fil, "\t\tSDSprintf(pszSafeTmp, \"%s%%ld\", %s);\n", slask, t -> column);
            }
            else if (!strcmp(t -> ctype, "struct"))
            {
                fprintf(fil, "\t\t{\n");
                fprintf(fil, "\t\t\tINT32 nLength = %s.EncodeSaveData(pszTmp, MAX_SQL_LEN);\n", t -> column);
                fprintf(fil, "\t\t\tif(nLength <= 0)\n");
                fprintf(fil, "\t\t\t{\n");
                fprintf(fil, "\t\t\t	return FALSE;\n");
                fprintf(fil, "\t\t\t}\n");

                fprintf(fil, "\t\t\tSDSprintf(pszTmp, \"%s'%%s'\", %s);\n", slask, t -> column);
                fprintf(fil, "\t\t\tUINT32 dwRet = m_poDBConn->EscapeString(pszTmp, nLength, pszTmp, MAX_SQL_LEN);\n");
                fprintf(fil, "\t\t\tif(dwRet <= 0)\n");
                fprintf(fil, "\t\t\t{\n");
                fprintf(fil, "\t\t\t	return FALSE;\n");
                fprintf(fil, "\t\t\t}\n");
                fprintf(fil, "\t\t}\n");
            }
            //×Ö·ûÒªÌØÊâ×ªÂë
            else if (*t -> ctype)
            {
				fprintf(fil, "\t\t{\n");
                fprintf(fil, "\t\t\tSDSprintf(pszTmp, \"%s'%%s'\", %s);\n", slask, t -> column);
                fprintf(fil, "\t\t\tUINT32 dwRet = m_poDBConn->EscapeString(pszTmp, strlen(pszTmp), pszTmp, MAX_SQL_LEN);\n");
                fprintf(fil, "\t\t\tif(dwRet <= 0)\n");
                fprintf(fil, "\t\t\t{\n");
                fprintf(fil, "\t\t\t	return FALSE;\n");
                fprintf(fil, "\t\t\t}\n");
				fprintf(fil, "\t\t}\n");
            }
            else
                fprintf(fil, "\t\tSDSprintf(pszSafeTmp, \"%s''\", %s);\n", slask, t -> column);	// unsupported data type

            strcpy(slask, ",");

            fprintf(fil, "\t\tSDStrcat(pszBuff, pszSafeTmp);\n");
            fprintf(fil, "\t\t\n");
        }
    }
    fprintf(fil, "\t\tSDStrcat(pszSql, \")\");\n");
    fprintf(fil, "\t\tSDStrcat(pszBuff, \")\");\n");
    fprintf(fil, "\t\tSDStrcat(pszSql, pszBuff);\n");

    fprintf(fil, "\t\tUINT32 dwErr = 0;\n");
    fprintf(fil, "\t\tstring strError = \"\";\n");
    fprintf(fil, "\t\tINT32 nRet = m_poDBConn->ExecuteSql(pszSql, NULL, NULL, &dwErr, &strError);\n");
    fprintf(fil, "\t\tif(nRet < 0)\n");
    fprintf(fil, "\t\t{\n");
    fprintf(fil, "\t\t	return FALSE;\n");
    fprintf(fil, "\t\t}\n");

    fprintf(fil, "\t}\n");
    fprintf(fil, "\n");


// void Class::update(void)
    fprintf(fil, "\tBOOL %s::update(void) {\n", classname);
    {
        fields_l::iterator it = table -> fieldsbase.begin();
        FIELDS *f = *it;
        fprintf(fil, "\t\t%s::update(%s);\n", classname, f -> column);
    }
    fprintf(fil, "\t}\n");
    fprintf(fil, "\n");

// void Class::update(long num)
//	'update ... set ... where ...'
    fprintf(fil, "\tBOOL %s::update(long ix) {\n", classname);
    fprintf(fil, "\t\tCAutoSqlBuf oAutoSql;\n");
    fprintf(fil, "\t\tCAutoSqlBuf oAutoBuf;\n");
    fprintf(fil, "\t\tCAutoSqlBuf oAutoTmp;\n");
    fprintf(fil, "\t\tCAutoSqlBuf oAutoSafeTmp;\n");

    fprintf(fil, "\t\tCHAR *pszSql = oAutoSql.GetSqlBuf();\n");
    fprintf(fil, "\t\tCHAR *pszBuff = oAutoBuf.GetSqlBuf();\n");
    fprintf(fil, "\t\tCHAR *pszTmp = oAutoTmp.GetSqlBuf();\n");
    fprintf(fil, "\t\tCHAR *pszSafeTmp = oAutoSafeTmp.GetSqlBuf();\n");


    fprintf(fil, "\n");
    fprintf(fil, "\t\tif((NULL == pszSql) || (NULL == pszBuff) || (NULL == pszTmp) || (NULL == pszSafeTmp))\n");
    fprintf(fil, "\t\t{\n");
    fprintf(fil, "\t\t\treturn FALSE;\n");
    fprintf(fil, "\t\t}\n");


    fprintf(fil, "\t\tsprintf(pszSql,\"update %s set\");\n", table -> name.c_str());
    c = ' ';
    {
        for (fields_l::iterator it = table -> fieldsbase.begin(); it != table -> fieldsbase.end(); it++)
        {
            FIELDS *t = *it;
            if (!strcmp(t -> ctype, "double"))
            {

                fprintf(fil, "\t\tSDSprintf(pszBuff, \"%c%s=%%f\", %s);\n", c, t -> column, t -> column);
                c = ',';
            }
            else if (!strcmp(t -> ctype, "long"))
            {
                fprintf(fil, "\t\tSDSprintf(pszBuff, \"%c%s=%%ld\", %s);\n", c, t -> column, t -> column);
                c = ',';
            }
            else if (!strcmp(t -> ctype, "struct"))
            {
				fprintf(fil, "\t\t{\n");
                fprintf(fil, "\t\t\tINT32 nLength = %s.EncodeSaveData(pszTmp, MAX_SQL_LEN);\n", t -> column);
                fprintf(fil, "\t\t\tif(nLength <= 0)\n");
                fprintf(fil, "\t\t\t{\n");
                fprintf(fil, "\t\t\t	return FALSE;\n");
                fprintf(fil, "\t\t\t}\n");

                fprintf(fil, "\t\t\tSDSprintf(pszTmp, \"%%s\", %s);\n", t -> column);
                fprintf(fil, "\t\t\tUINT32 dwRet = m_poDBConn->EscapeString(pszTmp, nLength, pszSafeTmp, MAX_SQL_LEN);\n");
                fprintf(fil, "\t\t\tif(dwRet <= 0)\n");
                fprintf(fil, "\t\t\t{\n");
                fprintf(fil, "\t\t\t	return FALSE;\n");
                fprintf(fil, "\t\t\t}\n");
				fprintf(fil, "\t\t}\n");

                fprintf(fil, "\t\tSDSprintf(pszBuff, \"%c%s='%%s'\", pszSafeTmp);\n", c, t -> column);
                c = ',';
            }
            else if (*t -> ctype)
            {
                fprintf(fil, "\t\tSDSprintf(pszBuff, \"%c%s='%%s'\", %s);\n", c, t -> column, t -> column);
                c = ',';
            }
            fprintf(fil, "\t\tSDStrcat(pszSql, pszBuff);\n");
            fprintf(fil, "\n");
        }
    }
    //where
    {
        fields_l::iterator it = table -> fieldsbase.begin();
        FIELDS *f = *it;
        fprintf(fil, "\t\tSDSprintf(pszBuff, \" where %s = %%ld\", %s);\n", f -> column, f -> column);
        fprintf(fil, "\t\tSDStrcat(pszSql, pszBuff);\n");
    }

    fprintf(fil, "\t\tUINT32 dwErr = 0;\n");
    fprintf(fil, "\t\tstring strError = \"\";\n");
    fprintf(fil, "\t\tINT32 nRet = m_poDBConn->ExecuteSql(pszSql, NULL, NULL, &dwErr, &strError);\n");
    fprintf(fil, "\t\tif(nRet < 0)\n");
    fprintf(fil, "\t\t{\n");
    fprintf(fil, "\t\t	return FALSE;\n");
    fprintf(fil, "\t\t}\n");
	fprintf(fil, "\t\treturn TRUE;\n");
    fprintf(fil, "\t}\n");
    fprintf(fil, "\n");

// void Class::save(void)
    fprintf(fil, "\tvoid %s::save(void) {\n", classname);
    fprintf(fil, "\t\tif (new_object)\n");
    fprintf(fil, "\t\t\tinsert();\n");
    fprintf(fil, "\t\telse\n");
    fprintf(fil, "\t\t\tupdate();\n");
    fprintf(fil, "\t}\n");

// variables
    {
        for (fields_l::iterator it = table -> fieldsbase.begin(); it != table -> fieldsbase.end(); it++)
        {
            FIELDS *t = *it;
            if (!strcmp(t -> ctype, "double"))
                fprintf(fil, "\t%s %s;", t -> ctype, t -> column);
            else if (!strcmp(t -> ctype, "long"))
                fprintf(fil, "\t%s %s;", t -> ctype, t -> column);
            else if (!strcmp(t -> ctype, "text"))
                fprintf(fil, "\tchar *%s;", t -> column);
            else if (!strcmp(t -> ctype, "struct"))
            {
                char v_szTmp[64] = {0};
                strcat(v_szTmp, t -> column);
                fprintf(fil, "\t%s %s;", strupr(v_szTmp), t -> column);
            }
            else if (*t -> ctype)
                fprintf(fil, "\tchar %s[%d];", t -> column, t -> length + 1);
            else
                fprintf(fil, "\t// %d - %s %s", t -> num, t -> column, t -> typ);
            if (*t -> comment)
                fprintf(fil, " /* %s */", t -> comment);
            fprintf(fil, "\n");

            if (*t -> comment && (ptrtotable = strstr(t -> comment, "ptrtotable: ")) != NULL)
            {
                strcpy(slask, ptrtotable + 12);	// ptrtoclass
                strlwr(slask);
                strcpy(slask2, slask);
                if (*slask >= 'a' && *slask <= 'z')
                    *slask -= 32;
                fprintf(fil, "\tclass %s *_%s;\n", slask, t -> column);
            }
        }
    }
    fprintf(fil, "\n");


// private
    fprintf(fil, "private:\n");

    fprintf(fil, "\tSGDP::ISDDBConnection* m_poDBConn;\n");
    fprintf(fil, "\tshort new_object;\n");

// clear fields
    fprintf(fil, "\tvoid %s::clear(void) {\n", classname);
    {
        for (fields_l::iterator it = table -> fieldsbase.begin(); it != table -> fieldsbase.end(); it++)
        {
            FIELDS *t = *it;
            if (!strcmp(t -> ctype, "double"))
                fprintf(fil, "\t\t%s = 0;\n", t -> column);
            else if (!strcmp(t -> ctype, "long"))
                fprintf(fil, "\t\t%s = 0;\n", t -> column);
            else if (!strcmp(t -> ctype, "text"))
                fprintf(fil, "\t\t%s = NULL;\n", t -> column);
            else if (!strcmp(t -> ctype, "struct"))
            {
                char v_szTmp[64] = {0};
                strcat(v_szTmp, t -> column);
                fprintf(fil, "\t\tmemset(&%s, 0x00, sizeof(%s));\n", t -> column, strupr(v_szTmp));
            }

            else if (*t -> ctype)
            {
                fprintf(fil, "\t\t*%s = 0;\n", t -> column);
                if (t -> length == 1) // char
                    fprintf(fil, "\t\t%s[1] = 0;\n", t -> column);
            }
            else
                fprintf(fil, "\t\t// %d - %s %s\n", t -> num, t -> column, t -> typ);

            if (*t -> comment && (ptrtotable = strstr(t -> comment, "ptrtotable: ")) != NULL)
            {
                strcpy(slask, ptrtotable + 12);	// ptrtoclass
                strlwr(slask);
                fprintf(fil, "\t\t_%s = NULL;\n", t -> column);
            }
        }
    }
    fprintf(fil, "\t}\n");

// spawn from query
    fprintf(fil, "\tBOOL %s::spawn(char *sql) {\n", classname);
    fprintf(fil, "\t\tstring strError;\n");
    fprintf(fil, "\t\tISDDBRecordSet* pRecordSet = NULL;\n");

    fprintf(fil, "\t\tINT32 nRet = m_poDBConn->ExecuteSqlRs(sql, &pRecordSet, 0, &strError );\n");
    fprintf(fil, "\t\tif((SDDB_HAS_RECORDSET == nRet) && (pRecordSet->GetRecord()))\n");

    fprintf(fil, "\t\t{\n");
    {
        for (fields_l::iterator it = table -> fieldsbase.begin(); it != table -> fieldsbase.end(); it++)
        {
            FIELDS *t = *it;
            if (*t -> ctype)
            {
                if (!strcmp(t -> ctype, "double"))
                {
                    fprintf(fil, "\t\t\t%s = SDStrtod(pRecordSet->GetFieldValueByName(\"%s\"));\n", t -> column, t -> column);
                }
                else if (!strcmp(t -> ctype, "long"))
                {
                    fprintf(fil, "\t\t\t%s = SDAtou64(pRecordSet->GetFieldValueByName(\"%s\"));\n", t -> column, t -> column);
                }
                else if (!strcmp(t -> ctype, "text"))
                {
                    fprintf(fil, "\t\t\tstrcpy(%s, pRecordSet->GetFieldValueByName(\"%s\"));\n", t -> column, t -> column);
                }
                else if (!strcmp(t -> ctype, "struct"))
                {
					fprintf(fil, "\t\t\t{\n");
					fprintf(fil, "\t\t\t\tINT32 dwLen = pRecordSet->GetFieldLengthByName( \"%s\" );\n", t -> column);
                    fprintf(fil, "\t\t\t\tif (0 != dwLen)\n");
                    fprintf(fil, "\t\t\t\t{\n");
                    fprintf(fil, "\t\t\t\t\tif( -1 == %s.DecodeSaveData( pRecordSet->GetFieldValueByName(\"%s\"), dwLen ) )\n", t -> column, t -> column);
                    fprintf(fil, "\t\t\t\t\t{\n");
                    fprintf(fil, "\t\t\t\t\t\treturn FALSE;\n");
                    fprintf(fil, "\t\t\t\t\t}\n");
                    fprintf(fil, "\t\t\t\t}\n");
                    fprintf(fil, "\t\t\t}\n");
                }
                else if (!strncmp(t -> ctype, "char", 4))
                {
					fprintf(fil, "\t\t\t{\n");
                    fprintf(fil, "\t\t\t\tINT32 nLen = pRecordSet->GetFieldLengthByName(\"%s\");\n", t -> column);
                    fprintf(fil, "\t\t\t\tnLen = nLen >= sizeof(%s) ? (sizeof(%s) - 1) : nLen;\n", t -> column, t -> column);
                    fprintf(fil, "\t\t\t\tSDStrncpy(%s, pRecordSet->GetFieldValueByName(\"%s\"), nLen);\n", t -> column, t -> column);
					fprintf(fil, "\t\t\t}\n");
                }
                else
                {

                }
                fprintf(fil, "\n");
            }
            else
            {
                fprintf(fil, "\t\t\t// %d - %s %s\n", t -> num, t -> column, t -> typ);
            }
        }
    }

    fprintf(fil, "\t\t\tnew_object = 0;\n");
    fprintf(fil, "\t\t}\n");
	fprintf(fil, "\t\telse\n");
	fprintf(fil, "\t\t{\n");
    fprintf(fil, "\t\t\tclear();\n");
	fprintf(fil, "\t\t}\n");

	fprintf(fil, "\t\tif(NULL != pRecordSet)\n");
	fprintf(fil, "\t\t{\n");
	fprintf(fil, "\t\t	pRecordSet->Release();\n");
	fprintf(fil, "\t\t	pRecordSet = NULL;\n");
	fprintf(fil, "\t\t}\n");

    fprintf(fil, "\t}\n");
    fprintf(fil, "\n");



    fprintf(fil, "\n");

    fprintf(fil, "}; // End of class '%s'\n", classname);
    fprintf(fil, "\n");


    ///*
    // * Create container class (see container.h for an example)
    // */

    ///*
    //typedef enum {
    //		TK_OPTION_BOOLEAN,
    //		TK_OPTION_INT,
    //		TK_OPTION_DOUBLE,
    //		TK_OPTION_STRING,
    //		TK_OPTION_STRING_TABLE,
    //		TK_OPTION_COLOR,
    //		TK_OPTION_FONT,
    //		TK_OPTION_BITMAP,
    //		TK_OPTION_BORDER,
    //		TK_OPTION_RELIEF,
    //		TK_OPTION_CURSOR,
    //		TK_OPTION_JUSTIFY,
    //		TK_OPTION_ANCHOR,
    //		TK_OPTION_SYNONYM,
    //		TK_OPTION_PIXELS,
    //		TK_OPTION_WINDOW,
    //		TK_OPTION_END
    //} Tk_OptionType;
    //*/

    //sprintf(cclassname, "c%s", classname);	// container class name
    //if (!strcmp(classname + strlen(classname) - 2, "ss"))
    //    sprintf(cstruct, "c%struct", classname);
    //else
    //    sprintf(cstruct, "c%sstruct", classname); // container struct

    //fprintf(fil, "\ttypedef struct %s\n", cstruct);
    //fprintf(fil, "\t{\n");
    //fprintf(fil, "\t\tstruct %s *next;\n", cstruct);
    //fprintf(fil, "\t\t%s *%s;\n", classname, lwrclassname);
    //fprintf(fil, "\t};\n");
    //fprintf(fil, "\n");



    //fprintf(fil, "#ifndef _LISTTYPE\n");
    //fprintf(fil, "#define _LISTTYPE\n");
    //fprintf(fil, "\ttypedef enum { Direct, InDirect } ListType;\n");
    //fprintf(fil, "#endif\n");
    //fprintf(fil, "\n");

    //fprintf(fil, "class %s {\n", cclassname);
    //fprintf(fil, "public:\n");

    //// constructor cclassname(db) - empty list
    //fprintf(fil, "\t%s::%s(Database *db,ListType lt) {\n", cclassname, cclassname);
    //fprintf(fil, "\t\tdatabase = db;\n");
    //fprintf(fil, "\t\tbase = NULL;\n");
    //fprintf(fil, "\t\t%ss = NULL;\n", lwrclassname);
    //fprintf(fil, "\t\tqty = 0;\n");
    //fprintf(fil, "\t\t_lt = lt;\n");
    //fprintf(fil, "\t}\n");
    //fprintf(fil, "\n");

    //// constructor cclassname(db,sql)
    //fprintf(fil, "\t%s::%s(Database *db,char *sql,ListType lt) {\n", cclassname, cclassname);
    //fprintf(fil, "\t\tQuery q(db);\n");
    //fprintf(fil, "\t\t%s *item,*p;\n", cstruct);
    //fprintf(fil, "\t\tlong l;\n");
    //fprintf(fil, "\n");
    //fprintf(fil, "\t\tdatabase = db;\n");
    //fprintf(fil, "\t\tbase = NULL;\n");
    //fprintf(fil, "\t\t%ss = NULL;\n", lwrclassname);
    //fprintf(fil, "\t\tqty = 0;\n");
    //fprintf(fil, "\t\t_lt = lt;\n");
    //fprintf(fil, "\n");
    //fprintf(fil, "\t\tq.get_result(sql);\n");
    //fprintf(fil, "\t\twhile (q.fetch_row())\n");
    //fprintf(fil, "\t\t{\n");
    //fprintf(fil, "\t\t\titem = new %s;\n", cstruct);
    //fprintf(fil, "\t\t\titem -> next = NULL;\n");
    //fprintf(fil, "\t\t\titem -> %s = new %s(db,q.getval());\n", lwrclassname, classname);
    //fprintf(fil, "\t\t\tif (!base)\n");
    //fprintf(fil, "\t\t\t\tbase = item;\n");
    //fprintf(fil, "\t\t\telse\n");
    //fprintf(fil, "\t\t\t{\n");
    //fprintf(fil, "\t\t\t\tp = base;\n");
    //fprintf(fil, "\t\t\t\twhile (p -> next)\n");
    //fprintf(fil, "\t\t\t\t\tp = p -> next;\n");
    //fprintf(fil, "\t\t\t\tp -> next = item;\n");
    //fprintf(fil, "\t\t\t}\n");
    //fprintf(fil, "\t\t\tqty++;\n");
    //fprintf(fil, "\t\t}\n");
    //fprintf(fil, "\t\tq.free_result();\n");
    //fprintf(fil, "\n");
    //fprintf(fil, "\t\t%ss = new %s *[qty];\n", lwrclassname, classname);
    //fprintf(fil, "\t\tl = 0;\n");
    //fprintf(fil, "\t\tfor (p = base; p; p = p -> next)\n");
    //fprintf(fil, "\t\t\t%ss[l++] = p -> %s;\n", lwrclassname, lwrclassname);
    //fprintf(fil, "\t}\n");
    //fprintf(fil, "\n");

    //// destructor
    //fprintf(fil, "\t%s::~%s(void) {\n", cclassname, cclassname);
    //fprintf(fil, "\t\t%s *q,*tmp;\n", cstruct);
    //fprintf(fil, "\t\tfor (q = base; q; q = tmp)\n");
    //fprintf(fil, "\t\t{\n");
    //fprintf(fil, "\t\t\tif (_lt == Direct)\n");
    //fprintf(fil, "\t\t\t\tdelete q -> %s;\n", lwrclassname);
    //fprintf(fil, "\t\t\ttmp = q -> next;\n");
    //fprintf(fil, "\t\t\tdelete q;\n");
    //fprintf(fil, "\t\t}\n");
    //fprintf(fil, "\t\tdelete %ss;\n", lwrclassname);
    //fprintf(fil, "\t}\n");
    //fprintf(fil, "\n");

    //// save()
    //fprintf(fil, "\tvoid %s::save(void) {\n", cclassname);
    //fprintf(fil, "\t\t%s *q;\n", cstruct);
    //fprintf(fil, "\t\tfor (q = base; q; q = q -> next)\n");
    //fprintf(fil, "\t\t\tq -> %s -> save();\n", lwrclassname);
    //fprintf(fil, "\t}\n");
    //fprintf(fil, "\n");

    //// baseptr()
    //fprintf(fil, "\t%s *%s::baseptr(void) {\n", cstruct, cclassname);
    //fprintf(fil, "\t\treturn base;\n");
    //fprintf(fil, "\t}\n");
    //fprintf(fil, "\n");

    //// get...()
    //fprintf(fil, "\t%s *%s::get%s(long ix) {\n", classname, cclassname, lwrclassname);
    //fprintf(fil, "\t\treturn %ss[ix];\n", lwrclassname);
    //fprintf(fil, "\t}\n");
    //fprintf(fil, "\n");

    //// add(classname *)
    //fprintf(fil, "\tvoid %s::add(%s *ix) {\n", cclassname, classname);
    //fprintf(fil, "\t\t%s *p,*item = new %s;\n", cstruct, cstruct);
    //fprintf(fil, "\t\tlong l;\n");
    //fprintf(fil, "\n");
    //fprintf(fil, "\t\titem -> next = NULL;\n");
    //fprintf(fil, "\t\titem -> %s = ix;\n", lwrclassname);
    //fprintf(fil, "\t\tif (!base)\n");
    //fprintf(fil, "\t\t\tbase = item;\n");
    //fprintf(fil, "\t\telse\n");
    //fprintf(fil, "\t\t{\n");
    //fprintf(fil, "\t\t\tp = base;\n");
    //fprintf(fil, "\t\t\twhile (p -> next)\n");
    //fprintf(fil, "\t\t\t\tp = p -> next;\n");
    //fprintf(fil, "\t\t\tp -> next = item;\n");
    //fprintf(fil, "\t\t}\n");
    //fprintf(fil, "\t\tqty++;\n");
    //fprintf(fil, "\t\tdelete %ss;\n", lwrclassname);

    //fprintf(fil, "\t\t%ss = new %s *[qty];\n", lwrclassname, classname);
    //fprintf(fil, "\t\tl = 0;\n");
    //fprintf(fil, "\t\tfor (p = base; p; p = p -> next)\n");
    //fprintf(fil, "\t\t\t%ss[l++] = p -> %s;\n", lwrclassname, lwrclassname);

    //fprintf(fil, "\t}\n");
    //fprintf(fil, "\n");

    //// find_...()
    //fprintf(fil, "\t// find_xxx()\n\n");

    //{
    //    for (fields_l::iterator it = table -> fieldsbase.begin(); it != table -> fieldsbase.end(); it++)
    //    {
    //        FIELDS *t = *it;
    //        strcpy(slask, typestring(t));
    //        if (*slask)
    //        {
    //            fprintf(fil, "\t%s *%s::find_%s(%six) {\n", classname, cclassname, t -> column, slask);
    //            fprintf(fil, "\t\t%s *q;\n", cstruct);
    //            fprintf(fil, "\t\tfor (q = base; q; q = q -> next)\n");
    //            if (!strcmp(t -> ctype, "long") || !strcmp(t -> ctype, "double"))
    //                fprintf(fil, "\t\t\tif (q -> %s -> %s == ix)\n", lwrclassname, t -> column);
    //            else
    //                fprintf(fil, "\t\t\tif (!strcasecmp(q -> %s -> %s,ix))\n", lwrclassname, t -> column);
    //            fprintf(fil, "\t\t\t\tbreak;\n");
    //            fprintf(fil, "\t\treturn q ? q -> %s : NULL;\n", lwrclassname);
    //            fprintf(fil, "\t}\n");
    //            fprintf(fil, "\n");
    //        }
    //    }
    //}

    //// private
    //fprintf(fil, "private:\n");
    //fprintf(fil, "\tDatabase *database;\n");
    //fprintf(fil, "\t%s *base;\n", cstruct);
    //fprintf(fil, "\t%s **%ss;\n", classname, lwrclassname);
    //fprintf(fil, "\tlong qty;\n");
    //fprintf(fil, "\tListType _lt;\n");
    //fprintf(fil, "\n");
    //fprintf(fil, "}; // End of class '%s'\n", cclassname);
    //fprintf(fil, "\n");

    fprintf(fil, "#endif // %s\n", define);
    fclose(fil);
}


/*
 * End of class generation
 */


/*
class Example {
public:
	Example::Example(void) {
	}
	Example::Example(Database *db,long ix) {
		Query q(db);
		char sql[200];
		sprintf(sql,"select * from example where num=%ld",ix);
		q.get_result(sql);
		while (q.fetch_row())
		{
			num = q.getval(0);
			strcpy(name,q.getstr(1));
		}
		q.free_result();
	}
	Example::~Example(void) {
	}
// variables are public
	long num;
	char name[200];
};

*/



