// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: client.proto

#ifndef PROTOBUF_client_2eproto__INCLUDED
#define PROTOBUF_client_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_client_2eproto();
void protobuf_AssignDesc_client_2eproto();
void protobuf_ShutdownFile_client_2eproto();

class EncryptKeyNtf;
class LoginReq;

enum LoginReq_LoginType {
  LoginReq_LoginType_NewRole = 0,
  LoginReq_LoginType_OldRole = 1
};
bool LoginReq_LoginType_IsValid(int value);
const LoginReq_LoginType LoginReq_LoginType_LoginType_MIN = LoginReq_LoginType_NewRole;
const LoginReq_LoginType LoginReq_LoginType_LoginType_MAX = LoginReq_LoginType_OldRole;
const int LoginReq_LoginType_LoginType_ARRAYSIZE = LoginReq_LoginType_LoginType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginReq_LoginType_descriptor();
inline const ::std::string& LoginReq_LoginType_Name(LoginReq_LoginType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginReq_LoginType_descriptor(), value);
}
inline bool LoginReq_LoginType_Parse(
    const ::std::string& name, LoginReq_LoginType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginReq_LoginType>(
    LoginReq_LoginType_descriptor(), name, value);
}
enum EncryptKeyDef {
  EncryptKeyLen = 32,
  EncryptHeadLen = 2,
  EncryptTailLen = 4
};
bool EncryptKeyDef_IsValid(int value);
const EncryptKeyDef EncryptKeyDef_MIN = EncryptHeadLen;
const EncryptKeyDef EncryptKeyDef_MAX = EncryptKeyLen;
const int EncryptKeyDef_ARRAYSIZE = EncryptKeyDef_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncryptKeyDef_descriptor();
inline const ::std::string& EncryptKeyDef_Name(EncryptKeyDef value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncryptKeyDef_descriptor(), value);
}
inline bool EncryptKeyDef_Parse(
    const ::std::string& name, EncryptKeyDef* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncryptKeyDef>(
    EncryptKeyDef_descriptor(), name, value);
}
// ===================================================================

class EncryptKeyNtf : public ::google::protobuf::Message {
 public:
  EncryptKeyNtf();
  virtual ~EncryptKeyNtf();

  EncryptKeyNtf(const EncryptKeyNtf& from);

  inline EncryptKeyNtf& operator=(const EncryptKeyNtf& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EncryptKeyNtf& default_instance();

  void Swap(EncryptKeyNtf* other);

  // implements Message ----------------------------------------------

  EncryptKeyNtf* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EncryptKeyNtf& from);
  void MergeFrom(const EncryptKeyNtf& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string encryptKey = 1;
  inline bool has_encryptkey() const;
  inline void clear_encryptkey();
  static const int kEncryptKeyFieldNumber = 1;
  inline const ::std::string& encryptkey() const;
  inline void set_encryptkey(const ::std::string& value);
  inline void set_encryptkey(const char* value);
  inline void set_encryptkey(const char* value, size_t size);
  inline ::std::string* mutable_encryptkey();
  inline ::std::string* release_encryptkey();
  inline void set_allocated_encryptkey(::std::string* encryptkey);

  // @@protoc_insertion_point(class_scope:EncryptKeyNtf)
 private:
  inline void set_has_encryptkey();
  inline void clear_has_encryptkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encryptkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static EncryptKeyNtf* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::Message {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoginReq_LoginType LoginType;
  static const LoginType NewRole = LoginReq_LoginType_NewRole;
  static const LoginType OldRole = LoginReq_LoginType_OldRole;
  static inline bool LoginType_IsValid(int value) {
    return LoginReq_LoginType_IsValid(value);
  }
  static const LoginType LoginType_MIN =
    LoginReq_LoginType_LoginType_MIN;
  static const LoginType LoginType_MAX =
    LoginReq_LoginType_LoginType_MAX;
  static const int LoginType_ARRAYSIZE =
    LoginReq_LoginType_LoginType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LoginType_descriptor() {
    return LoginReq_LoginType_descriptor();
  }
  static inline const ::std::string& LoginType_Name(LoginType value) {
    return LoginReq_LoginType_Name(value);
  }
  static inline bool LoginType_Parse(const ::std::string& name,
      LoginType* value) {
    return LoginReq_LoginType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required int32 clientVersion = 1;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 1;
  inline ::google::protobuf::int32 clientversion() const;
  inline void set_clientversion(::google::protobuf::int32 value);

  // required string deviceid = 2;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceidFieldNumber = 2;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // required string notifyid = 3;
  inline bool has_notifyid() const;
  inline void clear_notifyid();
  static const int kNotifyidFieldNumber = 3;
  inline const ::std::string& notifyid() const;
  inline void set_notifyid(const ::std::string& value);
  inline void set_notifyid(const char* value);
  inline void set_notifyid(const char* value, size_t size);
  inline ::std::string* mutable_notifyid();
  inline ::std::string* release_notifyid();
  inline void set_allocated_notifyid(::std::string* notifyid);

  // required string username = 4;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 4;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // required int32 zoneid = 5;
  inline bool has_zoneid() const;
  inline void clear_zoneid();
  static const int kZoneidFieldNumber = 5;
  inline ::google::protobuf::int32 zoneid() const;
  inline void set_zoneid(::google::protobuf::int32 value);

  // required int32 userid = 6;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUseridFieldNumber = 6;
  inline ::google::protobuf::int32 userid() const;
  inline void set_userid(::google::protobuf::int32 value);

  // required int32 playerid = 7;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayeridFieldNumber = 7;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // required string job = 8;
  inline bool has_job() const;
  inline void clear_job();
  static const int kJobFieldNumber = 8;
  inline const ::std::string& job() const;
  inline void set_job(const ::std::string& value);
  inline void set_job(const char* value);
  inline void set_job(const char* value, size_t size);
  inline ::std::string* mutable_job();
  inline ::std::string* release_job();
  inline void set_allocated_job(::std::string* job);

  // required .LoginReq.LoginType loginType = 9;
  inline bool has_logintype() const;
  inline void clear_logintype();
  static const int kLoginTypeFieldNumber = 9;
  inline ::LoginReq_LoginType logintype() const;
  inline void set_logintype(::LoginReq_LoginType value);

  // required int32 authType = 10;
  inline bool has_authtype() const;
  inline void clear_authtype();
  static const int kAuthTypeFieldNumber = 10;
  inline ::google::protobuf::int32 authtype() const;
  inline void set_authtype(::google::protobuf::int32 value);

  // required string authKey = 11;
  inline bool has_authkey() const;
  inline void clear_authkey();
  static const int kAuthKeyFieldNumber = 11;
  inline const ::std::string& authkey() const;
  inline void set_authkey(const ::std::string& value);
  inline void set_authkey(const char* value);
  inline void set_authkey(const char* value, size_t size);
  inline ::std::string* mutable_authkey();
  inline ::std::string* release_authkey();
  inline void set_allocated_authkey(::std::string* authkey);

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_notifyid();
  inline void clear_has_notifyid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_zoneid();
  inline void clear_has_zoneid();
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_job();
  inline void clear_has_job();
  inline void set_has_logintype();
  inline void clear_has_logintype();
  inline void set_has_authtype();
  inline void clear_has_authtype();
  inline void set_has_authkey();
  inline void clear_has_authkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deviceid_;
  ::std::string* notifyid_;
  ::google::protobuf::int32 clientversion_;
  ::google::protobuf::int32 zoneid_;
  ::std::string* username_;
  ::google::protobuf::int32 userid_;
  ::google::protobuf::int32 playerid_;
  ::std::string* job_;
  int logintype_;
  ::google::protobuf::int32 authtype_;
  ::std::string* authkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_client_2eproto();
  friend void protobuf_AssignDesc_client_2eproto();
  friend void protobuf_ShutdownFile_client_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// ===================================================================


// ===================================================================

// EncryptKeyNtf

// required string encryptKey = 1;
inline bool EncryptKeyNtf::has_encryptkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EncryptKeyNtf::set_has_encryptkey() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EncryptKeyNtf::clear_has_encryptkey() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EncryptKeyNtf::clear_encryptkey() {
  if (encryptkey_ != &::google::protobuf::internal::kEmptyString) {
    encryptkey_->clear();
  }
  clear_has_encryptkey();
}
inline const ::std::string& EncryptKeyNtf::encryptkey() const {
  return *encryptkey_;
}
inline void EncryptKeyNtf::set_encryptkey(const ::std::string& value) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(value);
}
inline void EncryptKeyNtf::set_encryptkey(const char* value) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(value);
}
inline void EncryptKeyNtf::set_encryptkey(const char* value, size_t size) {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  encryptkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EncryptKeyNtf::mutable_encryptkey() {
  set_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    encryptkey_ = new ::std::string;
  }
  return encryptkey_;
}
inline ::std::string* EncryptKeyNtf::release_encryptkey() {
  clear_has_encryptkey();
  if (encryptkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encryptkey_;
    encryptkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EncryptKeyNtf::set_allocated_encryptkey(::std::string* encryptkey) {
  if (encryptkey_ != &::google::protobuf::internal::kEmptyString) {
    delete encryptkey_;
  }
  if (encryptkey) {
    set_has_encryptkey();
    encryptkey_ = encryptkey;
  } else {
    clear_has_encryptkey();
    encryptkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginReq

// required int32 clientVersion = 1;
inline bool LoginReq::has_clientversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_clientversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_clientversion() {
  clientversion_ = 0;
  clear_has_clientversion();
}
inline ::google::protobuf::int32 LoginReq::clientversion() const {
  return clientversion_;
}
inline void LoginReq::set_clientversion(::google::protobuf::int32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// required string deviceid = 2;
inline bool LoginReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& LoginReq::deviceid() const {
  return *deviceid_;
}
inline void LoginReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void LoginReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* LoginReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string notifyid = 3;
inline bool LoginReq::has_notifyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReq::set_has_notifyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReq::clear_has_notifyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReq::clear_notifyid() {
  if (notifyid_ != &::google::protobuf::internal::kEmptyString) {
    notifyid_->clear();
  }
  clear_has_notifyid();
}
inline const ::std::string& LoginReq::notifyid() const {
  return *notifyid_;
}
inline void LoginReq::set_notifyid(const ::std::string& value) {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  notifyid_->assign(value);
}
inline void LoginReq::set_notifyid(const char* value) {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  notifyid_->assign(value);
}
inline void LoginReq::set_notifyid(const char* value, size_t size) {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  notifyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_notifyid() {
  set_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    notifyid_ = new ::std::string;
  }
  return notifyid_;
}
inline ::std::string* LoginReq::release_notifyid() {
  clear_has_notifyid();
  if (notifyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notifyid_;
    notifyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_notifyid(::std::string* notifyid) {
  if (notifyid_ != &::google::protobuf::internal::kEmptyString) {
    delete notifyid_;
  }
  if (notifyid) {
    set_has_notifyid();
    notifyid_ = notifyid;
  } else {
    clear_has_notifyid();
    notifyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string username = 4;
inline bool LoginReq::has_username() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReq::set_has_username() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReq::clear_has_username() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReq::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& LoginReq::username() const {
  return *username_;
}
inline void LoginReq::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginReq::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void LoginReq::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* LoginReq::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 zoneid = 5;
inline bool LoginReq::has_zoneid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginReq::set_has_zoneid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginReq::clear_has_zoneid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginReq::clear_zoneid() {
  zoneid_ = 0;
  clear_has_zoneid();
}
inline ::google::protobuf::int32 LoginReq::zoneid() const {
  return zoneid_;
}
inline void LoginReq::set_zoneid(::google::protobuf::int32 value) {
  set_has_zoneid();
  zoneid_ = value;
}

// required int32 userid = 6;
inline bool LoginReq::has_userid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginReq::set_has_userid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginReq::clear_userid() {
  userid_ = 0;
  clear_has_userid();
}
inline ::google::protobuf::int32 LoginReq::userid() const {
  return userid_;
}
inline void LoginReq::set_userid(::google::protobuf::int32 value) {
  set_has_userid();
  userid_ = value;
}

// required int32 playerid = 7;
inline bool LoginReq::has_playerid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginReq::set_has_playerid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginReq::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginReq::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 LoginReq::playerid() const {
  return playerid_;
}
inline void LoginReq::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required string job = 8;
inline bool LoginReq::has_job() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginReq::set_has_job() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginReq::clear_has_job() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginReq::clear_job() {
  if (job_ != &::google::protobuf::internal::kEmptyString) {
    job_->clear();
  }
  clear_has_job();
}
inline const ::std::string& LoginReq::job() const {
  return *job_;
}
inline void LoginReq::set_job(const ::std::string& value) {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  job_->assign(value);
}
inline void LoginReq::set_job(const char* value) {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  job_->assign(value);
}
inline void LoginReq::set_job(const char* value, size_t size) {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  job_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_job() {
  set_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    job_ = new ::std::string;
  }
  return job_;
}
inline ::std::string* LoginReq::release_job() {
  clear_has_job();
  if (job_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = job_;
    job_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_job(::std::string* job) {
  if (job_ != &::google::protobuf::internal::kEmptyString) {
    delete job_;
  }
  if (job) {
    set_has_job();
    job_ = job;
  } else {
    clear_has_job();
    job_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .LoginReq.LoginType loginType = 9;
inline bool LoginReq::has_logintype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoginReq::set_has_logintype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoginReq::clear_has_logintype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoginReq::clear_logintype() {
  logintype_ = 0;
  clear_has_logintype();
}
inline ::LoginReq_LoginType LoginReq::logintype() const {
  return static_cast< ::LoginReq_LoginType >(logintype_);
}
inline void LoginReq::set_logintype(::LoginReq_LoginType value) {
  assert(::LoginReq_LoginType_IsValid(value));
  set_has_logintype();
  logintype_ = value;
}

// required int32 authType = 10;
inline bool LoginReq::has_authtype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoginReq::set_has_authtype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoginReq::clear_has_authtype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoginReq::clear_authtype() {
  authtype_ = 0;
  clear_has_authtype();
}
inline ::google::protobuf::int32 LoginReq::authtype() const {
  return authtype_;
}
inline void LoginReq::set_authtype(::google::protobuf::int32 value) {
  set_has_authtype();
  authtype_ = value;
}

// required string authKey = 11;
inline bool LoginReq::has_authkey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoginReq::set_has_authkey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoginReq::clear_has_authkey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoginReq::clear_authkey() {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    authkey_->clear();
  }
  clear_has_authkey();
}
inline const ::std::string& LoginReq::authkey() const {
  return *authkey_;
}
inline void LoginReq::set_authkey(const ::std::string& value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void LoginReq::set_authkey(const char* value) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(value);
}
inline void LoginReq::set_authkey(const char* value, size_t size) {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  authkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginReq::mutable_authkey() {
  set_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    authkey_ = new ::std::string;
  }
  return authkey_;
}
inline ::std::string* LoginReq::release_authkey() {
  clear_has_authkey();
  if (authkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authkey_;
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginReq::set_allocated_authkey(::std::string* authkey) {
  if (authkey_ != &::google::protobuf::internal::kEmptyString) {
    delete authkey_;
  }
  if (authkey) {
    set_has_authkey();
    authkey_ = authkey;
  } else {
    clear_has_authkey();
    authkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LoginReq_LoginType>() {
  return ::LoginReq_LoginType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EncryptKeyDef>() {
  return ::EncryptKeyDef_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_client_2eproto__INCLUDED
